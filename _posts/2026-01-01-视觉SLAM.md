---
layout: post
title: "视觉SLAM"
date:   2026-01-01
tags: [SLAM]
comments: true
author: kwanwaipang
toc: true
excerpt: "" # 【指定摘要内容】
---

<!-- * 目录
{:toc} -->

* [原博客](https://kwanwaipang.github.io/File/Blogs/Poster/%E8%A7%86%E8%A7%89SLAM.html)

<div id="target-content-placeholder">正在加载...</div>

<!-- 目录容器 -->
<div id="custom-toc" class="toc">
  <h3>目录</h3>
  <ul id="toc-list"></ul>
</div>

<script>
(function() {
  // 1. 核心去重：检查全局变量，如果已存在则代表已经渲染过一次，立即销毁当前脚本
  if (window.__LIDAR_BLOG_LOADED__) return;

  // 2. 只有在详情页（即 URL 包含日期或标题）时才运行，防止首页误触发
  if (window.location.pathname === '/' || window.location.pathname.includes('index.html')) return;

  // 3. 锁定状态
  window.__LIDAR_BLOG_LOADED__ = true;

  const baseUrl = '/File/Blogs/Poster/'; 
  const filePath = baseUrl + '视觉SLAM.html';

  fetch(filePath)
    .then(res => res.text())
    .then(html => {
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');

      // 移除干扰元素
      const toRemove = ['header', '.navbar', '.post-header', '#toc', '#newToc', '#toggleTocButton', '#scrollToTocButton', 'footer'];
      toRemove.forEach(s => doc.querySelectorAll(s).forEach(el => el.remove()));

      // 提取内容中的标题用于生成目录
      const headings = doc.querySelectorAll('h1, h2, h3, h4, h5, h6');
      const tocList = document.getElementById('toc-list');
      
      if (tocList && headings.length > 0) {
        tocList.innerHTML = generateToc(headings);
      }

      // 路径转换
      const rawBody = doc.body.innerHTML;
      const processedHtml = rawBody.replace(/(src|href)="(?!(http|https|\/|#))/g, `$1="${baseUrl}`);

      // 样式提取
      let styleContent = '';
      doc.querySelectorAll('style, link[rel="stylesheet"]').forEach(s => {
        if (s.tagName === 'LINK') {
          let href = s.getAttribute('href');
          if (!href.startsWith('http') && !href.startsWith('/')) s.setAttribute('href', baseUrl + href);
        }
        styleContent += s.outerHTML;
      });

      // 4. 精准挂载：始终寻找页面中的第一个占位符进行渲染
      const target = document.getElementById('target-content-placeholder');
      if (target) {
        const shadow = target.attachShadow({ mode: 'open' });
        shadow.innerHTML = styleContent + processedHtml;
        target.childNodes[0].textContent = ""; 
      }
    })
    .catch(err => {
      console.error('加载博客内容失败:', err);
      const target = document.getElementById('target-content-placeholder');
      if (target) {
        target.innerHTML = '<p>内容加载失败，请稍后重试...</p>';
      }
    });

  // 生成目录的函数
  function generateToc(headings) {
    let tocHtml = '';
    const headingLevels = [];
    
    headings.forEach((heading, index) => {
      const level = parseInt(heading.tagName.charAt(1));
      const text = heading.textContent.trim();
      const id = heading.id || `heading-${index}`;
      
      // 设置ID以便锚点跳转
      if (!heading.id) {
        heading.id = id;
      }
      
      headingLevels.push({ level, text, id });
    });
    
    // 构建嵌套目录结构
    tocHtml = buildNestedToc(headingLevels);
    return tocHtml;
  }
  
  function buildNestedToc(headings) {
    if (headings.length === 0) return '';
    
    let result = '<ul>';
    let currentLevel = headings[0].level;
    let stack = [currentLevel];
    
    headings.forEach((heading, index) => {
      const level = heading.level;
      const text = heading.text;
      const id = heading.id;
      
      if (level > currentLevel) {
        // 增加层级，开始新的子列表
        while (stack[stack.length - 1] < level) {
          result += '<ul>';
          stack.push(stack[stack.length - 1] + 1);
        }
      } else if (level < currentLevel) {
        // 减少层级，关闭多余的列表
        while (stack.length > 0 && stack[stack.length - 1] > level) {
          result += '</ul></li>';
          stack.pop();
        }
      } else if (index > 0) {
        // 同级，关闭上一个li
        result += '</li>';
      }
      
      result += `<li><a href="#${id}">${text}</a>`;
      currentLevel = level;
    });
    
    // 关闭所有剩余的标签
    for (let i = 0; i < stack.length - 1; i++) {
      result += '</li></ul>';
    }
    result += '</li></ul>';
    
    return result;
  }
})();
</script>

<style>
/* 隐藏多余的占位符（如果主题渲染了两次，第二次会被 JS 忽略并由 CSS 隐藏） */
#target-content-placeholder:not(:first-of-type) {
  display: none !important;
}
#target-content-placeholder {
  width: 100%;
  position: relative;
}

/* 目录样式 */
.toc {
  background-color: #f8f9fa;
  border: 1px solid #e9ecef;
  border-radius: 0.375rem;
  padding: 1rem;
  margin: 1.5rem 0;
  max-width: 400px;
  float: right;
  margin-left: 1rem;
}

.toc h3 {
  margin-top: 0;
  color: #495057;
  font-size: 1.1rem;
  border-bottom: 1px solid #dee2e6;
  padding-bottom: 0.5rem;
}

.toc ul {
  list-style-type: none;
  padding-left: 1rem;
  margin: 0.5rem 0;
}

.toc li {
  margin: 0.25rem 0;
}

.toc a {
  color: #0d6efd;
  text-decoration: none;
  display: block;
  padding: 0.125rem 0;
  transition: color 0.15s ease-in-out;
}

.toc a:hover {
  color: #0a58ca;
  text-decoration: underline;
}

/* 清除浮动 */
.clearfix::after {
  content: "";
  display: table;
  clear: both;
}

/* 响应式调整 */
@media (max-width: 768px) {
  .toc {
    float: none;
    margin-left: 0;
    max-width: 100%;
  }
}
</style>

<div class="clearfix"></div>



