---
layout: post
title: "论文阅读笔记中——《D-LIOM: Tightly-Coupled Direct LiDAR-Inertial Odometry and Mapping》"
date:   2025-12-05
tags: [SLAM, LiDAR]
comments: true
author: kwanwaipang
toc: true
---


<!-- * 目录
{:toc} -->

D-LIOM是22年的Transactions on Multimedia,采用的是cartographer+IMU预积分紧耦合的形式。

* [PDF](https://www.fst.um.edu.mo/personal/wp-content/uploads/2023/09/DLIOM.pdf)
* [github](https://github.com/peterWon/D-LIOM)


# 原理解读
D-LIOM的主要特点如下：
* 直接法，雷达原始的扫描点与probability submap进行register
* lidar odometry、IMU预积分、重力约束整合一起构建局部因子图（submap’s time window），同时矫正IMU的biases，online gravity估计（限制roll与pitch的漂移，也可以较好的实现将3D submap投影到2D平面实现回环）；
* 通过2D submaps（用的cartographer的回环检测）的相互匹配实现回环检测
* 支持多个雷达输入、雷达与6轴IMU的初始。
* 对于点云去失真，用的是上一时刻优化后的状态以及biases，然后通过IMU预积分进行去畸变。


<div align="center">
  <img src="../images/微信截图_20251208095004.png" width="90%" />
<figcaption>  
</figcaption>
</div>

* 对于lidar odometry采用的是occupied voxel map；
* 回环检测采用的提取3D submap投影的2D image，对2D image进行特征点匹配

<div align="center">
  <img src="../images/微信截图_20251208141309.png" width="80%" />
<figcaption>  
</figcaption>
</div>


<div align="center">
  <img src="../images/微信截图_20251208141509.png" width="80%" />
<figcaption>  
</figcaption>
</div>

# 代码阅读

## 类概述

这是 Cartographer 3D SLAM 的核心组件，特点：
* 3D 环境建图：处理三维点云数据
* IMU 融合：紧耦合 IMU-激光雷达
* 多分辨率优化：使用高分辨率和低分辨率栅格
* 在线重力估计：动态估计重力方向

## 构造函数详细分析

```cpp
LocalTrajectoryBuilder3D::LocalTrajectoryBuilder3D(
    const mapping::proto::LocalTrajectoryBuilderOptions3D& options,
    const std::vector<std::string>& expected_range_sensor_ids)
    : options_(options),
      active_submaps_(options.submaps_options()),  // 3D 子图管理器
      motion_filter_(options.motion_filter_options()),  // 运动滤波器
      real_time_correlative_scan_matcher_(
          common::make_unique<scan_matching::RealTimeCorrelativeScanMatcher3D>(
              options_.real_time_correlative_scan_matcher_options())),  // 3D 实时扫描匹配器
      ceres_scan_matcher_(
          common::make_unique<scan_matching::CeresScanMatcher3D>(
              options_.ceres_scan_matcher_options())),  // 3D Ceres 扫描匹配器
      accumulated_range_data_{Eigen::Vector3f::Zero(), {}, {}},  // 累积点云数据
      range_data_synchronizer_(expected_range_sensor_ids)  // 数据同步器
{
    // 从配置中读取参数
    scan_period_ = options_.scan_period();  // 扫描周期
    eable_mannually_discrew_ = options_.eable_mannually_discrew();  // 是否手动去螺钉
    frames_for_static_initialization_ = options_.frames_for_static_initialization();  // 静态初始化帧数
    frames_for_dynamic_initialization_ = options_.frames_for_dynamic_initialization();  // 动态初始化帧数
    g_est_win_size_ = options_.frames_for_online_gravity_estimate();  // 在线重力估计窗口大小
    
    // IMU 参数（从配置文件中读取，比 2D 版本更灵活）
    const float imuAccNoise = options_.imu_options().acc_noise();
    const float imuGyrNoise = options_.imu_options().gyr_noise();
    const float imuAccBiasN = options_.imu_options().acc_bias_noise();
    const float imuGyrBiasN = options_.imu_options().gyr_bias_noise();
    const float imuGravity  = options_.imu_options().gravity();
    const float prior_pose_n = options_.imu_options().prior_pose_noise();
    const float prior_gravity_noise = options_.imu_options().prior_gravity_noise();
    const float ceres_pose_n_t = options_.imu_options().ceres_pose_noise_t();
    const float ceres_pose_n_r = options_.imu_options().ceres_pose_noise_r();
    const float ceres_pose_n_t_1 = options_.imu_options().ceres_pose_noise_t_drift();
    const float ceres_pose_n_r_1 = options_.imu_options().ceres_pose_noise_r_drift();
    
    // GTSAM 预积分参数设置（与 2D 版本类似但为 3D）
    preint_param_ = gtsam::PreintegrationParams::MakeSharedU(imuGravity);
    preint_param_->accelerometerCovariance = gtsam::Matrix33::Identity(3,3) * pow(imuAccNoise, 2);
    preint_param_->gyroscopeCovariance = gtsam::Matrix33::Identity(3,3) * pow(imuGyrNoise, 2);
    preint_param_->integrationCovariance = gtsam::Matrix33::Identity(3,3) * pow(1e-4, 2);
    
    // 噪声模型初始化
    prior_pose_noise_ = gtsam::noiseModel::Diagonal::Sigmas(
        (gtsam::Vector(6) << prior_pose_n, prior_pose_n, prior_pose_n,
         prior_pose_n, prior_pose_n, prior_pose_n).finished());
    prior_vel_noise_ = gtsam::noiseModel::Isotropic::Sigma(3, 1e4);
    prior_bias_noise_ = gtsam::noiseModel::Isotropic::Sigma(6, 1e-2);
    prior_gravity_noise_ = gtsam::noiseModel::Diagonal::Sigmas(
        (gtsam::Vector(2) << prior_gravity_noise, prior_gravity_noise).finished());
    
    // 修正噪声模型（两种级别）
    correction_noise_ = gtsam::noiseModel::Diagonal::Sigmas(
        (gtsam::Vector(6) << ceres_pose_n_t, ceres_pose_n_t, ceres_pose_n_t,
         ceres_pose_n_r, ceres_pose_n_r, ceres_pose_n_r).finished());
    correction_noise_2_ = gtsam::noiseModel::Diagonal::Sigmas(
        (gtsam::Vector(6) << ceres_pose_n_t_1, ceres_pose_n_t_1, ceres_pose_n_t_1,
         ceres_pose_n_r_1, ceres_pose_n_r_1, ceres_pose_n_r_1).finished());
    
    // 偏置噪声模型
    noise_model_between_bias_ = (gtsam::Vector(6) << 
        imuAccBiasN, imuAccBiasN, imuAccBiasN,
        imuGyrBiasN, imuGyrBiasN, imuGyrBiasN).finished();
    
    // VINS 风格积分器初始化（用于动态初始化）
    imu_noise_.ACC_N = imuAccNoise;
    imu_noise_.ACC_W = imuAccBiasN;
    imu_noise_.GYR_N = imuGyrNoise;
    imu_noise_.GYR_W = imuGyrBiasN;
    init_integrator_.reset(new IntegrationBase(INIT_BA, INIT_BW, imu_noise_));
    
    // 初始化环形缓冲区（用于动态初始化）
    InitCircularBuffers();
}
```

## 核心功能详细分析

1. 点云处理流程 (AddRangeData)





下面是融合2D雷达做的改进，具体代码解读如下：

```cpp
//
// Created by luming on 25-12-1.
//

#include "tight_trajectory_builder_2d.h"

namespace cartographer {
namespace mapping {


    TightTrajectoryBuilder2D::TightTrajectoryBuilder2D(
            const proto::LocalTrajectoryBuilderOptions2D &options,
            const std::vector<std::string> &expected_range_sensor_ids) :
            m_options_(options),
            m_active_submaps_(options.submaps_options()),
            m_motion_filter_(options.motion_filter_options()),
            m_real_time_correlative_scan_matcher_(options.real_time_correlative_scan_matcher_options()),
            m_ceres_scan_matcher_(options.ceres_scan_matcher_options()),
            m_range_data_collator_(expected_range_sensor_ids)
    {
        // 雷达扫描频率 10HZ
        scan_period_ = 0.1;
        eable_mannually_discrew_ = false;//是否手动去畸变

        frames_for_static_initialization_ = 15;//静态初始化需要15帧
        frames_for_dynamic_initialization_  = 7; //动态初始化需要7帧

        // IMU噪声参数，都是预定义的
        const float imuAccNoise = 7.4625253996802839e-03;
        const float imuGyrNoise = 3.6757863650655385e-03;
        const float imuAccBiasN = 3.1900854923260527e-04;
        const float imuGyrBiasN = 2.0417634619284984e-05;
        const float imuGravity  = 9.81; //重力参数
        const float prior_pose_n = 1e-2;//pose的噪声
        const float prior_gravity_noise = 0.1;

        // Ceres匹配的噪声参数（两种级别）
        const float ceres_pose_n_t = 5e-2;
        const float ceres_pose_n_r = 5e-2;
        const float ceres_pose_n_t_1 = 3e-1;
        const float ceres_pose_n_r_1 = 1e-1;

        // 一系列噪声模型的初始化（GTSAM预积分参数配置）
        preint_param_ = gtsam::PreintegrationParams::MakeSharedU(imuGravity);
        preint_param_->accelerometerCovariance = gtsam::Matrix33::Identity(3, 3) *
                pow(imuAccNoise, 2);
        preint_param_->gyroscopeCovariance = gtsam::Matrix33::Identity(3, 3) *
                pow(imuGyrNoise, 2);
        preint_param_->integrationCovariance = gtsam::Matrix33::Identity(3, 3) *
                pow(1e-4, 2);

        // 创建各种噪声模型
        // 位姿先验噪声（6自由度，对应平移和旋转）
        prior_pose_noise_  = gtsam::noiseModel::Diagonal::Sigmas(
                (gtsam::Vector(6) << prior_pose_n, prior_pose_n, prior_pose_n,
                        prior_pose_n, prior_pose_n, prior_pose_n).finished());
        
        prior_vel_noise_   = gtsam::noiseModel::Isotropic::Sigma(3, 1e4);//速度的噪声
        prior_bias_noise_  = gtsam::noiseModel::Isotropic::Sigma(6, 1e-2);//bias的噪声

        prior_gravity_noise_ = gtsam::noiseModel::Diagonal::Sigmas(
                (gtsam::Vector(2) << prior_gravity_noise, prior_gravity_noise).finished());//重力先验噪声（2自由度）
        
        // 激光匹配结果噪声模型（紧约束）
        correction_noise_ = gtsam::noiseModel::Diagonal::Sigmas(
                (gtsam::Vector(6) <<
                                  ceres_pose_n_t, ceres_pose_n_t, ceres_pose_n_t,
                        ceres_pose_n_r, ceres_pose_n_r, ceres_pose_n_r).finished());

        // 激光匹配结果噪声模型（松约束，用于漂移检测时）
        correction_noise_2_ = gtsam::noiseModel::Diagonal::Sigmas(
                (gtsam::Vector(6) <<
                                  ceres_pose_n_t_1, ceres_pose_n_t_1, ceres_pose_n_t_1,
                        ceres_pose_n_r_1, ceres_pose_n_r_1, ceres_pose_n_r_1).finished());
        noise_model_between_bias_ = (gtsam::Vector(6) <<
                                                      imuAccBiasN, imuAccBiasN, imuAccBiasN,
                imuGyrBiasN, imuGyrBiasN, imuGyrBiasN).finished();

        // for vins initial integrator initialization（采用VINS的初始化方式）
        imu_noise_.ACC_N = imuAccNoise;
        imu_noise_.ACC_W = imuAccBiasN;
        imu_noise_.GYR_N = imuGyrNoise;
        imu_noise_.GYR_W = imuGyrBiasN;
        // 创建积分器，传入初始偏置（应该是零）和噪声参数
        init_integrator_.reset(new IntegrationBase(INIT_BA, INIT_BW, imu_noise_));

//        InitCircularBuffers();

        SLAM_DEBUG("Initialize Tight trajectory builder Done. ");

    }

    TightTrajectoryBuilder2D::~TightTrajectoryBuilder2D() {}

    sensor::RangeData
    TightTrajectoryBuilder2D::TransfromToGravityAlignedFrameAndFilter(
            const transform::Rigid3f &transfrom_to_gravity_aligned_frame, const sensor::RangeData &range_data) const {
        const sensor::RangeData cropped =
                sensor::CropRangeData(sensor::TransformRangeData(range_data, transfrom_to_gravity_aligned_frame),
                                      m_options_.min_z(), m_options_.max_z());
        return sensor::RangeData{
                cropped.origin,
                sensor::VoxelFilter(cropped.returns, m_options_.voxel_filter_size()),
                sensor::VoxelFilter(cropped.misses, m_options_.voxel_filter_size())
        };
    }


    /**
     * @brief 处理点云数据, 进行扫描匹配, 将点云写成地图
     *
     * @param[in] sensor_id 点云数据对应的话题名称
     * @param[in] unsynchronized_data 传入的点云数据
     * @return std::unique_ptr<LocalTrajectoryBuilder2D::MatchingResult> 匹配后的结果
     */
    std::unique_ptr<TightTrajectoryBuilder2D::MatchingResult>
    TightTrajectoryBuilder2D::AddRangeData(const std::string &sensor_id,
                                                 const sensor::TimedPointCloudData &unsynchronized_data) {

        // Step: 1 进行多个雷达点云数据的时间同步, 点云的坐标是相对于tracking_frame的
        // synchronized_data数据结构{time, origins（点云原点坐标）, ranges（点云数据）}
        auto synchronized_data =
                m_range_data_collator_.AddRangeData(sensor_id, unsynchronized_data);
        
        // 如果同步后数据为空，直接返回
        if (synchronized_data.ranges.empty()) {
            return nullptr;
        }

         // 保存当前点云的时间戳
        const common::Time& time = synchronized_data.time;
        time_point_cloud_ = time;

        // 如果没有初始化完成就直接退出
        if (!imu_initialized_)
        {
            // 确保静态情况下IMU数据足够初始化
            if (accumulated_frame_num++ > frames_for_static_initialization_)
            {
                InitializeStatic();//调用静态初始化
            }
            return nullptr; // 初始化期间不处理点云，因此返回空的
        }

        // 检查点云数据的有效性
        CHECK(!synchronized_data.ranges.empty());//确保非空
        CHECK_LE(synchronized_data.ranges.back().point_time.time, 0.f);
        // 计算第一个点的时间
        const common::Time time_first_point =
                time +
                common::FromSeconds(synchronized_data.ranges.front().point_time.time);

        if (mi_num_accumulated_ == 0)
        {
            accumulation_started_ = std::chrono::steady_clock::now();
        }
        
        // Step 2: 点云体素滤波，减少数据量
        std::vector<sensor::TimedPointCloudOriginData::RangeMeasurement> hits =
                sensor::VoxelFilter(synchronized_data.ranges, m_options_.voxel_filter_size());

        // Step 3: 准备用于运动畸变去除的位姿
        std::vector<transform::Rigid3f> range_data_poses;
        range_data_poses.reserve(hits.size()); // 预分配空间（滤波后的点数）
        transform::Rigid3d tmp_pose; // 临时位姿变量

        // 获取当前预测状态和上一状态，计算相对变换
        transform::Rigid3d cur_state_pre, rel_trans;

        if (predicted_states_.empty()) return nullptr;  // 无预测状态，返回空，如果添加了IMU数据就会有的
        
         // 从GTSAM状态中提取位姿
        cur_state_pre = PoseFromGtsamNavState(predicted_states_.back().second);
        rel_trans = PoseFromGtsamNavState(prev_state_).inverse() * cur_state_pre;//获取相对位姿

        SLAM_INFO("cur_state_pre : [%f, %f], rel_trans : [%f, %f]",
                  cur_state_pre.translation().x(), cur_state_pre.translation().y(),
                  rel_trans.translation().x(), rel_trans.translation().y());

         // Step 4: 为每个激光点计算对应的位姿
        if (std::abs(hits.front().point_time.time) < 1e-3)//这是初始化，所以统一赋予最初的位置
        {
            // 如果第一个点的时间接近0，认为所有点是同一时刻采集的
            SLAM_INFO("hit point time : [%f]", hits.front().point_time.time);
            range_data_poses = std::vector<transform::Rigid3f>(
                    hits.size(), cur_state_pre.cast<float>());// 所有点用同一位姿
        }
        else
        {
             // 需要为每个点插值位姿
            const double sample_period = scan_period_; // 0.1秒
            for (const auto& hit : hits)
            {
                // 计算每个点的绝对时间
                common::Time time_point = time + common::FromSeconds(hit.point_time.time);

                // 计算插值比例 s = (周期 + 点时间) / 周期
                // 假设点云在扫描周期内均匀采集
                double s = (sample_period + hit.point_time.time) / sample_period;
                
                // 插值得到该点时刻的位姿
                InterpolatePose(s, rel_trans, tmp_pose);

                // 结合上一个状态的姿态，然后转换到完整世界坐标系。
                auto pose = (PoseFromGtsamNavState(prev_state_) * tmp_pose).cast<float>();

                SLAM_INFO("pose : [%f, %f], s : [%f]",
                          pose.translation().x(), pose.translation().y(), s);

                range_data_poses.push_back(
                        (PoseFromGtsamNavState(prev_state_) * tmp_pose).cast<float>());
            }
        }

        // Step 5: 清理过时的状态缓存
        TrimStatesCache(time);

        // Step 6: 累积点云处理
        if (mi_num_accumulated_ == 0) {
            m_accumulated_range_data_ = sensor::RangeData{{}, {}, {}};//进行重置为0
        }

         // 遍历所有点，去除运动畸变
        for (size_t i = 0; i < hits.size(); ++i)
        {
            const sensor::TimedRangefinderPoint& hit =
                    hits[i].point_time;

            // 【将激光原点转换到local坐标系】将点云的origins坐标转到 local slam 坐标系下
            const Eigen::Vector3f origin_in_local =
                    range_data_poses[i] *
                    synchronized_data.origins.at(synchronized_data.ranges[i].origin_index);

//          Step: 3 【将激光点转换到local坐标系】运动畸变的去除, 将相对于tracking_frame的hit坐标 转成 local坐标系下的坐标
            sensor::RangefinderPoint hit_in_local =
                    range_data_poses[i] * sensor::ToRangefinderPoint(hit);
            
             // 计算激光射线向量
            const Eigen::Vector3f delta = hit_in_local.position - origin_in_local;

            const float range = delta.norm(); // 距离

            // 根据距离分类处理
            if (range >= m_options_.min_range())//超过最小距离
            {
                if (range <= m_options_.max_range())//同时又在最大距离内
                {
                    m_accumulated_range_data_.returns.push_back(hit_in_local);  // 有效点
                }
                else
                {
//                    hit_in_local.position =
//                            origin_in_local + m_options_.max_range() / range * delta;
                    // 进行截断
                    hit_in_local.position =
                            origin_in_local + m_options_.missing_data_ray_length() / range * delta;

                    m_accumulated_range_data_.misses.push_back(hit_in_local);//无效点
                }
            }
        }

        // Step 7: 有一帧有效的数据了
        ++mi_num_accumulated_;

        // Step 8: 如果累积了足够的帧数，进行扫描匹配  
        // param: num_accumulated_range_data 几帧有效的点云数据进行一次扫描匹配
        if (mi_num_accumulated_ >= m_options_.num_accumulated_range_data()) {

            mi_num_accumulated_ = 0;  // 重置计数器

            // 获取机器人当前姿态（最后一个点的位姿，线性递推的）
            transform::Rigid3f current_pose = range_data_poses.back();

            // （设置累积点云的原点）以最后一个点的时间戳估计出的坐标为这帧数据的原点
            m_accumulated_range_data_.origin = current_pose.translation();

             // 调用处理累积点云的函数
            return AddAccumulatedRangeData(time,
                                           TransfromToGravityAlignedFrameAndFilter(
                                                   current_pose.inverse(), // 转换到重力对齐坐标系
                                                   m_accumulated_range_data_),
                                           current_pose.cast<double>());  // 预测位姿
        }

        return nullptr;  // 还未累积够帧数，返回空
    }
    /**
     * @brief 进行扫描匹配, 将点云写入地图
     *
     * @param[in] time 点云的时间戳
     * @param[in] gravity_aligned_range_data 原点位于local坐标系原点处的点云
     * @param[in] gravity_alignment 机器人当前姿态
     * @param[in] sensor_duration 2帧点云数据的时间差
     * @return std::unique_ptr<LocalTrajectoryBuilder2D::MatchingResult>
     */
    std::unique_ptr<TightTrajectoryBuilder2D::MatchingResult>
    TightTrajectoryBuilder2D::AddAccumulatedRangeData(common::Time time,
                                                            const sensor::RangeData &filtered_range_data_in_tracking,
                                                            const transform::Rigid3d &pose_prediction) {

        // 【检查点云是否有效】如果处理完点云之后数据为空, 就报错. 使用单线雷达时不要设置min_z
        if (filtered_range_data_in_tracking.returns.empty()) {
            SLAM_WARN("Dropped empty horizontal range data. ");
            return nullptr;
        }

        if (filtered_range_data_in_tracking.returns.size() < 50) {
            SLAM_WARN("Miss lots of horizontal range data. ");
            return nullptr;
        }

        transform::Rigid3d pose_estimate; // 估计的位姿

         // Step 1: 自适应体素滤波
        const sensor::PointCloud& filtered_gravity_aligned_point_cloud =
                sensor::AdaptiveVoxelFilter(filtered_range_data_in_tracking.returns,
                                            m_options_.adaptive_voxel_filter_options());
        
        // Step 2: 如果有子图，进行扫描匹配
        if (!m_active_submaps_.submaps().empty())
        {
            // 获取当前子图
            std::shared_ptr<const mapping::Submap2D> matching_submap =
                    m_active_submaps_.submaps().front();

             // 将预测位姿转换到子图坐标系
            transform::Rigid2d initial_ceres_pose =
                    transform::Project2D(matching_submap->local_pose().inverse() * pose_prediction);

            if (filtered_gravity_aligned_point_cloud.empty()) {
                SLAM_WARN("filtered_gravity_aligned_point_cloud is empty. ");
                return nullptr;
            }

            // Step 3: 可选的相关性扫描匹配（提高初始位姿精度）
            if (m_options_.use_online_correlative_scan_matching())
            {
                const transform::Rigid2d initial_pose = initial_ceres_pose;
                double score = m_real_time_correlative_scan_matcher_.Match(initial_pose, filtered_gravity_aligned_point_cloud,
                                                                           *matching_submap->grid(), &initial_ceres_pose);
                current_match_score_ = score;// 保存匹配分数
            }
            transform::Rigid2d pose_observation_in_submap;
            ceres::Solver::Summary summary;

            // Step 4: 使用ceres进行扫描匹配
            m_ceres_scan_matcher_.Match(
                    initial_ceres_pose.translation(), // 初始平移
                    initial_ceres_pose, // 初始位姿
                    filtered_gravity_aligned_point_cloud, // 点云
                    *matching_submap->grid(),  // 子图栅格
                    &pose_observation_in_submap, // 输出：子图坐标系下的位姿
                    &summary);  // 优化摘要
            
            // 将获取的扫描匹配的结果 pose_observation_in_submap 转换回世界坐标系
            pose_estimate = matching_submap->local_pose() * transform::Embed3D(pose_observation_in_submap);
        }
        else  // 没有子图，使用预测值
        {
            SLAM_INFO("m_active_submaps_.submaps() is empty. ");
            pose_estimate = pose_prediction;
        }

//        SLAM_INFO("pose estimate : [%f, %f]", pose_estimate.translation().x(), pose_estimate.translation().y());

         // Step 5: 紧耦合优化
        WindowOptimize(pose_estimate, false);//核心的优化函数

        // 获取优化后的位姿
        auto opt_pose = PoseFromGtsamNavState(prev_state_);

//        SLAM_INFO("opt pose : [%f, %f]", opt_pose.translation().x(), opt_pose.translation().y());

        // Step 6: 重力对齐
        const Eigen::Quaterniond gravity_alignment = opt_pose.rotation();

        // 将点云转换到local坐标系
        sensor::RangeData range_data_in_local =
                sensor::TransformRangeData(filtered_range_data_in_tracking, opt_pose.cast<float>());

        // Step 7: 将range_data_in_local插入子图
        std::unique_ptr<InsertionResult> insert_result = InsertIntoSubmap(
                time, range_data_in_local, filtered_gravity_aligned_point_cloud,
                opt_pose, gravity_alignment);

        // 返回前端扫描匹配结果：获得的pose、局部坐标系的点云、插入子图、匹配状态、匹配分数；
        return absl::make_unique<MatchingResult>(MatchingResult{
                time, opt_pose,
                std::move(range_data_in_local), std::move(insert_result),
                mi_current_match_state, current_match_score_});
    }

    std::unique_ptr<TightTrajectoryBuilder2D::InsertionResult>
    TightTrajectoryBuilder2D::InsertIntoSubmap(common::Time time, const sensor::RangeData &range_data_in_local,
                                                     const sensor::PointCloud &filtered_gravity_aligned_point_cloud,
                                                     const transform::Rigid3d &pose_estimate,
                                                     const Eigen::Quaterniond &gravity_alignment) {
        // 这里可修改对应的条件使得更新地图

        // 如果移动距离过小, 或者时间过短, 不进行地图的更新
        if (m_motion_filter_.IsSimilar(time, pose_estimate)) {
//      LOG(INFO) << "Skip this submap.";
            return nullptr;
        }
        // 将点云数据写入到submap中
        std::vector<std::shared_ptr<const Submap2D>> insertion_submaps =
                m_active_submaps_.InsertRangeData(range_data_in_local);
        // 生成InsertionResult格式的数据进行返回
        return absl::make_unique<InsertionResult>(InsertionResult{
                std::make_shared<const TrajectoryNode::Data>(TrajectoryNode::Data{
                        time,
                        gravity_alignment,
                        filtered_gravity_aligned_point_cloud,  // 这里存的是体素滤波后的点云, 不是校准后的点云
                        pose_estimate}),
                std::move(insertion_submaps)});
    }

    std::unique_ptr<TightTrajectoryBuilder2D::InsertionResult>
    TightTrajectoryBuilder2D::InsertIntoSubmapWithoutNode(common::Time time, const sensor::RangeData &range_data_in_local,
                                                                const sensor::PointCloud &filtered_gravity_aligned_point_cloud,
                                                                const transform::Rigid3d &pose_estimate,
                                                                const Eigen::Quaterniond &gravity_alignment) {
        // 这里可修改对应的条件使得更新地图

        // 如果移动距离过小, 或者时间过短, 不进行地图的更新
        if (m_motion_filter_.IsSimilar(time, pose_estimate)) {
//      LOG(INFO) << "Skip this submap.";
            return nullptr;
        }
        // 将点云数据写入到submap中
        std::vector<std::shared_ptr<const Submap2D>> insertion_submaps =
                m_active_submaps_.submaps();
        // 生成InsertionResult格式的数据进行返回
        return absl::make_unique<InsertionResult>(InsertionResult{
                std::make_shared<const TrajectoryNode::Data>(TrajectoryNode::Data{
                        time,
                        gravity_alignment,
                        filtered_gravity_aligned_point_cloud,  // 这里存的是体素滤波后的点云, 不是校准后的点云
                        pose_estimate}),
                std::move(insertion_submaps)});
    }

    void TightTrajectoryBuilder2D::AddImuData(const sensor::ImuData &imu_data) {

        // 如果还未初始化，则保存IMU数据用来初始化
        if (!imu_initialized_)
        {
            init_imu_buffer_opt_.push_back(imu_data);
        }

        // 如果已经初始化完成并且积分器有效，则进行预积分
        if (imu_initialized_ && imu_integrator_opt_)
        {
            // 计算时间差
            double imu_time = common::ToSecondsStamp(imu_data.time);
            double dt = (last_imu_time_opt_ < 0) ?
                        (1.0 / 200.0) : (imu_time - last_imu_time_opt_);  // 默认200Hz
            last_imu_time_opt_ = imu_time;

            // 积分IMU测量值
            imu_integrator_opt_->integrateMeasurement(
                    gtsam::Vector3(imu_data.linear_acceleration.x(),
                                   imu_data.linear_acceleration.y(),
                                   imu_data.linear_acceleration.z()),
                    gtsam::Vector3(imu_data.angular_velocity.x(),
                                   imu_data.angular_velocity.y(),
                                   imu_data.angular_velocity.z()), dt);

            // 预测当前状态
            gtsam::NavState current_state =
                    imu_integrator_opt_->predict(prev_state_, prev_bias_);

            // 存储递推值用于纠正点云／用于scan matching的prev_state_初始值
            predicted_states_.push_back({imu_data.time, current_state});
        }

    }

    void TightTrajectoryBuilder2D::AddOdometryData(const sensor::OdometryData &odom_data) {
//        if (m_pose_extrapolator_ == nullptr) {
//            SLAM_DEBUG("m_pose_extrapolator_ not yet initialize. ");
//            return;
//        }
//        m_pose_extrapolator_->AddOdometryData(odom_data);

    }


    void TightTrajectoryBuilder2D::InitCircularBuffers() {
        Eigen::Vector3d zero_vec(0., 0., 0.);
        all_laser_transforms_.clear();
        Ps_.clear();
        Rs_.clear();
        Vs_.clear();
        Bas_.clear();
        Bgs_.clear();
        for(size_t i = 0; i < frames_for_dynamic_initialization_+1; ++i){
            all_laser_transforms_.push_back(Rigid3dWithVINSPreintegrator());
            Ps_.push_back(zero_vec);
            Rs_.push_back(Eigen::Matrix3d::Identity());
            Vs_.push_back(zero_vec);
            Bas_.push_back(zero_vec);
            Bgs_.push_back(zero_vec);
        }
    }

    pcl::PointCloud<pcl::PointXYZI>::Ptr TightTrajectoryBuilder2D::cvtPointCloud(
            const cartographer::sensor::TimedPointCloudOriginData& point_cloud)
    {
        pcl::PointCloud<pcl::PointXYZI>::Ptr pcl_cloud;
        pcl_cloud.reset(new pcl::PointCloud<pcl::PointXYZI>());
        pcl_cloud->resize(point_cloud.ranges.size());
        for (size_t i = 0; i < point_cloud.ranges.size(); ++i) {
            const auto& range = point_cloud.ranges.at(i);
            pcl_cloud->points[i].x = range.point_time.position.x();
            pcl_cloud->points[i].y = range.point_time.position.y();
            pcl_cloud->points[i].z = range.point_time.position.z();
            pcl_cloud->points[i].intensity =  range.intensity;
        }

        return pcl_cloud;
    }


    // IMU静态初始化
    void TightTrajectoryBuilder2D::InitializeStatic()
    {
        Eigen::Vector3d accel_accum; // 加速度累积
        Eigen::Vector3d gyro_accum;   // 角速度累积
        int num_readings = 0;

        accel_accum.setZero();
        gyro_accum.setZero();

        // 计算平均值
        for(const auto& entry : init_imu_buffer_opt_){
            accel_accum += entry.linear_acceleration;
            gyro_accum += entry.angular_velocity;
            num_readings++;
        }

        Eigen::Vector3d accel_mean = accel_accum / num_readings;
        Eigen::Vector3d gyro_mean = gyro_accum / num_readings;

         // 重力向量（世界坐标系）
        g_vec_ << 0.0, 0.0, -9.8;

         // 初始状态
        P_.setZero();  // 位置为零
        V_.setZero(); // 速度为零

         // 通过重力方向计算初始姿态
         // FromTwoVectors: 从accel_mean到-g_vec_的旋转
        //frame I to frame G
        R_ = Eigen::Quaternion<double>::FromTwoVectors(accel_mean, -g_vec_);

         // 计算偏置
         // 加速度偏置 = 旋转后的重力 + 测量的加速度均值
        Ba_ = R_.transpose() * g_vec_ + accel_mean;
        Bg_ = gyro_mean;

        // 完成IMU初始化
        InitializeIMU();
    }

    void TightTrajectoryBuilder2D::InitializeIMU()
    {
        // setting up the IMU integration for IMU prediction
        gtsam::imuBias::ConstantBias prior_imu_bias((gtsam::Vector(6)
                << Ba_[0], Ba_[1], Ba_[2], Bg_[0], Bg_[1], Bg_[2]).finished());
        imu_integrator_opt_ =
                new gtsam::PreintegratedImuMeasurements(preint_param_, prior_imu_bias);

        Eigen::Quaterniond q(R_);
        gtsam::Pose3 pose_start = gtsam::Pose3(
                gtsam::Rot3::Quaternion(q.w(), q.x(), q.y(), q.z()),
                gtsam::Point3(P_.x(), P_.y(), P_.z()));
        gtsam::Velocity3 v_start = gtsam::Velocity3(V_[0], V_[1], V_[2]);
        LOG(INFO)<<"Initialization paras: ";
        LOG(INFO)<<"P: "<<P_.x()<<","<<P_.y()<<","<<P_.z();
        LOG(INFO)<<"V: "<<V_[0]<<","<<V_[1]<<","<<V_[2];
        LOG(INFO)<<"Q: "<<q.w()<<","<<q.x()<<","<<q.y()<<","<<q.z();
        LOG(INFO)<<"Ba: "<<Ba_[0]<<","<<Ba_[1]<<","<<Ba_[2];
        LOG(INFO)<<"Bg: "<<Bg_[0]<<","<<Bg_[1]<<","<<Bg_[2];

        prev_state_ = gtsam::NavState(pose_start, v_start);
        prev_bias_ = prior_imu_bias;
        prev_state_odom_ = prev_state_;
        prev_bias_odom_ = prev_bias_;

        imu_initialized_ = true;
    }

    transform::Rigid3d TightTrajectoryBuilder2D::PoseFromGtsamNavState(const gtsam::NavState &pose_in) {
        return transform::Rigid3d(pose_in.position(), pose_in.quaternion());
    }

    // 位姿插值
    void TightTrajectoryBuilder2D::InterpolatePose(const double timestamp_ratio,
                                                   const transform::Rigid3d &relative_transform,
                                                   transform::Rigid3d &pose_t) {

        Eigen::Quaterniond q = Eigen::Quaterniond::Identity().slerp(
                timestamp_ratio, relative_transform.rotation());
        Eigen::Vector3d t = timestamp_ratio * relative_transform.translation();
        pose_t = transform::Rigid3d(t, q);
    }

    // 清空预测
    void TightTrajectoryBuilder2D::TrimStatesCache(const common::Time &time) {
        while(1){
            if(predicted_states_.empty()) break;
            if(common::ToSeconds(predicted_states_.front().first - time) < 0){
                predicted_states_.pop_front();
            }else{
                break;
            }
        }
    }

    void TightTrajectoryBuilder2D::WindowOptimize(
            const transform::Rigid3d &matched_pose, bool is_drift)
    {

        // Step 1: 获取当前时间戳
        double currentCorrenntionTime = common::ToSecondsStamp(time_point_cloud_);

        // Step 2: 从匹配位姿提取位置和四元数
        float p_x = matched_pose.translation().x();
        float p_y = matched_pose.translation().y();
        float p_z = matched_pose.translation().z();
        float r_x = matched_pose.rotation().x();
        float r_y = matched_pose.rotation().y();
        float r_z = matched_pose.rotation().z();
        float r_w = matched_pose.rotation().w();

        bool degenerate = is_drift;  // 是否处于漂移状态

        // 转换为GTSAM的位姿格式
        gtsam::Pose3 lidarPose = gtsam::Pose3(gtsam::Rot3::Quaternion(r_w, r_x, r_y, r_z),
                                              gtsam::Point3(p_x, p_y, p_z));

        // Step 3: GTSAM初始化
        if (!gtsam_initialized_)
        {
            SLAM_INFO("gtsam is not initialize. ");//如果GTSAM还没初始化

            ResetGTSAM();  // 重置GTSAM优化器

            TrimOldImuData(time_point_cloud_);  // 清理旧数据

            prev_pose_ = prev_state_.pose(); // 获取当前位姿

            // 添加位姿先验因子
            gtsam::PriorFactor<gtsam::Pose3> priorPose(X(0), prev_pose_, prior_pose_noise_);
            graph_factors_.add(priorPose);

             // 添加速度先验因子
            prev_vel_ = prev_state_.velocity();
            gtsam::PriorFactor<gtsam::Vector3> priorVel(V(0), prev_vel_, prior_vel_noise_);
            graph_factors_.add(priorVel);

            // 添加偏置先验因子
            gtsam::PriorFactor<gtsam::imuBias::ConstantBias> priorBias(B(0), prev_bias_, prior_bias_noise_);
            graph_factors_.add(priorBias);

            // 插入初始值
            graph_values_.insert(X(0), prev_pose_);
            graph_values_.insert(V(0), prev_vel_);
            graph_values_.insert(B(0), prev_bias_);

            // 进行一次优化
            optimizer_.update(graph_factors_, graph_values_);
            graph_factors_.resize(0);  // 清空因子
            graph_values_.clear();  // 清空值

            // 重置IMU积分器
            imu_integrator_opt_->resetIntegrationAndSetBias(prev_bias_);

            key_ = 1;  // 关键帧ID从1开始
            gtsam_initialized_ = true;
            return;
        }

        // Step 4: 检查是否需要重置优化窗口
        if (key_ == m_options_.submaps_options().num_range_data())  // 当关键帧数量达到子图的数据数量时，重置优化器
        {
            SLAM_INFO("key_ == m_options_.submaps_options().num_range_data(), Reset graph.  ");

            // get updated noise before reset （// 获取当前状态的协方差作为新的噪声模型）
            gtsam::noiseModel::Gaussian::shared_ptr updatedPoseNoise =
                    gtsam::noiseModel::Gaussian::Covariance(
                            optimizer_.marginalCovariance(X(key_-1)));
            gtsam::noiseModel::Gaussian::shared_ptr updatedVelNoise  =
                    gtsam::noiseModel::Gaussian::Covariance(
                            optimizer_.marginalCovariance(V(key_-1)));
            gtsam::noiseModel::Gaussian::shared_ptr updatedBiasNoise =
                    gtsam::noiseModel::Gaussian::Covariance(
                            optimizer_.marginalCovariance(B(key_-1)));
            // reset graph
            ResetGTSAM();

            // 使用新的噪声模型添加先验因子
            // add pose
            gtsam::PriorFactor<gtsam::Pose3> priorPose(
                    X(0), prev_pose_, updatedPoseNoise);
            graph_factors_.add(priorPose);
            // add velocity
            gtsam::PriorFactor<gtsam::Vector3> priorVel(
                    V(0), prev_vel_, updatedVelNoise);
            graph_factors_.add(priorVel);
            // add bias
            gtsam::PriorFactor<gtsam::imuBias::ConstantBias> priorBias(
                    B(0), prev_bias_, updatedBiasNoise);
            graph_factors_.add(priorBias);

            // add values
            graph_values_.insert(X(0), prev_pose_);
            graph_values_.insert(V(0), prev_vel_);
            graph_values_.insert(B(0), prev_bias_);
            // optimize once
            optimizer_.update(graph_factors_, graph_values_);
            graph_factors_.resize(0);
            graph_values_.clear();

            key_ = 1; // 重置关键帧计数
        }

        // Step 5: 添加IMU因子
        const gtsam::PreintegratedImuMeasurements& preint_imu =
                dynamic_cast<const gtsam::PreintegratedImuMeasurements&>(*imu_integrator_opt_);
        
        // IMU因子连接前一关键帧和当前关键帧
        gtsam::ImuFactor imu_factor(X(key_ - 1), V(key_ - 1), X(key_), V(key_), B(key_ - 1), preint_imu);
        graph_factors_.add(imu_factor);

        // Step 6: 添加偏置随机游走因子
        graph_factors_.add(gtsam::BetweenFactor<gtsam::imuBias::ConstantBias>(
                B(key_ - 1), B(key_), gtsam::imuBias::ConstantBias(),
                gtsam::noiseModel::Diagonal::Sigmas(
                        sqrt(imu_integrator_opt_->deltaTij()) * noise_model_between_bias_)));
        
        // Step 7: 添加激光雷达位姿因子
        gtsam::Pose3 curPose = lidarPose;
        gtsam::PriorFactor<gtsam::Pose3> pose_factor(X(key_), curPose,
                                                     degenerate ? correction_noise_2_ : correction_noise_);
        graph_factors_.add(pose_factor);
        
        // Step 8: 插入预测的状态作为初始值
        gtsam::NavState propState_ = imu_integrator_opt_->predict(prev_state_, prev_bias_);
        graph_values_.insert(X(key_), propState_.pose());
        graph_values_.insert(V(key_), propState_.v());
        graph_values_.insert(B(key_), prev_bias_);
        
        // Step 9: 执行优化
        optimizer_.update(graph_factors_, graph_values_);
        optimizer_.update(); // 再次更新
        graph_factors_.resize(0);  // 清空因子
        graph_values_.clear();  // 清空值
        
         // Step 10: 提取优化结果
        gtsam::Values result = optimizer_.calculateEstimate();
        prev_pose_ = result.at<gtsam::Pose3>(X(key_));
        prev_vel_ = result.at<gtsam::Vector3>(V(key_));
        prev_state_ = gtsam::NavState(prev_pose_, prev_vel_);
        prev_bias_ = result.at<gtsam::imuBias::ConstantBias>(B(key_));//进而实现IMU bias的在线优化
        
        // Step 11: 重置IMU积分器，使用新的偏置
        imu_integrator_opt_->resetIntegrationAndSetBias(prev_bias_);

         // 清理旧的IMU数据
        TrimOldImuData(time_point_cloud_);
        
        // Step 12: 故障检测（根据IMU的bias是否超过阈值，此部分跟VINSmono类似）
        if (FailureDetection(prev_vel_, prev_bias_))
        {
            ResetParams();
            return;
        }
        
        // Step 13: 更新关键帧计数
        ++key_;
        done_first_opt_ = true;  // 标记已完成第一次优化

    }

    void TightTrajectoryBuilder2D::ResetGTSAM() {

        gtsam::ISAM2Params optParameters;
        optParameters.relinearizeThreshold = 0.1;
        optParameters.relinearizeSkip = 1;
        optimizer_ = gtsam::ISAM2(optParameters);

        gtsam::NonlinearFactorGraph new_graph_factors_;
        graph_factors_ = new_graph_factors_;

        gtsam::Values new_graph_values_;
        graph_values_ = new_graph_values_;

    }

    void TightTrajectoryBuilder2D::TrimOldImuData(const common::Time &time) {

        while (!imu_que_opt_.empty()){
            if (common::ToSeconds(imu_que_opt_.front().time - time) < 0) {
                last_imu_time_opt_ = common::ToSecondsStamp(imu_que_opt_.front().time);
                imu_que_opt_.pop_front();
            }
            else
                break;
        }

    }

    bool TightTrajectoryBuilder2D::FailureDetection(const gtsam::Vector3 &velCur,
                                                    const gtsam::imuBias::ConstantBias &biasCur) {
        Eigen::Vector3f vel(velCur.x(), velCur.y(), velCur.z());
        if (vel.norm() > 30){
            SLAM_WARN("Large velocity, reset IMU-preintegration!");
            return true;
        }

        Eigen::Vector3f ba(biasCur.accelerometer().x(),
                           biasCur.accelerometer().y(), biasCur.accelerometer().z());
        Eigen::Vector3f bg(biasCur.gyroscope().x(),
                           biasCur.gyroscope().y(), biasCur.gyroscope().z());
        if (ba.norm() > 1.0 || bg.norm() > 1.0){
            SLAM_WARN("Large bias, reset IMU-preintegration!");
            return true;
        }
        return false;
    }

    void TightTrajectoryBuilder2D::ResetParams() {
        done_first_opt_ = false;
        gtsam_initialized_ = false;
    }


} // mapping
} // cartographer
```