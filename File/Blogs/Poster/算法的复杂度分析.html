<!DOCTYPE html>
<html lang="en">

<style>
    p { /* 文字对齐 */
        text-align: justify;
        text-align-last: left;
        text-justify: inter-word;
    }
  </style>

<!-- Head -->
<head>    <!-- Metadata, OpenGraph and Schema.org -->


  <!-- Standard metadata -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Kwan Wai-Pang's Blog</title>
  <meta name="author" content="Kwan Wai-Pang " />
  <meta name="description" content="Personal Blog of Kwan Wai-Pang" />
  <meta name="keywords" content="Event-based Vision, SLAM, Robotics" />

  <!-- OpenGraph -->
  <meta property="og:site_name" content="My Technology Blog" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="My Blog  | Home" />
  <meta property="og:description" content="My Blog.
" />

  <meta property="og:locale" content="en" />

  <!-- Twitter card -->
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Home" />
  <meta name="twitter:description" content="Personal Blog of Kwan Wai-Pang" />

  <!-- Bootstrap & MDB -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous" />

  <!-- Fonts & Icons -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css2?family=Barriecito&family=Poppins:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700">

  <!-- Code Syntax Highlighting -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/PASTIE.css" media="none" id="highlight_theme_light" />

  <!-- Styles -->

  <!-- <link rel="stylesheet" href="https://kwanwaipang.github.io/File/Blogs/assets/css/main.css"> -->
  <!-- <link rel="stylesheet" href="https://kwanwaipang.github.io/File/Blogs/assets/css/fonts.css"> -->
  <link rel="stylesheet" href="../assets/css/main.css">
  <link rel="stylesheet" href="../assets/css/fonts.css">
  <link rel="stylesheet" href="../assets/new_css_js/cpp-highlight/styles/gradient-dark.css">
  <script src="../assets/new_css_js/cpp-highlight/highlight.js"></script>    <!--引入代码高亮js库-->

  <script>hljs.initHighlightingOnLoad();
  </script>

  <!-- Dark Mode -->


</head>

  <!-- Body -->
  <body class="fixed-top-nav ">

    <!-- Header -->
    <header>

      <!-- Nav Bar -->
      <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
        <div class="container">
          
          <!-- Navbar Toggle -->
          <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar top-bar"></span>
            <span class="icon-bar middle-bar"></span>
            <span class="icon-bar bottom-bar"></span>
          </button>

          <div class="collapse navbar-collapse text-right" id="navbarNav">
            <ul class="navbar-nav ml-auto flex-nowrap">
              <li class="nav-item ">
                <a class="nav-link" href="../My_Blog.html">Homepage</a>
              </li>

              <li class="nav-item ">
                <a class="nav-link" href="../Poster/cpp算法学习笔记.html">Learning Algorithm</a>
              </li>

            </ul>
          </div>
        </div>
      </nav>
    </header>

    <!-- Content -->
    <div class="container mt-5">
      <!-- home.html -->
      <div class="post">
        <header class="post-header">
          <h1 align="center" class="post-title">
           <span style="font-weight: 600;">算法的复杂度分析</span>
          </h1>
        </header>
<article>
<!-- 插入博客内容-->
<p><br></p>
 <p>
  在算法设计中，追求以下两个层面的目标：
  <ul>
    <li>找到问题的解法</li>
    <li>找到最优/尽可能高效的解法</li>
  </ul>
  那么也就是说，在能够解决问题的前提下，算法效率已成为衡量算法优劣的主要评价指标。主要包含两个维度：时间复杂度(时间效率)和空间复杂度(空间效率)。
  最直接的方式肯定是通过实际测试来评估的，但是会受到诸如硬件等影响。为此，理论推算也极为重要。
  <br>
  所谓的理论推算算法的效率，也就是复杂度分析，它是通过分析算法运行所需的时间和空间资源与输入数据大小之间的关系。它描述了随着输入数据大小的增加，算法执行所需时间和空间的增长趋势。
 </p>

<p><br></p>
<h1>算法的时间复杂度</h1>

<p>
  根据输入的数据大小（n），常见的时间复杂度有：
  <figure style="text-align: center;">
    <div style="margin-bottom: 10px;">
      <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/complexity_analysis/微信截图_20240728235149.png" alt="Image description">
    </div>
  <figcaption><p>
  </p></figcaption>
  </figure> 
  他们的数学曲线表达如下：
  <figure style="text-align: center;">
    <div style="margin-bottom: 10px;">
      <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/complexity_analysis/微信截图_20240728235217.png" alt="Image description">
    </div>
  <figcaption><p>
  </p></figcaption>
  </figure> 

  对于时间复杂度，实际上采用的是“最差时间复杂度”对应函数渐近上界，因此使用 𝑂 记号表示。
  如果采用“最佳时间复杂度”，则是对应函数渐近下界，用 Ω 记号表示。
</p>

<p><br></p>
<h3>1. 常数阶𝑂(1)</h3>
<p>操作数量与输入数据大小𝑛 无关，即不随着𝑛 的变化而变化。在以下函数中，尽管操作数量size 可能很大，但由于其与输入数据大小𝑛 无关，因此时间复杂度仍为𝑂(1)</p>
<pre><code>
  int constant(int n) {
    int count = 0;
    int size = 100000;
    for (int i = 0; i &lt size; i++)//操作数量与输入数据大小𝑛无关
        count++;
    return count;
    }
</code></pre>

<p><br></p>
<h3>2. 线性阶𝑂(𝑛)</h3>
<p>线性阶的操作数量相对于输入数据大小𝑛 以线性级别增长。例如，遍历数组和遍历链表等操作的时间复杂度均为𝑂(𝑛) ，其中𝑛 为数组或链表的长度。
  如下代码所示：</p>
<pre><code>
  int Linear(int n) {
    int count = 0;
    for (int i = 0; i &lt n; i++)//操作数量与输入数据大小𝑛相关
        count++;
    return count;
    }
</code></pre>

<p><br></p>
<h3>3. 平方阶𝑂(𝑛<sup>2</sup>)</h3>
<p>平方阶的操作数量相对于输入数据大小𝑛 以平方级别增长。
  平方阶通常出现在嵌套循环中，外层循环和内层循环的时间复杂度都为𝑂(𝑛) ，因此总体的时间复杂度为𝑂(𝑛<sup>2</sup>) ：</p>
<pre><code>
int quadratic(int n) {
  int count = 0;
  // 循环次数与数据大小n 成平方关系
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
      count++;
    }
  }
  return count;
}
</code></pre>

<details>
<summary>以冒泡排序为例，外层循环执行𝑛 − 1 次，内层循环执行𝑛 − 1、𝑛 − 2、…、2、1 次，平均为𝑛/2 次，因
  此时间复杂度为𝑂((𝑛 − 1)𝑛/2) = 𝑂(𝑛<sup>2</sup>) ：</summary>
<pre><code>
/* 平方阶（冒泡排序） */
int bubbleSort(vector&ltint&gt &nums) {
  int count = 0; // 计数器
  // 外循环：未排序区间为[0, i]
  for (int i = nums.size() - 1; i &gt 0; i--) {
      // 内循环：将未排序区间[0, i] 中的最大元素交换至该区间的最右端
      for (int j = 0; j &lt i; j++) {
        if (nums[j] &gt nums[j + 1]) {
          // 交换nums[j] 与nums[j + 1]
          int tmp = nums[j];
          nums[j] = nums[j + 1];
          nums[j + 1] = tmp;
          count += 3; // 元素交换包含3 个单元操作
      }
    }
  }
  return count;//返回的为操作数
}
</code></pre>
</details>
<br>
<p>
  此处的的𝑂((𝑛 − 1)𝑛/2) =𝑂(𝑛<sup>2</sup>/2 − 𝑛/2)。但是为什么时间复杂度是 𝑂(𝑛<sup>2</sup>)而不是前者呢？
  注意：时间复杂度由最高阶的项来决定。这是因为在𝑛趋于无穷大时，最高阶的项将发挥主导作用，其他项的影响都可以忽略。
  <details>
  <summary>如下图所示为不同操作数量对应的时间复杂度。</summary>
  <figure style="text-align: center;">
    <div style="margin-bottom: 10px;">
      <img style="width: 60%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/complexity_analysis/微信截图_20240728234928.png" alt="Image description">
    </div>
  <figcaption><p>
  </p></figcaption>
  </figure> 
  </details>
</p>

<p><br></p>
<h3>4. 指数阶𝑂(2<sup>𝑛</sup>)</h3>
<p>典型例子就是生物学的“细胞分裂”
<pre><code>
int exponential(int n) {
  int count = 0, base = 1;
  // 细胞每轮一分为二，形成数列1, 2, 4, 8, ..., 2^(n-1)
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < base; j++) {//base的size受到输入n的影响为2^n
      count++;
    }
    base *= 2;
    }
    //一共的运算数为 count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1
  return count;
}
</code></pre>
</p>
<details>
<summary>指数阶常出现于<strong>递归函数，穷举法（暴力搜索、回溯等）</strong>中。例如在以下代码中，其递归地一分为二，经过𝑛 次分裂后停止：</summary>
<pre><code>
int expRecur(int n) {
  if (n == 1)
    return 1;
  return expRecur(n - 1) + expRecur(n - 1) + 1;
}
</code></pre>
</details>
<p>对于数据规模较大的问题，指数阶是不可接受的，通常需要使用动态规划或贪心算法等来解决。</p>


<p><br></p>
<h3>5. 对数阶𝑂(log𝑛)</h3>
<p>
  与指数阶相反，对数阶反映了“每轮缩减到一半”的情况。设输入数据大小为𝑛 ，由于每轮缩减到一半，因此循环次数是log2 𝑛 ，即2<sup>𝑛</sup> 的反函数。
如下代码所示：
<pre><code>
int logarithmic(int n) {
  int count = 0;
  while (n &gt 1) {
    n = n / 2;//每轮缩减一半
    count++;
  }
  return count;
}
</code></pre>
</p>
<p>
  对数阶常出现于基于分治策略的算法中，体现了“一分为多”和“化繁为简”的算法思想。
  <figure style="text-align: center;">
    <div style="margin-bottom: 10px;">
      <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/complexity_analysis/微信截图_20240729093140.png" alt="Image description">
    </div>
  <figcaption><p>
  </p></figcaption>
  </figure> 
</p>

<details>
  <summary>与指数阶类似，对数阶也常出现于<strong>递归函数</strong>中：</summary>
<pre><code>
int logRecur(int n) {
  if (n &lt= 1)
    return 0;
  return logRecur(n / 2) + 1;//每轮递归缩减一半
}
</code></pre>
</details>

<p><br></p>
<h3>6. 线性对数阶𝑂(𝑛log𝑛)</h3>
<p>
  主流的排序算法如<strong>快速排序、归并排序、堆排序</strong>等的时间复杂度通常都是𝑂(𝑛log𝑛) 。
  线性对数阶常出现于嵌套循环中，两层循环的时间复杂度分别为𝑂(log 𝑛) 和𝑂(𝑛) 。相关代码如下：
<pre><code>
int linearLogRecur(int n) {
  if (n &lt= 1)
    return 1;
  int count = linearLogRecur(n / 2) + linearLogRecur(n / 2);//每轮递归缩减一半，对数𝑂(log 𝑛)
  for (int i = 0; i &lt n; i++) {
    count++; //而每次递归后，内嵌循环的时间复杂度为𝑂(𝑛)
  }
  return count;
}
</code></pre>
</p>

<p><br></p>
<h3>7. 阶乘阶𝑂(𝑛！)</h3>
<p>
  阶乘阶对应数学上的“全排列”问题。给定 𝑛 个互不重复的元素，求其所有可能的排列方案，方案数量为：
  <br>
  <mark>𝑛！=𝑛×(n-1)×(n-2)×...×2×1 </mark>
  以阶乘阶比指数阶增长得更快，在 𝑛 较大时也是不可接受的。
  如下代码所示：
</p>

<pre><code>
/* 阶乘阶（递归实现） */
int factorialRecur(int n) {
  if (n == 0)
    return 1;
  int count = 0;
  // 从 1 个分裂出 n 个
  for (int i = 0; i &lt n; i++) {
    count += factorialRecur(n - 1);
  }
  return count;
}
</code></pre>


<p><br></p>
<h1>算法的空间复杂度</h1>
<p>
  空间复杂度（space complexity）用于衡量算法占用内存空间随着数据量变大时的增长趋势。
  这个概念与时间复杂度非常类似，只需将“运行时间”替换为“占用内存空间”。
  <br>
  一般情况下，空间复杂度的统计范围是“暂存空间”加上“输出空间”。暂存空间可以进一步划分为三个部分:
  <ul>
    <li>暂存数据：用于保存算法运行过程中的各种常量、变量、对象等。</li>
    <li>栈帧空间：用于保存调用函数的上下文数据。系统在每次调用函数时都会在栈顶部创建一个栈帧，函数返回后，栈帧空间会被释放。</li>
    <li>指令空间：用于保存编译后的程序指令，在实际统计中<strong>通常忽略不计</strong>。</li>
  </ul>
</p>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 60%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/complexity_analysis/微信截图_20240801220154.png" alt="Image description">
  </div>
<figcaption>
  一般情况下应该是暂存数据作为使用空间的大小，但是对于递归函数，需要注意统计栈帧空间（递归结束前是一直有占用空间的~）
</figcaption>
</figure> 
<p>
  常见的空间复杂度类型如下图所示：
  <figure style="text-align: center;">
    <div style="margin-bottom: 10px;">
      <img style="width: 60%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/complexity_analysis/微信截图_20240801220658.png" alt="Image description">
    </div>
  <figcaption><p>
  </p></figcaption>
  </figure> 
  </p>

<p><br></p>
<h3>1. 常数阶𝑂(1)</h3>
<p>常数阶常见于数量与输入数据大小 𝑛 无关的常量、变量、对象。
  <br>
  注意：在循环中初始化变量或调用函数而占用的内存，在进入下一循环后就会被释放，因此不会累积占用空间，空间复杂度仍为 𝑂(1) ：
</p>
<pre><code>
int func() {
  // 执行某些操作
  return 0;
}

/* 常数阶 */
void constant(int n) {
  // 常量、变量、对象占用 O(1) 空间
  const int a = 0;
  int b = 0;
  vector&ltint&gt nums(10000);//虽然很大，但仍然是常数阶，与输入无关
  ListNode node(0);
  
  // 循环中的变量占用 O(1) 空间（每次调用进入下一次循环会释放）
  for (int i = 0; i &lt n; i++) {
    int c = 0;
  }
  
  // 循环中的函数占用 O(1) 空间（每次调用进入下一次循环会释放）
  for (int i = 0; i &lt n; i++) {
    func();
  }
}
</code></pre>

<p><br></p>
<h3>2. 线性阶𝑂(𝑛)</h3>
<p>线性阶常见于元素数量与 𝑛 成正比的数组、链表、栈、队列等以及递归:</p>
<pre><code>
/* 线性阶 */
void linear(int n) {
  // 长度为 n 的数组占用 O(n) 空间
  vector&ltint&gt nums(n);

  // 长度为 n 的列表占用 O(n) 空间
  vector&ltListNode&gt nodes;
  for (int i = 0; i &lt n; i++) {
    nodes.push_back(ListNode(i));
  }

  // 长度为 n 的哈希表占用 O(n) 空间
  unordered_map&ltint, string&gt map;
  for (int i = 0; i &lt n; i++) {
    map[i] = to_string(i);
  }
}

/* 递归的空间复杂度为 O(n) */
//对于递归函数，递归结束前是一直有占用空间的，这属于栈帧空间
//函数的递归深度为 𝑛 ，即同时存在 𝑛 个未返回的 recur() 函数，
void recur(int n) {
  if (n == 1) return;
  return recur(n - 1);
}
</code></pre>

<p><br></p>
<h3>3. 平方阶𝑂(𝑛<sup>2</sup>)</h3>
<p>平方阶常见于矩阵和图，元素数量与 𝑛 成平方关系：</p>
<pre><code>
/* 平方阶 */
void quadratic(int n) {
  // 二维列表占用 O(n^2) 空间
  vector&ltvector&ltint&gt&gt numMatrix;//矩阵式存储
  for (int i = 0; i &lt n; i++) {
    vector&ltint&gt tmp;
    for (int j = 0; j &lt n; j++) {
      tmp.push_back(0);
    }
    numMatrix.push_back(tmp);
  }
}
</code></pre>
<p>
  下面代码递归深度为 𝑛 ，在每个递归函数中都初始化了一个数组，长度分别为 𝑛、𝑛 − 1、…、2、1 ，平均长度为 𝑛/2 ，因此总体占用𝑂(𝑛<sup>2</sup>)空间：
</p>
<pre><code>
int quadraticRecur(int n) {//递归空间复杂度也为O(n)
  if (n &lt= 0)
    return 0;
  vector&ltint&gt nums(n); //递归空间复杂度内的空间复杂度为O(n)
  cout << " 递归 n = " << n << " 中的 nums 长度 = " << nums.size() << endl;
  return quadraticRecur(n - 1);
}
</code></pre>

<p><br></p>
<h3>4. 指数阶𝑂(2<sup>𝑛</sup>)</h3>  
<p>
  指数阶常见于二叉树。层数为 𝑛 的“满二叉树”的节点数量为 2<sup>𝑛</sup> − 1 ，占用 𝑂(2<sup>𝑛</sup>) 空间
</p>
<pre><code>
/* 指数阶（建立满二叉树） */
TreeNode *buildTree(int n) {
  if (n == 0)
    return nullptr;
  TreeNode *root = new TreeNode(0);
  root-&gtleft = buildTree(n - 1);
  root-&gtright = buildTree(n - 1);
  return root;
}
</code></pre>

<p><br></p>
<h3>5. 对数阶𝑂(log𝑛)</h3>
<p>
  对数阶常见于分治算法。例如归并排序，输入长度为 𝑛 的数组，每轮递归将数组从中点处划分为两半，形成高度为 log 𝑛 的递归树，使用 𝑂(log 𝑛) 栈帧空间。
  </p>


<!-- 标签内使用 &lt; 和 &gt; 来代替 < 和 > -->
<!-- <details>
<summary>Click to expand the code</summary>
<pre><code>
</code></pre>
</details> -->

<!-- <p><br></p>
<h1></h1>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 60%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/complexity_analysis/" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>  -->

<p><br></p>
<h1>参考资料</h1>
<ul>
  <li><a href="https://labuladong.online/algo/essential-technique/complexity-analysis/" target="_blank">算法时空复杂度分析实用指南</a></li>
  <li>书籍《Hello 算法 C++语言版》</li>
</ul>

</article>
</div>
</div>

<!-- Footer --> 
<p><br></p>   
<footer class="nofixed-bottom">
<div class="container mt-0" style="width:100%;text-align:center;">
  Please feel free to contact me through <a href="https://kwanwaipang.github.io/" target="_blank">my personal website</a>
</div>
</footer> 

    <!-- JavaScripts -->
    <!-- jQuery -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>

    <!-- Bootsrap & MDB scripts -->
  <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.2/dist/umd/popper.min.js" integrity="sha256-l/1pMF/+J4TThfgARS6KwWrk/egwuVvhRzfLAMQ6Ds4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.min.js" integrity="sha256-SyTu6CwrfOhaznYZPoolVw2rxoY7lKYKQvqbtqN93HI=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script>

    <!-- Masonry & imagesLoaded -->
  <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
  <script defer src="/ecmd/assets/js/masonry.js" type="text/javascript"></script>

  <!-- Medium Zoom JS -->
  <script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script>
  <script src="/ecmd/assets/js/zoom.js"></script><!-- Load Common JS -->
  <script src="/ecmd/assets/js/common.js"></script>

    <!-- MathJax -->
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        tags: 'ams'
      }
    };
  </script>
  <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
  <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>

</body>
</html>

