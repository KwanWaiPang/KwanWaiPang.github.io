<!DOCTYPE html>
<html lang="en">

<style>
    p { /* æ–‡å­—å¯¹é½ */
        text-align: justify;
        text-align-last: left;
        text-justify: inter-word;
    }
    #toc {
      background: #f4f4f4;
      padding: 10px;
      /* border: 1px solid #ccc; */
      /* margin-bottom: 20px; */
      max-width: 100%; /* é™åˆ¶ç›®å½•æ¡†æ¶çš„æœ€å¤§å®½åº¦ */
      word-wrap: break-word; /* å¼ºåˆ¶è¶…é•¿å•è¯æ¢è¡Œ */
      position: relative;
      margin-left: auto; /* ä½¿ç›®å½•æ¡†æ¶åœ¨é¡µé¢ä¸­å±…å³ */
      margin-right: auto; /* ä½¿ç›®å½•æ¡†æ¶åœ¨é¡µé¢ä¸­å±…å³ */
      box-sizing: border-box; /* åŒ…å«å†…è¾¹è·å’Œè¾¹æ¡†åœ¨å†…çš„å®½åº¦è®¡ç®— */
  }

  #scrollToTocButton {
    position: fixed;
    bottom: 20px;
    right: 20px;
    padding: 12px 25px;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 50px; /* åœ†è§’è®¾è®¡ */
    font-size: 16px;
    font-weight: 600;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* å¢åŠ é˜´å½±æ•ˆæœ */
    transition: all 0.3s ease; /* æ·»åŠ å¹³æ»‘è¿‡æ¸¡æ•ˆæœ */
    cursor: pointer;
    z-index: 1000;
  }

  #scrollToTocButton:hover {
      background-color: #0056b3; /* é¼ æ ‡æ‚¬åœæ—¶é¢œè‰²å˜åŒ– */
      transform: translateY(-3px); /* æ‚¬åœæ—¶æŒ‰é’®ç•¥å¾®ä¸Šç§» */
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3); /* æ‚¬åœæ—¶å¢åŠ é˜´å½± */
  }

  #toggleTocButton {
    position: fixed;
    bottom: 70px;
    right: 20px;
    padding: 12px 25px;
    background-color: #00b34b;
    color: white;
    border: none;
    border-radius: 50px; /* åœ†è§’è®¾è®¡ */
    font-size: 16px;
    font-weight: 600;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* å¢åŠ é˜´å½±æ•ˆæœ */
    transition: all 0.3s ease; /* æ·»åŠ å¹³æ»‘è¿‡æ¸¡æ•ˆæœ */
    cursor: pointer;
    z-index: 1000;
  }

  #toggleTocButton:hover {
      background-color: #00b34b; /* é¼ æ ‡æ‚¬åœæ—¶é¢œè‰²å˜åŒ– */
      transform: translateY(-3px); /* æ‚¬åœæ—¶æŒ‰é’®ç•¥å¾®ä¸Šç§» */
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3); /* æ‚¬åœæ—¶å¢åŠ é˜´å½± */
  }

  #newToc {
  display: none; 
  position: fixed; 
  bottom: 70px; 
  right: 200px; 
  background: #f4f4f4; 
  padding: 10px; 
  font-size: 12px; 
  max-height: 40%; /* è®¾ç½®æœ€å¤§é«˜åº¦ */
  overflow-y: auto; /* æ·»åŠ å‚ç›´æ»šåŠ¨æ¡ */
  overflow-x: hidden; /* éšè—æ°´å¹³æ»šåŠ¨æ¡ */
}

  </style>

<!-- Head -->
<head>    <!-- Metadata, OpenGraph and Schema.org -->


  <!-- Standard metadata -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Kwan Wai-Pang's Blog</title>
  <meta name="author" content="Kwan Wai-Pang " />
  <meta name="description" content="Personal Blog of Kwan Wai-Pang" />
  <meta name="keywords" content="Event-based Vision, SLAM, Robotics" />

  <!-- OpenGraph -->
  <meta property="og:site_name" content="My Technology Blog" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Kwan Wai-Pang | Personal Blog" />
  <meta property="og:description" content="Welcome to My Blog of Binary Tree ğŸ˜Š" />
  <meta property="og:image" content="https://kwanwaipang.github.io/Poster_files/hku_logo.jpg" />

  <meta property="og:locale" content="en" />

  <!-- Twitter card -->
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Home" />
  <meta name="twitter:description" content="Personal Blog of Kwan Wai-Pang" />

  <!-- Bootstrap & MDB -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous" />

  <!-- Fonts & Icons -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css2?family=Barriecito&family=Poppins:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700">

  <!-- Code Syntax Highlighting -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/PASTIE.css" media="none" id="highlight_theme_light" />

  <!-- Styles -->

    <link rel="shortcut icon" href="https://kwanwaipang.github.io/Poster_files/hku_logo.jpg"/>

  <!-- <link rel="stylesheet" href="https://kwanwaipang.github.io/File/Blogs/assets/css/main.css"> -->
  <!-- <link rel="stylesheet" href="https://kwanwaipang.github.io/File/Blogs/assets/css/fonts.css"> -->
  <link rel="stylesheet" href="../assets/css/main.css">
  <link rel="stylesheet" href="../assets/css/fonts.css">
  <link rel="stylesheet" href="../assets/new_css_js/cpp-highlight/styles/gradient-dark.css">
  <script src="../assets/new_css_js/cpp-highlight/highlight.js"></script>    <!--å¼•å…¥ä»£ç é«˜äº®jsåº“-->

  <script>hljs.initHighlightingOnLoad();
  </script>

  <!-- Dark Mode -->


</head>

  <!-- Body -->
  <body class="fixed-top-nav ">

    <!-- Header -->
    <header>

      <!-- Nav Bar -->
      <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
        <div class="container">
          
          <!-- Navbar Toggle -->
          <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar top-bar"></span>
            <span class="icon-bar middle-bar"></span>
            <span class="icon-bar bottom-bar"></span>
          </button>

          <div class="collapse navbar-collapse text-right" id="navbarNav">
            <ul class="navbar-nav ml-auto flex-nowrap">
              <li class="nav-item ">
                <a class="nav-link" href="../My_Blog.html">Homepage</a>
              </li>

              <li class="nav-item ">
                <a class="nav-link" href="../Poster/cppç®—æ³•å­¦ä¹ ç¬”è®°.html">Learning Algorithm</a>
              </li>

            </ul>
          </div>
        </div>
      </nav>
    </header>

<header class="post-header">
  <h1 align="center" class="post-title">
    <span style="font-weight: 600;">äºŒå‰æ ‘</span>
  </h1>
</header>

<!-- Content -->
<div class="container mt-5">
<!-- home.html -->
<div class="post">

<!-- æ·»åŠ ç›®å½•æŒ‰é’® -->
<button id="toggleTocButton">Table of Contents</button>
<!-- æ–°çš„ç›®å½• -->
<div id="newToc">
  <h8>Catalog</h8>
  <ul></ul>
</div>

<!-- æ·»åŠ æŒ‰é’®è·³è½¬åˆ°é¢˜ç›® -->
<button id="scrollToTocButton">ğŸ‘†Back to TitleğŸ‘†</button>

<!-- æ’å…¥ç›®å½• -->
<div id="toc">
  <h8>ç›®å½•</h8>
  <ul></ul>
</div>

<article>
<!-- æ’å…¥åšå®¢å†…å®¹-->
<p><br></p>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 100%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/binary_tree/å¾®ä¿¡å›¾ç‰‡_20240802183641.jpg" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
<p>
  äºŒå‰æ ‘çš„ç§ç±»ï¼š
  <li>æ»¡äºŒå‰æ ‘ï¼šå¦‚æœä¸€æ£µäºŒå‰æ ‘åªæœ‰åº¦ä¸º0çš„ç»“ç‚¹å’Œåº¦ä¸º2çš„ç»“ç‚¹ï¼Œå¹¶ä¸”åº¦ä¸º0çš„ç»“ç‚¹åœ¨åŒä¸€å±‚ä¸Šï¼Œåˆ™è¿™æ£µäºŒå‰æ ‘ä¸ºæ»¡äºŒå‰æ ‘ã€‚(ç›´è§‚ç†è§£å°±æ˜¯å¡«æ»¡äº†~)</li>
  <figure style="text-align: center;">
    <div style="margin-bottom: 10px;">
      <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/binary_tree/å¾®ä¿¡æˆªå›¾_20240912162401.png" alt="Image description">
    </div>
  <figcaption><p>
  </p></figcaption>
  </figure> 

  <li>å®Œå…¨äºŒå‰æ ‘ï¼šåœ¨å®Œå…¨äºŒå‰æ ‘ä¸­ï¼Œé™¤äº†æœ€åº•å±‚èŠ‚ç‚¹å¯èƒ½æ²¡å¡«æ»¡å¤–ï¼Œå…¶ä½™æ¯å±‚èŠ‚ç‚¹æ•°éƒ½è¾¾åˆ°æœ€å¤§å€¼ï¼Œå¹¶ä¸”æœ€ä¸‹é¢ä¸€å±‚çš„èŠ‚ç‚¹éƒ½é›†ä¸­åœ¨è¯¥å±‚æœ€å·¦è¾¹çš„è‹¥å¹²ä½ç½®ã€‚</li>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/binary_tree/å¾®ä¿¡æˆªå›¾_20240912162519.png" alt="Image description">
  </div>
<figcaption>æ³¨æ„æœ€åä¸€ä¸ªçš„å·¦ä¾§æ²¡æœ‰å¡«æ»¡ï¼Œæ•…æ­¤ä¸æ˜¯</figcaption>
</figure> 

<li>å¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼šå®ƒæ˜¯ä¸€æ£µç©ºæ ‘æˆ–å®ƒçš„å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡1ï¼Œå¹¶ä¸”å·¦å³ä¸¤ä¸ªå­æ ‘éƒ½æ˜¯ä¸€æ£µå¹³è¡¡äºŒå‰æ ‘ã€‚</li>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/binary_tree/å¾®ä¿¡æˆªå›¾_20240912162825.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
<li>å¹³è¡¡äºŒå‰æ ‘ä¸æ™®é€šäºŒå‰æ ‘çš„ç©ºé—´å¤æ‚åº¦çš„åŒºåˆ«ï¼š</li>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/binary_tree/WX20240920-111210.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
</p>



<p>
  äºŒå‰æ ‘è§£é¢˜çš„æ€ç»´æ¨¡å¼åˆ†ä¸¤ç±»ï¼š
<br>
1ã€æ˜¯å¦å¯ä»¥é€šè¿‡éå†ä¸€éäºŒå‰æ ‘å¾—åˆ°ç­”æ¡ˆï¼Ÿå¦‚æœå¯ä»¥ï¼Œç”¨ä¸€ä¸ª traverse å‡½æ•°é…åˆå¤–éƒ¨å˜é‡æ¥å®ç°ï¼Œè¿™å«ã€Œéå†ã€çš„æ€ç»´æ¨¡å¼ã€‚
<br>
2ã€æ˜¯å¦å¯ä»¥å®šä¹‰ä¸€ä¸ªé€’å½’å‡½æ•°ï¼Œé€šè¿‡å­é—®é¢˜ï¼ˆå­æ ‘ï¼‰çš„ç­”æ¡ˆæ¨å¯¼å‡ºåŸé—®é¢˜çš„ç­”æ¡ˆï¼Ÿå¦‚æœå¯ä»¥ï¼Œå†™å‡ºè¿™ä¸ªé€’å½’å‡½æ•°çš„å®šä¹‰ï¼Œå¹¶å……åˆ†åˆ©ç”¨è¿™ä¸ªå‡½æ•°çš„è¿”å›å€¼ï¼Œè¿™å«ã€Œåˆ†è§£é—®é¢˜ã€çš„æ€ç»´æ¨¡å¼ã€‚
<br>
æ— è®ºä½¿ç”¨å“ªç§æ€ç»´æ¨¡å¼ï¼Œä½ éƒ½éœ€è¦æ€è€ƒï¼š

å¦‚æœå•ç‹¬æŠ½å‡ºä¸€ä¸ªäºŒå‰æ ‘èŠ‚ç‚¹ï¼Œå®ƒéœ€è¦åšä»€ä¹ˆäº‹æƒ…ï¼Ÿéœ€è¦åœ¨ä»€ä¹ˆæ—¶å€™ï¼ˆå‰/ä¸­/ååºä½ç½®ï¼‰åšï¼Ÿå…¶ä»–çš„èŠ‚ç‚¹ä¸ç”¨ä½ æ“å¿ƒï¼Œé€’å½’å‡½æ•°ä¼šå¸®ä½ åœ¨æ‰€æœ‰èŠ‚ç‚¹ä¸Šæ‰§è¡Œç›¸åŒçš„æ“ä½œã€‚
<br>
äºŒå‰æ ‘çš„æ‰€æœ‰é—®é¢˜ï¼Œå°±æ˜¯è®©ä½ åœ¨å‰ä¸­ååºä½ç½®æ³¨å…¥å·§å¦™çš„ä»£ç é€»è¾‘ï¼Œå»è¾¾åˆ°è‡ªå·±çš„ç›®çš„ï¼Œä½ åªéœ€è¦å•ç‹¬æ€è€ƒæ¯ä¸€ä¸ªèŠ‚ç‚¹åº”è¯¥åšä»€ä¹ˆï¼Œå…¶ä»–çš„ä¸ç”¨ä½ ç®¡ï¼ŒæŠ›ç»™äºŒå‰æ ‘éå†æ¡†æ¶ï¼Œé€’å½’ä¼šåœ¨æ‰€æœ‰èŠ‚ç‚¹ä¸Šåšç›¸åŒçš„æ“ä½œã€‚
  </p>

<p><br></p>
<h1>äºŒå‰æ ‘çš„éå†æ–¹å¼</h1>

<p><br></p>
<h1>DFSæ·±åº¦ä¼˜å…ˆéå†</h1>
<div>
<p>
  DFSæ·±åº¦ä¼˜å…ˆéå†ï¼šå…ˆå¾€æ·±èµ°ï¼Œé‡åˆ°å¶å­èŠ‚ç‚¹å†å¾€å›èµ°ã€‚<br>
  åˆ†ä¸ºï¼š
  å‰åºéå†ï¼ˆé€’å½’æ³•ï¼Œè¿­ä»£æ³•ï¼‰ï¼›
  ä¸­åºéå†ï¼ˆé€’å½’æ³•ï¼Œè¿­ä»£æ³•ï¼‰ï¼›
  ååºéå†ï¼ˆé€’å½’æ³•ï¼Œè¿­ä»£æ³•ï¼‰ï¼›
  <br>è¿™é‡Œå‰ä¸­åï¼Œå…¶å®æŒ‡çš„å°±æ˜¯ä¸­é—´èŠ‚ç‚¹çš„éå†é¡ºåºï¼Œåªè¦è®°ä½:å‰ä¸­ååºæŒ‡çš„å°±æ˜¯ä¸­é—´èŠ‚ç‚¹çš„ä½ç½®å°±å¯ä»¥äº†ã€‚
</p>

<p><br></p>
<h2>ä¸‰é“é¢˜çœ‹äºŒå‰æ ‘çš„å‰ä¸­ååºéå†</h2>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 50%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/binary_tree/å¾®ä¿¡æˆªå›¾_20240802183934.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 

<details>
<summary>æ ¹æ®é¦–é¡µå›¾ç‰‡ä¸­å…³äºäºŒå‰æ ‘éå†çš„æ€è·¯ï¼Œç”¨é€’å½’è§£é¢˜ã€‚æ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦éƒ½æ˜¯Oï¼ˆNï¼‰ï¼š</summary>
<pre><code>
  /**
  * Definition for a binary tree node.
  * struct TreeNode {
  *     int val;
  *     TreeNode *left;
  *     TreeNode *right;
  *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
  *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
  *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
  * };
  */
 class Solution {
 public:
 
     void calculate(TreeNode* root, vector&ltint&gt &result)//æ³¨æ„ä»¥åœ°å€çš„æ–¹å¼æ¥ä¼ é€’å‚æ•°
     {
         if(root==nullptr)
             return;
 
         result.push_back(root->val);//å‰åºéå†çš„ä½ç½®
         calculate(root->left,result);
         calculate(root->right,result);
     }
 
     vector&ltint&gt preorderTraversal(TreeNode* root) {
         vector&ltint&gt result;        
         //ç”¨é€’å½’çš„å½¢å¼å»è§£ç®—
         calculate(root, result);
         return result;
     }
 };
</code></pre>
</details>

<details>
<summary>æ­¤å¤–ï¼Œä¹Ÿå¯ä»¥ç”¨æ ˆè§£é¢˜ã€‚æ—¶é—´å¤æ‚åº¦ä¹Ÿæ˜¯Oï¼ˆNï¼‰</summary>
<pre><code>
  class Solution {
    public:
    
        vector&ltint&gt preorderTraversal(TreeNode* root) {
            vector&ltint&gt result;        
            
            // è§£æ³•ï¼šç”¨å †æ ˆçš„å½¢å¼ï¼Œå¤æ‚åº¦ä¸ºOï¼ˆNï¼‰
            stack&ltTreeNode*&gt stack_tree;
            //è¦å…ˆç¡®ä¿rootä¸ä¸ºç©ºæŒ‡é’ˆ
            if(root==nullptr)
                return result;
            stack_tree.push(root);
            while(!stack_tree.empty())//å½“å †ä¸ä¸ºç©ºï¼Œé‚£å°±æ˜¯è¿˜æœ‰ï¼Œæ‰€ä»¥ç»§ç»­
            {
                TreeNode* top=stack_tree.top();//è·å–æ ˆé¡¶
                stack_tree.pop();
                result.push_back(top->val);//æ”¾å…¥
                // é€šè¿‡æµ‹è¯•æ¥åˆ¤æ–­é¡ºåº~
                if(top->right!=nullptr)
                    stack_tree.push(top->right);
                if(top->left!=nullptr)
                    stack_tree.push(top->left);
            }
    
            return result;
        }
    };
    
</code></pre>
</details>

<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 50%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/binary_tree/å¾®ä¿¡æˆªå›¾_20240802185433.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 

<details>
<summary>ç”¨é€’å½’è§£é¢˜æœ€ç›´æ¥ï¼Œå¤æ‚åº¦è·Ÿä¸Šé¢ä¸€æ ·ï¼Œæ”¾å¯¹äº†é€’å½’çš„ä½ç½®ï¼Œç»“æœå°±è‡ªç„¶å‡ºæ¥äº†~</summary>
<pre><code>
  /**
  * Definition for a binary tree node.
  * struct TreeNode {
  *     int val;
  *     TreeNode *left;
  *     TreeNode *right;
  *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
  *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
  *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
  * };
  */
 class Solution {
 public:
     void calculate(TreeNode* root, vector&ltint&gt &result)
     {
         if(root==nullptr)
             return;
         
         calculate(root->left,result);
         result.push_back(root->val);//æ³¨æ„ä½ç½®
         calculate(root->right,result);
     }
 
     vector&ltint&gt inorderTraversal(TreeNode* root) {
         vector&ltint&gt result;
 
          // è§£æ³•1ï¼šé€’å½’ï¼ˆä¸­åºéå†å°±æ˜¯å…ˆå·¦åä¸­å†å³ï¼Œä»ä¾‹å­ä¸­ï¼Œ3æ‰åˆ°2ï¼Œæ‰€ä»¥å…ˆ3ï¼‰
         calculate(root,result);
         return result;
     }
 };
</code></pre>
</details>
<details>
<summary>ä¹Ÿå¯ä»¥é‡‡ç”¨æ ˆçš„æ€è·¯å»è§£é¢˜ï¼Œä½†æ˜¯ç›¸å¯¹å¤æ‚ä¸€äº›ï¼Œè¦è€ƒè™‘ç»†è‡´è¯»å–é¡ºåº</summary>
<pre><code>
  class Solution {
    public:
    
        vector&ltint&gt inorderTraversal(TreeNode* root) {
            vector&ltint&gt result;
    
             // è§£æ³•2ï¼šå †æ ˆ
            stack&ltTreeNode*&gt stack_int;
            while(!stack_int.empty() || root!=nullptr)
            {
                //ä»æœ€å·¦å¼€å§‹ï¼Œå·¦ä¸­å³
               while(root!=nullptr)
               {
                    stack_int.push(root);
                    root=root->left;//ç›¸å½“ä¸å…ˆå°†æ‰€æœ‰çš„å·¦èŠ‚ç‚¹æ”¾å…¥æ ˆä¸­ï¼Œç›´åˆ°æ ¹èŠ‚ç‚¹
               }
               root=stack_int.top();//è·å–æ ˆé¡¶
               stack_int.pop();//åˆ æ‰
               result.push_back(root->val);
               root = root->right;//ä¸‹ä¸€æ¬¡å°±ä»å®ƒçš„å³è¾¹å¼€å§‹æ£€æŸ¥~
    
            }
    
            return result;
        }
    };
</code></pre>
</details>

<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 50%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/binary_tree/å¾®ä¿¡æˆªå›¾_20240912165047.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
<details>
<summary>Click to expand the code</summary>
<pre><code>
<script type='text/html' style='display:block'>
  /**
  * Definition for a binary tree node.
  * struct TreeNode {
  *     int val;
  *     TreeNode *left;
  *     TreeNode *right;
  *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
  *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
  *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
  * };
  */
 class Solution {
 public:
     void calculate(TreeNode* root, vector<int> &result)
     {
         if(root==nullptr)
             return;
 
         calculate(root->left,result);
         calculate(root->right,result);
         result.push_back(root->val);//ååºéå†
     }
 
     vector<int> postorderTraversal(TreeNode* root) {
 
         vector<int> result;
         calculate(root, result);
         return result;
     }
 };
</script>
</code></pre>
</details> 

<p><br></p>
<h3>æ·±å…¥ç†è§£å‰ä¸­ååº</h3>
<pre><code>
  void traverse(TreeNode* root) {//å…¶å®å°±æ˜¯ä¸€ä¸ªèƒ½å¤Ÿéå†äºŒå‰æ ‘çš„å‡½æ•°ï¼ˆç±»ä¼¼äºé“¾è¡¨ï¼‰ä¹Ÿå°±æ˜¯ä¸€ä¸ªé€’å½’
    if (root == nullptr) {
        return;
    }
    // å‰åºä½ç½®
    traverse(root->left);
    // ä¸­åºä½ç½®
    traverse(root->right);
    // ååºä½ç½®
}
</code></pre>

<p>æ‰€è°“å‰åºä½ç½®ï¼Œå°±æ˜¯åˆšè¿›å…¥ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆå…ƒç´ ï¼‰çš„æ—¶å€™ï¼Œè€Œååºä½ç½®å°±æ˜¯å³å°†ç¦»å¼€ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆå…ƒç´ ï¼‰çš„æ—¶å€™ã€‚
  å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š
  <figure style="text-align: center;">
    <div style="margin-bottom: 10px;">
      <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/binary_tree/å¾®ä¿¡æˆªå›¾_20240802202544.png" alt="Image description">
    </div>
  <figcaption><p>
  </p></figcaption>
  </figure> 

  å‰åºä½ç½®çš„ä»£ç åœ¨åˆšåˆšè¿›å…¥ä¸€ä¸ªäºŒå‰æ ‘èŠ‚ç‚¹çš„æ—¶å€™æ‰§è¡Œï¼›(å‰åºéå†ï¼šä¸­å·¦å³)
  <br>
  ååºä½ç½®çš„ä»£ç åœ¨å°†è¦ç¦»å¼€ä¸€ä¸ªäºŒå‰æ ‘èŠ‚ç‚¹çš„æ—¶å€™æ‰§è¡Œï¼›(ä¸­åºéå†ï¼šå·¦ä¸­å³)
  <br>
  ä¸­åºä½ç½®çš„ä»£ç åœ¨ä¸€ä¸ªäºŒå‰æ ‘èŠ‚ç‚¹å·¦å­æ ‘éƒ½éå†å®Œï¼Œå³å°†å¼€å§‹éå†å³å­æ ‘çš„æ—¶å€™æ‰§è¡Œã€‚(ååºéå†ï¼šå·¦å³ä¸­)
  <br>æ‰€è°“çš„å‰ä¸­åï¼Œå…¶å®æŒ‡çš„å°±æ˜¯ä¸­é—´èŠ‚ç‚¹çš„éå†é¡ºåºã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š
  <figure style="text-align: center;">
    <div style="margin-bottom: 10px;">
      <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/binary_tree/å¾®ä¿¡æˆªå›¾_20240802202847.png" alt="Image description">
    </div>
  <figcaption>
    æ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰ã€Œå”¯ä¸€ã€å±äºè‡ªå·±çš„å‰ä¸­ååºä½ç½®ï¼Œæ‰€ä»¥å‰ä¸­ååºéå†æ˜¯éå†äºŒå‰æ ‘è¿‡ç¨‹ä¸­å¤„ç†æ¯ä¸€ä¸ªèŠ‚ç‚¹çš„ä¸‰ä¸ªç‰¹æ®Šæ—¶é—´ç‚¹ã€‚
  </figcaption>
  </figure> 
</p>

<p>
  <!-- äºŒå‰æ ‘çš„éå†åˆ†ä¸ºé€’å½’éå†ï¼ˆDFSï¼‰å’Œå±‚åºéå†ï¼ˆFBSï¼‰ã€‚
  </br> -->
  å¯¹äºé€’å½’éå†ï¼ˆDFSï¼‰æœ¬è´¨ä¸Šå°±æ˜¯é€’å½’ç®—æ³•ã€‚ä¹Ÿå°±è¯´åšå®¢<sup><a href="../Poster/é€’å½’ç±»é¢˜ç›®.html">Link</a></sup>ä¸­æåˆ°çš„å¤§éƒ¨åˆ†äºŒå‰æ ‘çš„ç®—æ³•éƒ½å¯ä»¥ç”¨é€’å½’æ¥è§£å†³çš„ç¼˜ç”±ã€‚ä¸Šé¢ä»‹ç»çš„å‰ä¸­ååºéå†éƒ½æ˜¯é€’å½’éå†çš„ä¸€ç§ã€‚
  <br>å½“ç„¶,é™¤äº†ä½¿ç”¨é€’å½’ä¹Ÿå¯ä»¥é‡‡ç”¨æ ˆçš„æ–¹å¼æ¥è§£å†³ï¼Œè¿™æ ·çš„è¯å°±æ˜¯è¿­ä»£æ³•ã€‚æ­¤å¤„ä¸åšæ·±å…¥ä»‹ç»ï¼Œè¯·è§<sup><a href="https://www.programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html" target="_blank">Link</a></sup>ã€‚
</p>


<p><br></p>
<h2>äºŒå‰æ ‘çš„ç›´å¾„</h2>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/binary_tree/WX20240824-113023.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>
<details>
<summary>Click to expand the codeã€‚å…¶å®åªæ˜¯åœ¨äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦çš„åŸºç¡€ä¸Šçš„ä¸€ä¸ªå°æ‹“å±•è€Œå·²ï½</summary>
<pre><code>
<script type='text/html' style='display:block'>
  /**
  * Definition for a binary tree node.
  * struct TreeNode {
  *     int val;
  *     TreeNode *left;
  *     TreeNode *right;
  *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
  *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
  *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
  * };
  */
 class Solution {
 public:
     int max_len=0;
     int traverse(TreeNode* root)
     {
         if(root==nullptr)//åˆ°è¾¾æ ¹èŠ‚ç‚¹å°±è¿”å›
             return 0;
 
         int left_depth=traverse(root->left);//å·¦è¾¹çš„æ·±åº¦
         int right_depth=traverse(root->right);//å³è¾¹çš„æ·±åº¦
 
         //è·å–æ­¤æ ‘çš„ç›´å¾„
         int dim=left_depth+right_depth;
         max_len=max(max_len,dim);
 
         // ååºä½ç½®ä¸Šè®¡ç®—å½“å‰èŠ‚ç‚¹çš„æœ€å¤§çš„æ·±åº¦
         return max(right_depth,left_depth)+1;
 
         
     }
     int diameterOfBinaryTree(TreeNode* root) {
         // æ¯ä¸€æ¡äºŒå‰æ ‘çš„ã€Œç›´å¾„ã€é•¿åº¦ï¼Œå°±æ˜¯ä¸€ä¸ªèŠ‚ç‚¹çš„å·¦å³å­æ ‘çš„æœ€å¤§æ·±åº¦ä¹‹å’Œã€‚
         // ä¹Ÿå°±æ˜¯åº”è¯¥åœ¨ååºçš„ä½ç½®ä¸Šç»Ÿè®¡å½“å‰æ ‘çš„æœ€å¤§æ·±åº¦
         traverse(root);
         return max_len;
 
     }
 };
</script>
</code></pre>
</details>

<p><br></p>
<h2>å¹³è¡¡äºŒå‰æ ‘</h2>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/binary_tree/WX20240920-111435.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>
<details>
<summary>Click to expand the code.DFSè·Ÿç»Ÿè®¡é«˜åº¦/æ·±åº¦åŸºæœ¬ä¸€æ ·ï¼Œåªæ˜¯å½“ä¸¤è¾¹é«˜åº¦å·®ä¸ç¬¦åˆçš„æ—¶å€™è¿”å›-1ï¼Œè€Œ-1å°±æ˜¯å¯¹åº”falseï¼Œå…¶ä½™éƒ½æ˜¯true</summary>
<pre><code>
<script type='text/html' style='display:block'>
  /**
  * Definition for a binary tree node.
  * struct TreeNode {
  *     int val;
  *     TreeNode *left;
  *     TreeNode *right;
  *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
  *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
  *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
  * };
  */
 class Solution {
 public:
     int traverse(TreeNode* root)//åŒæ ·æ˜¯ç»Ÿè®¡äºŒå‰æ ‘çš„é«˜åº¦ï¼Œä½†æ˜¯ä¸º-1çš„æ—¶å€™å°±æ˜¯ä¸æ˜¯å¹³è¡¡äºŒå‰æ ‘ï¼Œä¸ä¸º-1çš„æ—¶å€™å°±è¾“å‡º
     {
         if(root==nullptr)//åˆ°è¾¾è·ŸèŠ‚ç‚¹
             return 0;
         
         //å‰åºçš„ä½ç½®
         int left=traverse(root->left);//å·¦ä¾§çš„æ ‘çš„æ·±åº¦
         if(left==-1)
             return -1;
         //ä¸­åºçš„ä½ç½®
         int right=traverse(root->right);//å³ä¾§çš„æ ‘çš„æ·±åº¦
         if(right==-1)
             return -1;
         //ååºçš„ä½ç½®(è¿”å›æ ‘çš„é«˜åº¦ä»¥åŠæ˜¯å¦ä¸º-1)
         if(abs(right-left)>1)
             return -1;
         else//å¦åˆ™å°±è¿”å›å½“å‰çš„æ·±åº¦/é«˜åº¦
             return max(right,left)+1;
     }
     bool isBalanced(TreeNode* root) {
         // å¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼šå®ƒæ˜¯ä¸€æ£µç©ºæ ‘æˆ–å®ƒçš„å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡1ï¼Œå¹¶ä¸”å·¦å³ä¸¤ä¸ªå­æ ‘éƒ½æ˜¯ä¸€æ£µå¹³è¡¡äºŒå‰æ ‘ã€‚
         // äºŒå‰æ ‘èŠ‚ç‚¹çš„æ·±åº¦ï¼šæŒ‡ä»æ ¹èŠ‚ç‚¹åˆ°è¯¥èŠ‚ç‚¹çš„æœ€é•¿ç®€å•è·¯å¾„è¾¹çš„æ¡æ•°ã€‚
         // äºŒå‰æ ‘èŠ‚ç‚¹çš„é«˜åº¦ï¼šæŒ‡ä»è¯¥èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„æœ€é•¿ç®€å•è·¯å¾„è¾¹çš„æ¡æ•°ã€‚
         return traverse(root)==-1 ? false:true;//åŒæ ·æ˜¯ç»Ÿè®¡é«˜åº¦
     }
 };
</script>
</code></pre>
</details> 


<p><br></p>
<h2>å·¦å¶å­ä¹‹å’Œ</h2>
<div>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="../assets/img/binary_tree/å¾®ä¿¡æˆªå›¾_20240924083014.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>

<details>
<summary>Click to expand the codeã€‚æ³¨æ„é¢˜ç›®è¦æ±‚çš„åªæ˜¯å·¦å­å¶çš„å’Œã€‚é‡‡ç”¨å‰åºéå†</summary>
<pre><code>
<script type='text/html' style='display:block'>
  /**
  * Definition for a binary tree node.
  * struct TreeNode {
  *     int val;
  *     TreeNode *left;
  *     TreeNode *right;
  *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
  *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
  *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
  * };
  */
 class Solution {
 public:
     int reslut;
     void traverse(TreeNode* root) 
     {
         if(root==nullptr)//åˆ°å¶èŠ‚ç‚¹
             return;
         //å‰åºä½ç½®ç´¯åŠ 
         if(root->left!=nullptr && 
         (root->left->left==nullptr && root->left->right==nullptr))//ä¸ä¸ºç©ºï¼Œå¹¶ä¸”å®ƒçš„å­èŠ‚ç‚¹éƒ½ä¸ºç©ºã€‚åˆ™ç´¯åŠ 
             reslut=reslut+root->left->val;
 
         traverse(root->left);
         traverse(root->right);
     }
     int sumOfLeftLeaves(TreeNode* root) {
         // é‡‡ç”¨DFSã€‚æ³¨æ„åªæ˜¯å·¦å­å¶
         reslut=0;
         traverse(root);
         return reslut;
     }
 };
</script>
</code></pre>
</details>

<details>
<summary>Click to expand the code.å¦å¤–ä¸€ç§å†™æ³•ï¼ˆé‡‡ç”¨ååºéå†ï¼‰</summary>
<pre><code>
<script type='text/html' style='display:block'>
  /**
  * Definition for a binary tree node.
  * struct TreeNode {
  *     int val;
  *     TreeNode *left;
  *     TreeNode *right;
  *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
  *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
  *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
  * };
  */
 class Solution {
 public:
     int traverse(TreeNode* root) 
     {
         if(root==nullptr)//åˆ°å¶èŠ‚ç‚¹
             return 0;
 
         int leftvalue=traverse(root->left);//å·¦è¾¹çš„å·¦å­å¶
         int rightvalue=traverse(root->right);//å³è¾¹çš„å·¦å­å¶
 
         //ååºä½ç½®
         if(root->left!=nullptr && 
         (root->left->left==nullptr && root->left->right==nullptr))//ä¸ä¸ºç©ºï¼Œå¹¶ä¸”å®ƒçš„å­èŠ‚ç‚¹éƒ½ä¸ºç©ºã€‚åˆ™ç´¯åŠ 
             leftvalue=root->left->val;//æ›´æ–°å½“å‰å·¦å­å¶çš„ç»“æœ
         
         return leftvalue+rightvalue;
     }
     int sumOfLeftLeaves(TreeNode* root) {
         // é‡‡ç”¨DFSã€‚æ³¨æ„åªæ˜¯å·¦å­å¶
         return traverse(root);
     }
 };
</script>
</code></pre>
</details>

</div>


<p><br></p>
<h2>äºŒå‰æ ‘çš„æ„é€ </h2>
<div>
  <p>
    äºŒå‰æ ‘çš„æ„é€ é—®é¢˜ä¸€èˆ¬éƒ½æ˜¯ä½¿ç”¨ã€Œåˆ†è§£é—®é¢˜ã€çš„æ€è·¯ï¼šæ„é€ æ•´æ£µæ ‘ = æ ¹èŠ‚ç‚¹ + æ„é€ å·¦å­æ ‘ + æ„é€ å³å­æ ‘ã€‚
  </p>
<p><br></p>
<h3>ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘</h3>
<div>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="../assets/img/binary_tree/å¾®ä¿¡æˆªå›¾_20240925085558.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>
<details>
<summary>Click to expand the code.å›¾ç‰‡è§£æè§ä¸‹å›¾ã€‚è¿™é¢˜å…¶å®ä¸éš¾ï¼Œå…³é”®æ˜¯ç†è§£æ¸…æ¥šååºä¸ä¸­åºéå†ç›¸å¯¹çš„ä½ç½®ã€‚è€Œæ„å»ºçš„èŠ‚ç‚¹ä»¥åŠåˆ†å‰²æ•°ç»„éƒ½æ˜¯åœ¨å‰åºä½ç½®è¿›è¡Œçš„ã€‚</summary>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="../assets/img/binary_tree/å¾®ä¿¡æˆªå›¾_20240925091046.png" alt="Image description">
    <img style="width: 80%;" src="../assets/img/binary_tree/å¾®ä¿¡æˆªå›¾_20240925091554.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
<p>
åˆ†ä¸ºä»¥ä¸‹å‡ æ­¥ï¼š<br>
ç¬¬ä¸€æ­¥ï¼šå¦‚æœæ•°ç»„å¤§å°ä¸ºé›¶çš„è¯ï¼Œè¯´æ˜æ˜¯ç©ºèŠ‚ç‚¹äº†ã€‚
<br>
ç¬¬äºŒæ­¥ï¼šå¦‚æœä¸ä¸ºç©ºï¼Œé‚£ä¹ˆå–ååºæ•°ç»„æœ€åä¸€ä¸ªå…ƒç´ ä½œä¸ºèŠ‚ç‚¹å…ƒç´ ã€‚
<br>
ç¬¬ä¸‰æ­¥ï¼šæ‰¾åˆ°ååºæ•°ç»„æœ€åä¸€ä¸ªå…ƒç´ åœ¨ä¸­åºæ•°ç»„çš„ä½ç½®ï¼Œä½œä¸ºåˆ‡å‰²ç‚¹
<br>
ç¬¬å››æ­¥ï¼šåˆ‡å‰²ä¸­åºæ•°ç»„ï¼Œåˆ‡æˆä¸­åºå·¦æ•°ç»„å’Œä¸­åºå³æ•°ç»„ ï¼ˆé¡ºåºåˆ«æåäº†ï¼Œä¸€å®šæ˜¯å…ˆåˆ‡ä¸­åºæ•°ç»„ï¼‰
<br>
ç¬¬äº”æ­¥ï¼šåˆ‡å‰²ååºæ•°ç»„ï¼Œåˆ‡æˆååºå·¦æ•°ç»„å’Œååºå³æ•°ç»„
<br>
ç¬¬å…­æ­¥ï¼šé€’å½’å¤„ç†å·¦åŒºé—´å’Œå³åŒºé—´
</p>

<pre><code>
<script type='text/html' style='display:block'>
  /**
  * Definition for a binary tree node.
  * struct TreeNode {
  *     int val;
  *     TreeNode *left;
  *     TreeNode *right;
  *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
  *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
  *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
  * };
  */
 class Solution {
 public:
     TreeNode* traversal (vector<int>& inorder, vector<int>& postorder)
     {
         //é€’å½’ç»ˆæ­¢æ¡ä»¶
         if(postorder.size()==0)
             return nullptr;
 
         //ååºæ•°ç»„ä¸­æœ€åä¸€ä¸ªå…ƒç´ ä¸ºå½“å‰èŠ‚ç‚¹çš„å€¼
         int cur_rootvalue=postorder[postorder.size()-1];
         //åˆ›å»ºèŠ‚ç‚¹
         TreeNode* root=new TreeNode(cur_rootvalue);
 
         // å¦‚æœå·²ç»æ˜¯æœ€åä¸€ä¸ªäº†ï¼Œå¿…ç„¶æ˜¯å¶å­èŠ‚ç‚¹ï¼Œç›´æ¥è¿”å›å³å¯
         if (postorder.size() == 1) 
             return root;
 
         //æ ¹æ®å½“å‰çš„èŠ‚ç‚¹å€¼ï¼Œå°†ä¸­åºæ•°ç»„è¿›è¡Œåˆ‡å‰²ï¼šåˆ‡å‰²æˆleft_inorderä¸right_inorderï¼Œç»™é€’å½’ç»§ç»­è°ƒç”¨
         int index = find(inorder.begin(), inorder.end(), cur_rootvalue) - inorder.begin();
 
         //ä¸ºäº†ä¿è¯ä¸€è‡´æ€§ï¼Œç»Ÿä¸€é‡‡ç”¨å·¦é—­å³å¼€çš„å½¢å¼[0, delimiterIndex)
         vector<int> left_inorder(inorder.begin(), inorder.begin() + index);
         // æ³¨æ„inorder.begin()+indexå·²ç»è¢«é€‰æ‹©äº†ï¼[delimiterIndex + 1, end)
         vector<int> right_inorder(inorder.begin()+index+1, inorder.end());
 
 
         //æ ¹æ®inorder size==postorder sizeçš„è§„å¾‹ï¼Œå¯¹ååºæ•°ç»„è¿›è¡Œåˆ‡å‰²ï¼šåˆ‡å‰²æˆleft_postorderä¸right_postorderï¼Œç»™é€’å½’ç»§ç»­è°ƒç”¨
         // [0, leftInorder.size)
         vector<int> left_postorder(postorder.begin(), postorder.begin() + left_inorder.size());
         //  [leftInorder.size(), end-1) æœ€åä¸€ä¸ªè¢«é€‰äº†~
         vector<int> right_postorder(postorder.begin()+ left_inorder.size(), postorder.end()-1);//æ³¨æ„æ­¤å¤„ä¸åŒ…å«æœ€åä¸€ä¸ª
 
         // é€’å½’åˆ†åˆ«æ„å»ºå·¦å­æ ‘ä¸å³å­æ ‘ï¼ˆå› æ­¤ï¼Œå‰é¢å±äºå‰åºï¼Œå…ˆæ„å»ºå½“å‰çš„èŠ‚ç‚¹å€¼ï¼‰
         root->left=traversal(left_inorder, left_postorder);
         root->right=traversal(right_inorder, right_postorder);
 
         return root;
 
     }
 
     TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
         if(inorder.size()==0 || postorder.size()==0)
             return nullptr;//å¿…ç„¶ä¸ºç©º
         
         return traversal(inorder, postorder);
     }
 };
</script>
</code></pre>
</details>
</div>

<p><br></p>
<h3>ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘</h3>
<div>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="../assets/img/binary_tree/å¾®ä¿¡æˆªå›¾_20240925094221.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>

<details>
<summary>Click to expand the codeã€‚æ­¤é¢˜è·Ÿä¸Šä¸€é¢˜åŸºæœ¬æ˜¯ä¸€æ ·çš„ï¼Œä¸ä¸€æ ·çš„åªæ˜¯å‰åºéå†æ˜¯ç¬¬ä¸€ä¸ªå€¼</summary>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="../assets/img/binary_tree/å¾®ä¿¡æˆªå›¾_20240925094950.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
<pre><code>
<script type='text/html' style='display:block'>
  class Solution {
    public:
       TreeNode* traversal (vector<int>& preorder, vector<int>& inorder)
       {
           //é€’å½’ç»ˆæ­¢æ¡ä»¶
           if(preorder.size()==0)
               return nullptr;
   
           //å‰åºæ•°ç»„ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ ä¸ºå½“å‰èŠ‚ç‚¹çš„å€¼
           int cur_rootvalue=preorder[0];
           //åˆ›å»ºèŠ‚ç‚¹
           TreeNode* root=new TreeNode(cur_rootvalue);
   
           // å¦‚æœå·²ç»æ˜¯æœ€åä¸€ä¸ªäº†ï¼Œå¿…ç„¶æ˜¯å¶å­èŠ‚ç‚¹ï¼Œç›´æ¥è¿”å›å³å¯
           if (preorder.size() == 1) 
               return root;
   
           //æ ¹æ®å½“å‰çš„èŠ‚ç‚¹å€¼ï¼Œå°†ä¸­åºæ•°ç»„è¿›è¡Œåˆ‡å‰²ï¼šåˆ‡å‰²æˆleft_inorderä¸right_inorderï¼Œç»™é€’å½’ç»§ç»­è°ƒç”¨
           int index = find(inorder.begin(), inorder.end(), cur_rootvalue) - inorder.begin();
   
           //ä¸ºäº†ä¿è¯ä¸€è‡´æ€§ï¼Œç»Ÿä¸€é‡‡ç”¨å·¦é—­å³å¼€çš„å½¢å¼[0, delimiterIndex)
           vector<int> left_inorder(inorder.begin(), inorder.begin() + index);
           // æ³¨æ„inorder.begin()+indexå·²ç»è¢«é€‰æ‹©äº†ï¼[delimiterIndex + 1, end)
           vector<int> right_inorder(inorder.begin()+index+1, inorder.end());
   
   
           //æ ¹æ®inorder size==preorder sizeçš„è§„å¾‹ï¼Œå¯¹å‰åºæ•°ç»„è¿›è¡Œåˆ‡å‰²ï¼šåˆ‡å‰²æˆleft_preorderä¸right_preorderï¼Œç»™é€’å½’ç»§ç»­è°ƒç”¨
           // [1, leftInorder.size)
           vector<int> left_preorder(preorder.begin()+1, preorder.begin() +1+ left_inorder.size());
           //  [leftInorder.size(), end) 
           vector<int> right_preorder(preorder.begin()+1+ left_inorder.size(), preorder.end());
   
           // é€’å½’åˆ†åˆ«æ„å»ºå·¦å­æ ‘ä¸å³å­æ ‘ï¼ˆå› æ­¤ï¼Œå‰é¢å±äºå‰åºï¼Œå…ˆæ„å»ºå½“å‰çš„èŠ‚ç‚¹å€¼ï¼‰
           root->left=traversal(left_preorder, left_inorder);
           root->right=traversal(right_preorder,right_inorder);
   
           return root;
   
       }
   
       TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
           if(preorder.size()==0 || inorder.size()==0)
                return nullptr;//å¿…ç„¶ä¸ºç©º
            
            return traversal(preorder, inorder);
       }
   };
</script>
</code></pre>
</details>

</div>

<p><br></p>
<p>
TipsğŸ™‹â€é€šè¿‡ä¸Šé¢ä¸¤é“é¢˜ï¼Œå‰åºå’Œä¸­åºå¯ä»¥å”¯ä¸€ç¡®å®šä¸€æ£µäºŒå‰æ ‘ï¼›è€Œååºå’Œä¸­åºä¹Ÿå¯ä»¥å”¯ä¸€ç¡®å®šä¸€æ£µäºŒå‰æ ‘ã€‚ä½†æ˜¯ï¼Œå‰åºå’Œååºä¸èƒ½å”¯ä¸€ç¡®å®šä¸€æ£µäºŒå‰æ ‘ï¼ï¼Œå› ä¸ºæ²¡æœ‰ä¸­åºéå†æ— æ³•ç¡®å®šå·¦å³éƒ¨åˆ†ï¼Œä¹Ÿå°±æ˜¯æ— æ³•åˆ†å‰²ã€‚ä½†æ˜¯leetcodeä¸Šè¿˜æ˜¯æœ‰è¿™é“é¢˜ï¼Œä¸ºæ­¤æ˜¯è®©è¿”å›å…¶ä¸­ä»»æ„ä¸€ä¸ªç­”æ¡ˆ
</p>

<p><br></p>
<h3>æ ¹æ®å‰åºå’Œååºéå†æ„é€ äºŒå‰æ ‘</h3>
<div>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="../assets/img/binary_tree/å¾®ä¿¡æˆªå›¾_20240925100753.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>

<details>
<summary>Click to expand the codeã€‚
  <br>
  1ã€é¦–å…ˆæŠŠå‰åºéå†ç»“æœçš„ç¬¬ä¸€ä¸ªå…ƒç´ ç¡®å®šä¸ºæ ¹èŠ‚ç‚¹çš„å€¼(æ³¨æ„ï¼Œè¿™ä¸ªå€¼å¿…ç„¶ç­‰äºå½“å‰ååºéå†ç»“æœçš„æœ€åä¸€ä¸ªå…ƒç´ )ã€‚
  <br>
  2ã€ç„¶åæŠŠå‰åºéå†ç»“æœçš„ç¬¬äºŒä¸ªå…ƒç´ ä½œä¸ºå·¦å­æ ‘çš„æ ¹èŠ‚ç‚¹çš„å€¼ã€‚
  <br>
  3ã€åœ¨ååºéå†ç»“æœä¸­å¯»æ‰¾å·¦å­æ ‘æ ¹èŠ‚ç‚¹çš„å€¼ï¼Œä»è€Œç¡®å®šäº†å·¦å­æ ‘çš„ç´¢å¼•è¾¹ç•Œï¼Œè¿›è€Œå¯ä»¥å¯¹ååºæ•°ç»„è¿›è¡Œåˆ‡å‰²ï¼Œåˆ†ä¸ºå·¦å³å­æ•°ç»„ï¼Œå†é€’å½’æ„é€ å·¦å³å­æ ‘å³å¯ã€‚
</summary>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="../assets/img/binary_tree/å¾®ä¿¡æˆªå›¾_20240925102411.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
<pre><code>
<script type='text/html' style='display:block'>
  class Solution {
    public:
    
        TreeNode* traversal (vector<int>& preorder, vector<int>& postorder)
        {
            //é€’å½’ç»ˆæ­¢æ¡ä»¶
            if(preorder.size()==0)
                return nullptr;
    
            //å‰åºæ•°ç»„ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ ä¸ºå½“å‰èŠ‚ç‚¹çš„å€¼
            int cur_rootvalue=preorder[0];
            //åˆ›å»ºèŠ‚ç‚¹
            TreeNode* root=new TreeNode(cur_rootvalue);
    
            // å¦‚æœå·²ç»æ˜¯æœ€åä¸€ä¸ªäº†ï¼Œå¿…ç„¶æ˜¯å¶å­èŠ‚ç‚¹ï¼Œç›´æ¥è¿”å›å³å¯
            if (preorder.size() == 1) 
                return root;
    
            //æ³¨æ„ï¼Œå½“å‰çš„å‰åºç¬¬ä¸€ä¸ªå¿…ç„¶ä¸ºååºæœ€åä¸€ä¸ªï¼Œæ•…æ­¤éœ€è¦å‰”é™¤æ‰å†é€‰ï¼Œè¿›è€Œå†³å®šä¸‹ä¸€ä¸ªå·¦æ ‘çš„èµ·ç‚¹ 
            //æ‰¾åˆ°ååºæ•°ç»„ä¸­å·¦å­æ ‘çš„æ ¹èŠ‚ç‚¹ã€‚æ ¹æ®æ­¤åˆ‡å‰²å“ªé‡Œä¹‹å‰æ˜¯å·¦æ ‘ï¼
            int leftRootValue = preorder[1];
            int index = find(postorder.begin(), postorder.end(), leftRootValue) - postorder.begin();
    
             //ä¸ºäº†ä¿è¯ä¸€è‡´æ€§ï¼Œç»Ÿä¸€é‡‡ç”¨å·¦é—­å³å¼€çš„å½¢å¼[0, delimiterIndex+1)
            vector<int> left_postorder(postorder.begin(), postorder.begin() + index+1);//å½“å‰çš„è¿™ä¸ªindexéœ€è¦è¢«é€‰ä¸Šï¼Œä¸‹æ¬¡ç”¨ï¼
            // [delimiterIndex + 1, end-1)ï¼ˆæœ€åä¸€ä¸ªä¸è¦äº†ï¼‰
            vector<int> right_postorder(postorder.begin()+index+1, postorder.end()-1);//æ³¨æ„æœ€åä¸€ä¸ªå¿…ç„¶è·Ÿå½“å‰çš„å‰åºç¬¬ä¸€ä¸ªç›¸åŒï¼Œæ•…æ­¤ä¸è¦
    
            //æ ¹æ®postordersize==preorder sizeçš„è§„å¾‹ï¼Œå¯¹å‰åºæ•°ç»„è¿›è¡Œåˆ‡å‰²ï¼šåˆ‡å‰²æˆleft_preorderä¸right_preorderï¼Œç»™é€’å½’ç»§ç»­è°ƒç”¨
            // [1, leftInorder.size)
            vector<int> left_preorder(preorder.begin()+1, preorder.begin() +1+ left_postorder.size());
            //  [leftInorder.size(), end) 
            vector<int> right_preorder(preorder.begin()+1+ left_postorder.size(), preorder.end());
    
            // é€’å½’åˆ†åˆ«æ„å»ºå·¦å­æ ‘ä¸å³å­æ ‘ï¼ˆå› æ­¤ï¼Œå‰é¢å±äºå‰åºï¼Œå…ˆæ„å»ºå½“å‰çš„èŠ‚ç‚¹å€¼ï¼‰
            root->left=traversal(left_preorder, left_postorder);
            root->right=traversal(right_preorder,right_postorder);
    
            return root;
        }
    
        TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {
            if(preorder.size()==0 || postorder.size()==0)
                return nullptr;//å¿…ç„¶ä¸ºç©º
            return traversal(preorder, postorder);
        }
    };
</script>
</code></pre>
</details>

</div>


<p><br></p>
<h3>æ„é€ æœ€å¤§äºŒå‰æ ‘</h3>
<div>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="../assets/img/binary_tree/å¾®ä¿¡æˆªå›¾_20240925090141.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>

<details>
<summary>Click to expand the codeã€‚è·Ÿä¸Šé¢ä¸¤é¢˜å¾ˆåƒï¼Œåªæ˜¯ä¸Šé¢ä¸¤é¢˜é€šè¿‡å‰åºæˆ–ååºåˆ—è¡¨å…ˆç¡®å®šæœ¬èŠ‚ç‚¹çš„å€¼åŠåœ¨ä¸­åºçš„åˆ†å‰²ï¼Œä½†æ­¤é¢˜æ˜¯é€šè¿‡æœ€å¤§å€¼æ¥ç¡®å®šçš„,ç„¶åæŠŠè¾“å…¥çš„æ•°ç»„çœ‹æˆæ˜¯ä¸­åºæ•°ç»„å³å¯~</summary>
<pre><code>
<script type='text/html' style='display:block'>
  /**
  * Definition for a binary tree node.
  * struct TreeNode {
  *     int val;
  *     TreeNode *left;
  *     TreeNode *right;
  *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
  *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
  *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
  * };
  */
 class Solution {
 public:
     TreeNode* traversal (vector<int>& nums)  
     {
         //é€’å½’ç»ˆæ­¢æ¡ä»¶
         if(nums.size()==0)
             return nullptr;
 
         //è·å–å½“å‰çš„æœ€å¤§å€¼ä½œä¸ºå½“å‰èŠ‚ç‚¹çš„å€¼
         int cur_rootvalue=*max_element(nums.begin(), nums.end());
         //åˆ›å»ºèŠ‚ç‚¹
         TreeNode* root=new TreeNode(cur_rootvalue);
 
         // å¦‚æœå·²ç»æ˜¯æœ€åä¸€ä¸ªäº†ï¼Œå¿…ç„¶æ˜¯å¶å­èŠ‚ç‚¹ï¼Œç›´æ¥è¿”å›å³å¯
         if (nums.size() == 1) 
             return root;
         
         //è·å–å½“å‰èŠ‚ç‚¹å€¼çš„ç´¢å¼•
         int index = find(nums.begin(), nums.end(), cur_rootvalue) - nums.begin();
 
         //å¯¹æ•°ç»„è¿›è¡Œåˆ‡å‰²ã€‚ä¸ºäº†ä¿è¯ä¸€è‡´æ€§ï¼Œç»Ÿä¸€é‡‡ç”¨å·¦é—­å³å¼€çš„å½¢å¼[0, delimiterIndex)
         vector<int> left_nums(nums.begin(), nums.begin() + index);
         // æ³¨æ„nums.begin()+indexå·²ç»è¢«é€‰æ‹©äº†ï¼[delimiterIndex + 1, end)
         vector<int> right_nums(nums.begin()+index+1, nums.end());
 
 
         // é€’å½’åˆ†åˆ«æ„å»ºå·¦å­æ ‘ä¸å³å­æ ‘ï¼ˆå› æ­¤ï¼Œå‰é¢å±äºå‰åºï¼Œå…ˆæ„å»ºå½“å‰çš„èŠ‚ç‚¹å€¼ï¼‰
         root->left=traversal(left_nums);
         root->right=traversal(right_nums);
 
         return root;
 
     }
 
     TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
         if(nums.size()==0)
             return nullptr;//å¿…ç„¶ä¸ºç©º
         
         return traversal(nums);
     }
 };
</script>
</code></pre>
</details>

</div>

</div>



<p><br></p>
<h2>ä¸­åºéå†è§£å†³äºŒå‰æœç´¢æ ‘(Binary Search Tree, BST)</h2>
<div>
<p>
  å¯¹äºäºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰å®ƒçš„ä¸­åºéå†å¿…ç„¶æ˜¯æœ‰åºçš„ï¼ï¼ï¼
å› æ­¤ï¼Œé‡åˆ°åœ¨äºŒå‰æœç´¢æ ‘ä¸Šæ±‚ä»€ä¹ˆæœ€å€¼ï¼Œæ±‚å·®å€¼ä¹‹ç±»çš„ï¼Œéƒ½è¦æ€è€ƒä¸€ä¸‹äºŒå‰æœç´¢æ ‘å¯æ˜¯æœ‰åºçš„ï¼Œè¿›è€Œè½¬æ¢ä¸ºå‰ä¸­ååºéå†ã€‚
åŒæ—¶åœ¨é€’å½’éå†çš„è¿‡ç¨‹ä¸­è®°å½•å‰åä¸¤ä¸ªæŒ‡é’ˆï¼Œå°±å¯ä»¥å®ç°å¯¹æ¯”
</p>

<p><br></p>
<h3>éªŒè¯äºŒå‰æœç´¢æ ‘</h3>
<div>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="../assets/img/binary_tree/å¾®ä¿¡æˆªå›¾_20240926120431.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>

<details>
<summary>Click to expand the code.DFSï¼Œæ³¨æ„è¦æ±‚æ˜¯å·¦è¾¹å­æ ‘çš„å…¨éƒ¨éƒ½è¦å°äºå½“å‰çš„èŠ‚ç‚¹ï¼Œè€Œå¹¶ä¸ä»…ä»…åˆ¤æ–­å½“å‰çš„å·¦å³çš„å¤§å°ï¼è€Œç»†çœ‹é¢˜ç›®çš„è¦æ±‚ï¼Œå®é™…ä¸Šå°±æ˜¯ä¸­åºéå†ï¼Œç„¶åçœ‹è¯¥æ•°ç»„æ˜¯å¦ä¸¥æ ¼é€’å¢ï¼Œå¦‚æœæ˜¯é‚£ä¹ˆå°±æ˜¯true</summary>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 60%;" src="../assets/img/binary_tree/å¾®ä¿¡æˆªå›¾_20240926122919.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>
<pre><code>
<script type='text/html' style='display:block'>
  /**
  * Definition for a binary tree node.
  * struct TreeNode {
  *     int val;
  *     TreeNode *left;
  *     TreeNode *right;
  *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
  *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
  *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
  * };
  */
 class Solution {
 public:
     void traverse(TreeNode* root, vector<int>& group)
     {
         if(root==nullptr)
             return;
 
         traverse(root->left,group);
         //ä¸­åºçš„ä½ç½®
         group.push_back(root->val);//å°†äºŒå‰æ ‘è½¬æ¢ä¸ºæœ‰åºæ•°ç»„
 
         traverse(root->right,group);
 
     }
     bool isValidBST(TreeNode* root) {
         vector<int> group;
         
         traverse(root,group);
 
         // æ£€æŸ¥æ˜¯å¦ä¸¥æ ¼é€’å¢
         for (int i = 1; i < group.size(); i++) {
             if (group[i] <= group[i - 1]) // æ£€æŸ¥ç›¸é‚»å…ƒç´ 
                 return false;//ä¸æ˜¯é€’å¢
         }
         return true;
     }
 };
</script>
</code></pre>
</details>

<details>
<summary>Click to expand the codeã€‚ç›´æ¥åœ¨dfsçš„æ—¶å€™åˆ¤æ–­ï¼Œä½†æ˜¯è¿™ç§å†™æ³•ç›¸å¯¹ä¸å¥½ç†è§£~</summary>
<pre><code>
<script type='text/html' style='display:block'>
  /**
  * Definition for a binary tree node.
  * struct TreeNode {
  *     int val;
  *     TreeNode *left;
  *     TreeNode *right;
  *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
  *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
  *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
  * };
  */
 class Solution {
 public:
     TreeNode* pre = nullptr; // ç”¨æ¥è®°å½•å‰ä¸€ä¸ªèŠ‚ç‚¹
 
     bool traverse(TreeNode* root)
     {
         if(root==nullptr)
             return true;
 
         bool left=traverse(root->left);
 
         //ä¸­åºçš„ä½ç½®ä¸Šå†ä¸ä¸Šä¸€ä¸ªèŠ‚ç‚¹è¿›è¡Œå¯¹æ¯”ã€‚
         if(pre!=nullptr && !(pre->val<root->val))
             return false;
         pre=root;// è®°å½•å‰ä¸€ä¸ªèŠ‚ç‚¹
         //å¯¹äºä¸­åºéå†ï¼Œåº”è¯¥æ˜¯å·¦ä¸­å³ã€‚æ‰€ä»¥ä¸Šä¸€ä¸ªèŠ‚ç‚¹åº”è¯¥æ°¸è¿œå°äºå½“å‰çš„æ‰å¯ä»¥æ»¡è¶³å·¦<ä¸­<å³
 
         bool right=traverse(root->right);
 
         return (left && right);//æœ‰ä¸€ä¸ªä¸ºfalseå°±ä¸å¯¹
 
     }
     bool isValidBST(TreeNode* root) {
         
         return traverse(root);
 
     }
 };
</script>
</code></pre>
</details>

</div>


<p><br></p>
<h3>äºŒå‰æœç´¢æ ‘çš„æœ€å°ç»å¯¹å·®</h3>
<div>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="../assets/img/binary_tree/å¾®ä¿¡æˆªå›¾_20240926142312.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>

<details>
<summary>Click to expand the codeã€‚æ­¤é¢˜æœ¬è´¨ä¸Šä¹Ÿæ˜¯ä¸€ä¸ªä¸­åºéå†ï¼Œæ±‚çš„å°±æ˜¯ä¸­åºéå†çš„æ•°ç»„ä¸¤ä¸¤ä¹‹é—´çš„å·®å€¼çš„æœ€å°å€¼</summary>
<pre><code>
<script type='text/html' style='display:block'>
  class Solution {
    public:
        TreeNode* pre=nullptr;
        void traverse(TreeNode* root, int& min_value)//æ³¨æ„è¦ä¼ åœ°å€
        {
            if(root==nullptr)
                return;
            
            traverse(root->left,min_value);
            //ä¸­åºçš„ä½ç½®
            if(pre!=nullptr)
            {
                if(min_value>abs(pre->val-root->val))
                    min_value=abs(pre->val-root->val);
            }
            pre=root;// è®°å½•å½“å‰èŠ‚ç‚¹ä½œä¸ºä¸‹ä¸€ä¸ªèŠ‚ç‚¹
            traverse(root->right,min_value);
    
        }
    
        int getMinimumDifference(TreeNode* root) {
            int min_value=INT_MAX;//æœ€å°ç»å¯¹å·®ï¼Œä¸ºæ­¤åˆå§‹åŒ–ä¸ºæœ€å¤§çš„int
            traverse(root,min_value);
    
            return min_value;
        }
    };
</script>
</code></pre>
</details>

</div>


<p><br></p>
<h3>äºŒå‰æœç´¢æ ‘ä¸­çš„ä¼—æ•°</h3>
<div>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="../assets/img/binary_tree/å¾®ä¿¡æˆªå›¾_20240926145833.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>

<details>
<summary>Click to expand the codeã€‚æœ€ç›´æ¥çš„è§£é¢˜æ€è·¯å¦‚ä¸‹ã€‚å½“ç„¶hash tableè®°å½•çš„è¯æ”¾å‰ä¸­ååºéƒ½ä¸€æ ·</summary>
<pre><code>
<script type='text/html' style='display:block'>
  /**
  * Definition for a binary tree node.
  * struct TreeNode {
  *     int val;
  *     TreeNode *left;
  *     TreeNode *right;
  *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
  *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
  *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
  * };
  */
 class Solution {
 public:
     void traverse(TreeNode* root, unordered_map<int, int>& map_group)//æ³¨æ„è¦ä¼ åœ°å€
     {
         if(root==nullptr)
             return;   
 
         traverse(root->left,map_group);
 
         //ä¸­åºçš„ä½ç½®è®°å½•å½“å‰çš„å€¼
         map_group[root->val]++;//å½“å‰å€¼å‡ºç°çš„æ¬¡æ•°è®°å½•
 
         traverse(root->right,map_group);
     }
 
     static bool comparefunction(pair<int,int>a, pair<int,int>b)
     {
         return a.second > b.second;//ä»å¤§åˆ°å°æ’åˆ—
     }
 
     vector<int> findMode(TreeNode* root) {
         unordered_map<int, int> map_group;//å€¼åŠå‡ºç°çš„æ¬¡æ•°
         traverse(root,map_group);
 
         // å°† map çš„å†…å®¹å¤åˆ¶åˆ° vector ä¸­
         vector<pair<int, int>> copy_group(map_group.begin(), map_group.end());//åˆå§‹åŒ–ä¸€ä¸ªvectoræ•°ç»„
 
         sort(copy_group.begin(),copy_group.end(),comparefunction);//æ ¹æ®å‡ºç°çš„æ¬¡æ•°è¿›è¡Œæ’åº
 
         vector<int> result;
         for(int i=0;i<copy_group.size();i++)
         {
             if(copy_group[i].second==copy_group[0].second)//è·Ÿç¬¬ä¸€ä¸ªå‡ºç°æ¬¡æ•°ä¸€è‡´
             {
                 result.push_back(copy_group[i].first);//å¯¹åº”å€¼è®°å½•
             }
             else
                 break;            
         }
 
         return result;
     }
 };
</script>
</code></pre>
</details>

<details>
<summary>Click to expand the codeã€‚ä¸Šé¢çš„è§£å†³æ€è·¯å…¶å®æ˜¯å¯¹äºæ™®é€šçš„äºŒå‰æ ‘æ˜¯é€šç”¨çš„ï¼Œä½†æ˜¯ç”±äºæœ¬é¢˜æ˜¯äºŒå‰æœç´¢æ ‘ï¼Œä¸ºæ­¤å®ƒçš„ä¸­åºéå†å¿…ç„¶æ˜¯æœ‰åºçš„ï¼Œé‚£ä¹ˆå°±å¾ˆè‡ªç„¶è€Œç„¶é€šè¿‡è®¡æ•°æ³•å°±å¯ä»¥å¾—åˆ°ä¼—æ•°ï¼
  <br>æ­¤å¤–ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼šå…³äºè®¡æ•°æ¬¡æ•°çš„æ›´æ–°ä¸èƒ½å†™å…¥pre!=nullpträ¸­ï¼Œå› ä¸ºä¼šå­˜åœ¨åªæœ‰ä¸€ä¸ªæ•°ä¹Ÿå°±æ˜¯preä¸ºç©ºçš„æƒ…å†µ</summary>
<pre><code>
<script type='text/html' style='display:block'>

  class Solution {
    public:
        TreeNode* pre=nullptr;
        int max_count=0;//å‡ºç°çš„æ•°ç›®æœ€å¤š
        int each_count=1;//å‡ºç°æ¬¡æ•°çš„ç»Ÿè®¡
        void traverse(TreeNode* root, vector<int>& result)//æ³¨æ„è¦ä¼ åœ°å€
        {
            if(root==nullptr)
                return;
            
            traverse(root->left,result);
    
            //ä¸­åºçš„ä½ç½®
            if(pre!=nullptr)
            {
                if(root->val==pre->val)
                {
                    each_count++;//å†æ¬¡å‡ºç°äº†
                }
                else
                {
                    each_count=1;//æ–°å‡ºç°çš„ï¼Œæ•°ç›®ä¸º1
                }
            }
    
            //å…³äºè®¡æ•°æ¬¡æ•°çš„æ›´æ–°ï¼ˆæ³¨æ„ä¸‹é¢éƒ¨åˆ†ä¸èƒ½å†™å…¥pre!=nullpträ¸­ï¼Œå› ä¸ºä¼šå­˜åœ¨åªæœ‰ä¸€ä¸ªæ•°ä¹Ÿå°±æ˜¯preä¸ºç©ºçš„æƒ…å†µï¼‰
            if(each_count==max_count)//åŒæ ·æ˜¯å‡ºç°æ¬¡æ•°æœ€å¤š
            {
                result.push_back(root->val);
            }
            else if(each_count>max_count)//å½“å‰æ‰æ˜¯å‡ºç°çš„æ¬¡æ•°æœ€å¤šçš„
            {
                result.clear();//æ¸…ç©ºä¹‹å‰çš„è¯¯è®°å½•
                max_count=each_count;//è®°å½•å½“å‰çš„æœ€å¤§å€¼
                result.push_back(root->val);//ç»“æœæ”¾å…¥
            }
    
            pre=root;//å½“å‰èŠ‚ç‚¹ä½œä¸ºä¸Šä¸€ä¸ªè·Ÿåé¢è¿›è¡Œå¯¹æ¯”ã€‚
    
            pre=root;// è®°å½•å½“å‰èŠ‚ç‚¹ä½œä¸ºä¸‹ä¸€ä¸ªèŠ‚ç‚¹
            traverse(root->right,result);
    
        }
        vector<int> findMode(TreeNode* root) {
    
            vector<int> result;
            traverse(root,result);
            return result;
        }
    };
</script>
</code></pre>
</details>

</div>
</div>

<p><br></p>
<h2>ååºéå†è§£æœ€è¿‘å…¬å…±ç¥–å…ˆç³»åˆ—(Lowest Common Ancestorï¼ŒLCA)</h2>
<p>
  è¿™ä¸ªå…¶å®ä¹Ÿæ˜¯git pushä¸mergeçš„åŸºæœ¬åŸç†äº†ã€‚
<br>
1.æ±‚æœ€å°å…¬å…±ç¥–å…ˆï¼Œéœ€è¦ä»åº•å‘ä¸Šéå†ï¼Œé‚£ä¹ˆäºŒå‰æ ‘ï¼Œåªèƒ½é€šè¿‡ååºéå†ï¼ˆå³ï¼šå›æº¯ï¼‰å®ç°ä»åº•å‘ä¸Šçš„éå†æ–¹å¼ã€‚
<br>
2.åœ¨å›æº¯çš„è¿‡ç¨‹ä¸­ï¼Œå¿…ç„¶è¦éå†æ•´æ£µäºŒå‰æ ‘ï¼Œå³ä½¿å·²ç»æ‰¾åˆ°ç»“æœäº†ï¼Œä¾ç„¶è¦æŠŠå…¶ä»–èŠ‚ç‚¹éå†å®Œï¼Œå› ä¸ºè¦ä½¿ç”¨é€’å½’å‡½æ•°çš„è¿”å›å€¼ï¼ˆä¹Ÿå°±æ˜¯ä»£ç ä¸­çš„leftå’Œrightï¼‰åšé€»è¾‘åˆ¤æ–­ã€‚
<br>
3.è¦ç†è§£å¦‚æœè¿”å›å€¼leftä¸ºç©ºï¼Œrightä¸ä¸ºç©ºä¸ºä»€ä¹ˆè¦è¿”å›rightï¼Œä¸ºä»€ä¹ˆå¯ä»¥ç”¨è¿”å›rightä¼ ç»™ä¸Šä¸€å±‚ç»“æœã€‚
</p>

<p><br></p>
<h3>äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ</h3>
<div>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="../assets/img/binary_tree/å¾®ä¿¡æˆªå›¾_20240926214033.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>

<details>
<summary>Click to expand the code.é¦–å…ˆååºéå†å®ç°äº†è‡ªä¸‹è€Œä¸Šçš„è¿‡ç¨‹ï¼Œæ ¹æ®ç›®å‰å·¦å³èŠ‚ç‚¹çš„æƒ…å†µæ¥å¾€å‰æ¨æ–­ã€‚
  <br>è€Œé€’å½’çš„ç»ˆæ­¢å°±æ˜¯ç›´åˆ°è·ŸèŠ‚ç‚¹æˆ–æ‰¾åˆ°pæˆ–qå¼€å§‹ä»ä¸‹è€Œä¸Šã€‚
  <br>è€Œæ³¨æ„på’Œqå¿…ç„¶ä¼šå‡ºç°ä¸”åªä¼šå‡ºç°ä¸€æ¬¡ï¼Œå› æ­¤å½“æ‰¾åˆ°äº†æœ€è¿‘å¤„å·¦å³éƒ½ä¸ä¸ºç©ºçš„æƒ…å†µï¼Œè¿”å›äº†å½“å‰çš„èŠ‚ç‚¹ï¼Œé‚£ä¹ˆå°±æ˜¯æœ€è¿‘çš„ç¥–å…ˆäº†ã€‚è€Œä¹‹åæ˜¯ä¸ä¼šå†å­˜åœ¨å·¦å³ä¸ä¸ºç©ºçš„æƒ…å†µäº†ã€‚
  <br>æ›´è¯¦ç»†çš„åˆ†æè¯·å‚è€ƒåšå®¢ï¼š<a href="https://www.programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html#%E6%80%9D%E8%B7%AF" target="_blank">ä»£ç éšæƒ³å½•</a>ã€‚
</summary>
<pre><code>
<script type='text/html' style='display:block'>
  /**
  * Definition for a binary tree node.
  * struct TreeNode {
  *     int val;
  *     TreeNode *left;
  *     TreeNode *right;
  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  * };
  */
 class Solution {
 public:
     TreeNode* traverse(TreeNode* root, TreeNode* p, TreeNode* q)
     {
         //é€’å½’ç»ˆæ­¢çš„æ¡ä»¶
         if(root==NULL || root == q || root == p)
             return root;//å¦‚æœ root == qï¼Œæˆ–è€… root == pï¼Œè¯´æ˜æ‰¾åˆ° q p ï¼Œåˆ™å°†å…¶è¿”å›
         
         TreeNode* left=traverse(root->left,p,q);
 
         TreeNode* right=traverse(root->right,p,q);
 
         //ååºçš„ä½ç½®
 
         if(left!=NULL && right!=NULL)
             return root;//æ‰¾åˆ°äº†å°±è¿”å›å½“å‰å€¼
 
         // å¦‚æœleftä¸ºç©ºï¼Œrightä¸ä¸ºç©ºï¼Œå°±è¿”å›rightï¼Œè¯´æ˜ç›®æ ‡èŠ‚ç‚¹æ˜¯é€šè¿‡rightè¿”å›çš„ï¼Œåä¹‹ä¾ç„¶ã€‚
         //æ³¨æ„å½“æ‰¾åˆ°äº†æœ€è¿‘ç¥–å…ˆç‚¹åï¼Œå¾€ä¸Šä¼ é€’çš„æ—¶å€™ï¼Œæ°¸è¿œåªä¿ç•™æœ‰å€¼çš„å­æ ‘ï¼Œè€Œå¦å¤–å­æ ‘å¿…ç„¶æ˜¯ç©ºçš„ï¼Œå› ä¸ºæ²¡æ‰¾åˆ°ï¼
         else if(left==NULL && right!=NULL)
             return right;
         else if(left!=NULL && right==NULL)
             return left;
         else
             return NULL;//éƒ½ä¸ºç©ºé‚£ä¹ˆå°±è¿”å›ç©º
 
     }
     TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
 
         //é¦–å…ˆé€šè¿‡äºŒå‰æ ‘çš„ååºéå†ï¼ˆå·¦å³ä¸­ï¼‰ï¼Œå°±å¯ä»¥å®ç°ä»åº•å‘ä¸ŠæŸ¥
         //è¿›è€Œå®ç°æ ¹æ®å·¦å³å­æ ‘çš„è¿”å›å€¼ï¼Œæ¥å¤„ç†ä¸­èŠ‚ç‚¹çš„é€»è¾‘ã€‚
 
         //åŒæ—¶ï¼Œé¢˜ç›®ä¹Ÿå¼ºè°ƒäº†ï¼šäºŒå‰æ ‘èŠ‚ç‚¹æ•°å€¼æ˜¯ä¸é‡å¤çš„ï¼Œè€Œä¸”ä¸€å®šå­˜åœ¨ q å’Œ p
 
         //å› æ­¤ï¼Œåˆ¤æ–­é€»è¾‘æ˜¯å¦‚æœé€’å½’éå†é‡åˆ°qï¼Œå°±å°†qè¿”å›ï¼Œé‡åˆ°p å°±å°†pè¿”å›
         // å¦‚æœ å·¦å³å­æ ‘çš„è¿”å›å€¼éƒ½ä¸ä¸ºç©ºï¼Œè¯´æ˜æ­¤æ—¶çš„ä¸­èŠ‚ç‚¹ï¼Œä¸€å®šæ˜¯q å’Œp çš„æœ€è¿‘ç¥–å…ˆã€‚
 
         return traverse(root,p,q);
         
     }
 };
</script>
</code></pre>
</details>

</div> 


235, 1644, 1650, 1676


</div>

<p><br></p>
<h1>BFSå¹¿åº¦ä¼˜å…ˆéå†</h1>
<div>
<p>
  BFSå¹¿åº¦ä¼˜å…ˆéå†ï¼šä¸€å±‚ä¸€å±‚çš„å»éå†.<br>
  å±‚æ¬¡éå†ï¼ˆè¿­ä»£æ³•ï¼‰
</br>
å¯¹äºäºŒå‰æ ‘çš„å±‚åºéå†ï¼Œå°±æ˜¯ä»å·¦åˆ°å³ä¸€å±‚ä¸€å±‚çš„å»éå†äºŒå‰æ ‘ã€‚
è¿™ç§éå†æ–¹å¼é€šå¸¸éœ€è¦å€ŸåŠ©é˜Ÿåˆ—æ¥å®ç°ã€‚<strong>é˜Ÿåˆ—å…ˆè¿›å…ˆå‡º</strong>ï¼Œç¬¦åˆä¸€å±‚ä¸€å±‚éå†çš„é€»è¾‘ï¼Œè€Œç”¨æ ˆå…ˆè¿›åå‡ºé€‚åˆæ¨¡æ‹Ÿæ·±åº¦ä¼˜å…ˆéå†ä¹Ÿå°±æ˜¯é€’å½’çš„é€»è¾‘ï¼ˆæ•…æ­¤ä¸Šé¢DFSä¹Ÿæœ‰ç»™å‡ºæ ˆè§£æ³•ï¼Œåªæ˜¯é€’å½’å‰ä¸­ååºæ›´ç›´æ¥ï½ï¼‰ã€‚
<!-- <details> -->
<!-- <summary>-->
  ä»£ç æ¡†æ¶å¦‚ä¸‹ ï¼š
  <!-- (ğŸ™‹â€æš‚æ—¶è¿˜æ²¡ç”¨åˆ°è¿‡ï¼Œä¹Ÿæ²¡æœ‰ç†è§£å¾ˆé€å½»ã€‚<a href="https://labuladong.online/algo/data-structure-basic/binary-tree-traverse-basic/" target="_blank">å‚è€ƒé“¾æ¥</a>)ï¼š -->
<!-- </summary> -->
<pre><code>
void levelOrderTraverse(TreeNode* root) {

  //å½“åˆ°ç»ˆç‚¹çš„æ—¶å€™å°±è¿”å›
  if (root == nullptr) {
      return;
  }

  // åˆå§‹åŒ–é˜Ÿåˆ—ï¼Œå°†æ ¹èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ—
  std::queue&ltTreeNode*&gt q;
  q.push(root);
  while (!q.empty()) {
      TreeNode* cur = q.front();//è·å–é˜Ÿåˆ—çš„å¤´
      q.pop();//åˆ é™¤é˜Ÿåˆ—çš„å¤´

      // è®¿é—® cur èŠ‚ç‚¹
      std::cout &lt&lt cur->val &lt&lt std::endl;

      // æŠŠ cur çš„å·¦å³å­èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ—
      if (cur->left != nullptr) {
          q.push(cur->left);
      }
      if (cur->right != nullptr) {
          q.push(cur->right);
      }
  }
}
</code></pre>
<!-- </details> -->

ä½¿ç”¨é˜Ÿåˆ—å®ç°äºŒå‰æ ‘å¹¿åº¦ä¼˜å…ˆéå†ï¼ŒåŠ¨ç”»å¦‚ä¸‹ï¼š
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/binary_tree/102äºŒå‰æ ‘çš„å±‚åºéå†.gif" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>
</p>

<p><br></p>
<h2>äºŒå‰æ ‘çš„å±‚åºéå†</h2>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/binary_tree/WX20240914-212858.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>
<details>
<summary>Click to expand the codeã€‚é‡‡ç”¨é˜Ÿåˆ—è¿›è¡Œå±‚åºéå†ï¼Œæ³¨æ„æ£€æŸ¥æ˜¯å¦ä¸ºç©ºå†æ”¾å…¥é˜Ÿåˆ—ä¸­</summary>
<pre><code>
<script type='text/html' style='display:block'>
  /**
  * Definition for a binary tree node.
  * struct TreeNode {
  *     int val;
  *     TreeNode *left;
  *     TreeNode *right;
  *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
  *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
  *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
  * };
  */
 class Solution {
 public:
     vector<vector<int>> levelOrder(TreeNode* root) {
 
         vector<vector<int>> result;
 
         //åˆå§‹åŒ–é˜Ÿåˆ—ï¼ˆå…ˆå…¥å…ˆå‡ºï¼‰
         std::queue<TreeNode*> q;
         if(root!=nullptr)
             q.push(root);
         
         while(!q.empty())
         {
             int cur_size=q.size();//å½“å‰å±‚çš„èŠ‚ç‚¹æ•°ç›®
             vector<int> cur_temp;//å­˜æ”¾å½“å‰å±‚ï¼ˆä»å·¦åˆ°å³ï¼Œæ‰€æœ‰çš„èŠ‚ç‚¹ï¼‰
 
             for(int i=0;i<cur_size;i++)
             {
                 TreeNode* cur=q.front();//è·å–é˜Ÿåˆ—å¼€å¤´ï¼ˆå…ˆå…¥å…ˆå‡ºï¼‰
                 q.pop();//åˆ æ‰
                 cur_temp.push_back(cur->val);//è·å–å½“å‰èŠ‚ç‚¹çš„å€¼
                 
                 //å½“å‰èŠ‚ç‚¹çš„å·¦å­èŠ‚ç‚¹ä¸å³å­èŠ‚ç‚¹æ”¾å…¥é˜Ÿåˆ—ä¸­ï¼Œä¸‹æ¬¡ç”¨(æ³¨æ„é¡ºåºæ˜¯å…ˆæ”¾å·¦åæ”¾å³)
                 if(cur->left!=nullptr)//æ³¨æ„ä¸ä¸ºç©ºå†æ”¾
                     q.push(cur->left);
                 if(cur->right!=nullptr)
                     q.push(cur->right);
             }
             result.push_back(cur_temp);
 
         }
 
         return result;
 
 
     }
 };
</script>
</code></pre>
</details> 

<p><br></p>
<h2>äºŒå‰æ ‘çš„å±‚æ¬¡éå† II</h2>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/binary_tree/WX20240914-215511.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 

<details>
<summary>Click to expand the codeã€‚è·Ÿä¸Šé¢˜ä¸€æ ·ï¼Œåªæ˜¯ç»“æœåŠ ä¸ªåè½¬</summary>
<pre><code>
<script type='text/html' style='display:block'>
  /**
  * Definition for a binary tree node.
  * struct TreeNode {
  *     int val;
  *     TreeNode *left;
  *     TreeNode *right;
  *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
  *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
  *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
  * };
  */
 class Solution {
 public:
     vector<vector<int>> levelOrderBottom(TreeNode* root) {
         
         //ç±»ä¼¼102çš„ç¨‹åºéå†ï¼Œæœ€åæŠŠç»“æœåè½¬ä¸€ä¸‹å³å¯ï½
         vector<vector<int>> result;
  
          //åˆå§‹åŒ–é˜Ÿåˆ—ï¼ˆå…ˆå…¥å…ˆå‡ºï¼‰
          std::queue<TreeNode*> q;
          if(root!=nullptr)
              q.push(root);
          
          while(!q.empty())
          {
              int cur_size=q.size();//å½“å‰å±‚çš„èŠ‚ç‚¹æ•°ç›®
              vector<int> cur_temp;//å­˜æ”¾å½“å‰å±‚ï¼ˆä»å·¦åˆ°å³ï¼Œæ‰€æœ‰çš„èŠ‚ç‚¹ï¼‰
  
              for(int i=0;i<cur_size;i++)
              {
                  TreeNode* cur=q.front();//è·å–é˜Ÿåˆ—å¼€å¤´ï¼ˆå…ˆå…¥å…ˆå‡ºï¼‰
                  q.pop();//åˆ æ‰
                  cur_temp.push_back(cur->val);//è·å–å½“å‰èŠ‚ç‚¹çš„å€¼
                  
                  //å½“å‰èŠ‚ç‚¹çš„å·¦å­èŠ‚ç‚¹ä¸å³å­èŠ‚ç‚¹æ”¾å…¥é˜Ÿåˆ—ä¸­ï¼Œä¸‹æ¬¡ç”¨(æ³¨æ„é¡ºåºæ˜¯å…ˆæ”¾å·¦åæ”¾å³)
                  if(cur->left!=nullptr)//æ³¨æ„ä¸ä¸ºç©ºå†æ”¾
                      q.push(cur->left);
                  if(cur->right!=nullptr)
                      q.push(cur->right);
              }
              result.push_back(cur_temp);//æŠŠæ¯ä¸€å±‚çš„ç»“æœè®°å½•
  
          }
 
          reverse(result.begin(),result.end());//æœ€åç»“æœè¿›è¡Œåè½¬ï½
          return result;
  
     }
 };
</script>
</code></pre>
</details>

<p><br></p>
<h2>äºŒå‰æ ‘çš„å³è§†å›¾</h2>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/binary_tree/WX20240914-220107.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 

<details>
<summary>Click to expand the codeã€‚åŒæ ·æ˜¯å±‚åºéå†ï¼Œä¸è¿‡åªçœ‹æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼ˆæ³¨æ„æ˜¯æœ€åä¸€ä¸ªï¼Œä¸ä¸€å®šæ˜¯å³ä¾§çš„ï¼‰</summary>
<pre><code>
<script type='text/html' style='display:block'>
  /**
  * Definition for a binary tree node.
  * struct TreeNode {
  *     int val;
  *     TreeNode *left;
  *     TreeNode *right;
  *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
  *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
  *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
  * };
  */
 class Solution {
 public:
     vector<int> rightSideView(TreeNode* root) {
 
         //åŒæ ·æ˜¯å±‚åºéå†ï¼Œä¸è¿‡åªçœ‹æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼ˆæ³¨æ„æ˜¯æœ€åä¸€ä¸ªï¼Œä¸ä¸€å®šæ˜¯å³ä¾§çš„ï¼‰
 
         queue<TreeNode*> que;
 
         if(root!=nullptr)
             que.push(root);
 
         vector<int> result;
         while(!que.empty())//ä¸ä¸ºç©º
         {
             int cur_size=que.size();
             for(int i=0;i<cur_size;i++)
             {
                 TreeNode* cur=que.front();//æ¨å‡ºç¬¬ä¸€ä¸ª
                 que.pop();//åˆ æ‰
 
                 if(i==(cur_size-1))//æœ€åä¸€ä¸ª
                     result.push_back(cur->val);
 
                 //å±‚åºéå†å…ˆå·¦åå³
                 if(cur->left!=nullptr)
                     que.push(cur->left);
 
                 if(cur->right!=nullptr)//ä¸ä¸ºç©ºï¼Œæ’å…¥
                     que.push(cur->right);
             }
         }
 
         return result;
     }
 };
</script>
</code></pre>
</details>


<p><br></p>
<h2>äºŒå‰æ ‘çš„å±‚å¹³å‡å€¼</h2>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/binary_tree/WX20240914-222011.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>
<details>
<summary>Click to expand the code</summary>
<pre><code>
<script type='text/html' style='display:block'>
  /**
  * Definition for a binary tree node.
  * struct TreeNode {
  *     int val;
  *     TreeNode *left;
  *     TreeNode *right;
  *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
  *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
  *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
  * };
  */
 class Solution {
 public:
     vector<double> averageOfLevels(TreeNode* root) {
 
         queue<TreeNode*> que;
 
         if(root!=nullptr)
             que.push(root);
         
         vector<double> result;
         while(!que.empty())
         {
             int cur_size=que.size();//å½“å‰å±‚èŠ‚ç‚¹çš„æ•°ç›®
             double sum=0.0;
             for(int i=0;i<cur_size;i++)
             {
                 TreeNode* cur=que.front();
                 que.pop();
 
                 sum+=cur->val;
 
                 //å…ˆæ”¾å…¥å·¦å†æ”¾å…¥å³
                 if(cur->left!=nullptr)
                     que.push(cur->left);
                 
                 if(cur->right!=nullptr)
                     que.push(cur->right);
 
             }
             result.push_back( double(sum/cur_size));
         }
 
         return result;
     }
 };
</script>
</code></pre>
</details>

<p><br></p>
<h2>Nå‰æ ‘çš„å±‚åºéå†</h2>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/binary_tree/WX20240915-200549.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>  
<details>
<summary>Click to expand the codeã€‚Nå‰æ ‘åªæ˜¯äºŒå‰æ ‘çš„ç®€å•æ‹“å±•ï½</summary>
<pre><code>
<script type='text/html' style='display:block'>
  /*
  // Definition for a Node.
  class Node {
  public:
      int val;
      vector<Node*> children;
  
      Node() {}
  
      Node(int _val) {
          val = _val;
      }
  
      Node(int _val, vector<Node*> _children) {
          val = _val;
          children = _children;
      }
  };
  */
  
  class Solution {
  public:
      vector<vector<int>> levelOrder(Node* root) {
  
          vector<vector<int>> result;
          
          queue<Node*> que;
          if(root!=nullptr)
              que.push(root);
          
          while(!que.empty())
          {
              int cur_size=que.size();
              vector<int> temp;
  
              for(int i=0;i<cur_size;i++)
              {
                  Node* cur=que.front();
                  que.pop();
  
                  temp.push_back(cur->val);
  
                  //ä¾æ¬¡æŠŠèŠ‚ç‚¹æ”¾å…¥queä¸­
                  for(auto temp_children:cur->children)
                      que.push(temp_children);
              }
              result.push_back(temp);
          }
  
          return result;
      }
  };
</script>
</code></pre>
</details>

<p><br></p>
<h2>åœ¨æ¯ä¸ªæ ‘è¡Œä¸­æ‰¾æœ€å¤§å€¼</h2>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/binary_tree/WX20240915-203117.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 

<details>
<summary>Click to expand the code</summary>
<pre><code>
<script type='text/html' style='display:block'>
  /**
  * Definition for a binary tree node.
  * struct TreeNode {
  *     int val;
  *     TreeNode *left;
  *     TreeNode *right;
  *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
  *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
  *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
  * };
  */
 class Solution {
 public:
     vector<int> largestValues(TreeNode* root) {
         
         queue<TreeNode*> que;
  
         if(root!=nullptr)
              que.push(root);
          
         vector<int> result;
         while(!que.empty())
         {
             int cur_size=que.size();//å½“å‰å±‚èŠ‚ç‚¹çš„æ•°ç›®
             int max_value=INT_MIN;//å­˜åœ¨è´Ÿæ•°ï¼Œæ•…æ­¤ä¸èƒ½åˆå§‹åŒ–ä¸º0
 
             //éå†å½“å‰å±‚ï¼Œè®°å½•æœ€å¤§å€¼
             for(int i=0;i<cur_size;i++)
             {
                 TreeNode* cur=que.front();
                 que.pop();
 
                 max_value=max(max_value,cur->val);
 
                 //å…ˆæ”¾å…¥å·¦å†æ”¾å…¥å³
                 if(cur->left!=nullptr)
                     que.push(cur->left);
                 
                 if(cur->right!=nullptr)
                     que.push(cur->right);
 
             }
             result.push_back(max_value);
         }
         return result;
     }
 };
</script>
</code></pre>
</details>

<p><br></p>
<h2>å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ</h2>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/binary_tree/WX20240915-203743.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 

<details>
<summary>Click to expand the codeã€‚ä¸è¦é‡‡ç”¨æŒ‡é’ˆçš„æ€æƒ³ï¼Œå•çº¯æŠŠæ¯ä¸ªèŠ‚ç‚¹çš„nextèµ‹å€¼å³å¯</summary>
<pre><code>
<script type='text/html' style='display:block'>
  /*
  // Definition for a Node.
  class Node {
  public:
      int val;
      Node* left;
      Node* right;
      Node* next;
  
      Node() : val(0), left(NULL), right(NULL), next(NULL) {}
  
      Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}
  
      Node(int _val, Node* _left, Node* _right, Node* _next)
          : val(_val), left(_left), right(_right), next(_next) {}
  };
  */
  
  class Solution {
  public:
      Node* connect(Node* root) {
          
          queue<Node*> que;
          if(root!=NULL)
              que.push(root);
  
          while(!que.empty())
          {
              int cur_size=que.size();
  
              //éå†è¿™ä¸€å±‚
              for(int i=0;i<cur_size;i++)
              {
                  Node* cur=que.front();
                  que.pop();
  
                  if(i!=cur_size-1)
                  {//ä¸ä¸ºæœ€åä¸€ä¸ªèŠ‚ç‚¹
                      cur->next=que.front();//å½“å‰ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æŒ‡å‘å®ƒçš„å³ä¾§
                  }
  
                  //å…ˆå·¦åå³
                  if(cur->left)
                      que.push(cur->left);
                  if(cur->right)
                      que.push(cur->right);
              }
              
          }
  
          return root; // è¿”å›èŠ‚ç‚¹è‡ªèº«ï¼Œåªæ˜¯æ·»åŠ äº†nextæŒ‡é’ˆ
      }
  };
</script>
</code></pre>
</details>

<p><br></p>
<h2>äºŒå‰æ ‘çš„æœ€å°æ·±åº¦</h2>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/binary_tree/WX20240916-221040.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
<details>
<summary>Click to expand the codeã€‚é‡‡ç”¨DFSï¼Œè¦æ³¨æ„åŒºåˆ†ç©ºå­æ ‘å’Œéç©ºå­æ ‘ã€‚å¦‚æœä¸€ä¸ªèŠ‚ç‚¹åªæœ‰ä¸€ä¸ªéç©ºçš„å­æ ‘ï¼Œå®ƒçš„æœ€å°æ·±åº¦åº”è¯¥æ˜¯éç©ºå­æ ‘çš„æ·±åº¦ï¼Œè€Œä¸æ˜¯ 0ã€‚
</summary>
<pre><code>
<script type='text/html' style='display:block'>
  /**
  * Definition for a binary tree node.
  * struct TreeNode {
  *     int val;
  *     TreeNode *left;
  *     TreeNode *right;
  *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
  *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
  *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
  * };
  */
 class Solution {
 public:
 
     int traverse(TreeNode* root) 
     {
         //é€’å½’ç»ˆæ­¢æ¡ä»¶
         if(root==nullptr)
             return 0;
         
         //å‰åºçš„ä½ç½®
         int left=traverse(root->left);//å·¦ä¾§çš„æ ‘çš„æ·±åº¦
         //ä¸­åºçš„ä½ç½®
         int right=traverse(root->right);//å³ä¾§çš„æ ‘çš„æ·±åº¦
          
         //ååºçš„ä½ç½®
         // å¦‚æœä¸€ä¸ªå­æ ‘ä¸ºç©ºï¼Œè¿”å›å¦ä¸€ä¸ªå­æ ‘çš„æ·±åº¦
         if (root->left == nullptr)
             return right + 1;
         if (root->right == nullptr)
             return left + 1;
 
         // å¦‚æœå·¦å³å­æ ‘éƒ½ä¸ä¸ºç©ºï¼Œè¿”å›æœ€å°æ·±åº¦
         return min(left, right) + 1;
         //åŠ ä¸Šè‡ªèº«+1
     }
 
     int minDepth(TreeNode* root) {
         return traverse(root);
     }
 };
</script>
</code></pre>
</details>

<details>
<summary>Click to expand the codeã€‚BFSè§£æ³•ã€‚æ‰€è°“çš„å¶èŠ‚ç‚¹æŒ‡çš„æ˜¯å·¦å³ä¸¤ä¸ªå­èŠ‚ç‚¹å‡ä¸ºç©ºï½</summary>
<pre><code>
<script type='text/html' style='display:block'>
  /**
  * Definition for a binary tree node.
  * struct TreeNode {
  *     int val;
  *     TreeNode *left;
  *     TreeNode *right;
  *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
  *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
  *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
  * };
  */
 class Solution {
 public:
     int minDepth(TreeNode* root) {
 
         queue<TreeNode* >que;
 
         if(root!=nullptr)
             que.push(root);
         int min_depth=0;
         while(!que.empty())
         {
             int cur_size=que.size();
 
             min_depth++;//æ¯å±‚æ·±åº¦è‡ªåŠ 
             for(int i=0;i<cur_size;i++)//éå†å½“å‰å±‚
             {
                 TreeNode* cur=que.front();
                 que.pop();
 
                 //å…ˆå·¦åå³
                 if(cur->left!=nullptr)
                     que.push(cur->left);
                 if(cur->right!=nullptr)
                     que.push(cur->right);
 
                 // å½“å·¦å³å­èŠ‚ç‚¹éƒ½ä¸ºç©ºçš„æ—¶å€™ï¼Œè¯´æ˜æ˜¯æœ€ä½ç‚¹çš„ä¸€å±‚äº†ï¼Œé€€å‡º
                 if(cur->left==nullptr && cur->right==nullptr)
                     return min_depth;
             }
         }
 
         return min_depth;
     }
 };
</script>
</code></pre>
</details>

<p><br></p>
<h2>æ‰¾æ ‘å·¦ä¸‹è§’çš„å€¼</h2>
<div>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="../assets/img/binary_tree/å¾®ä¿¡æˆªå›¾_20240924090605.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>

<details>
<summary>Click to expand the codeã€‚BFS</summary>
<pre><code>
<script type='text/html' style='display:block'>
  /**
  * Definition for a binary tree node.
  * struct TreeNode {
  *     int val;
  *     TreeNode *left;
  *     TreeNode *right;
  *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
  *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
  *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
  * };
  */
 class Solution {
 public:
     int findBottomLeftValue(TreeNode* root) {
 
         // BFSéå†
         queue<TreeNode*> que;
         
         if(root!=nullptr)
             que.push(root);
 
         int result=0;
         while(!que.empty())
         {
             int cur_size=que.size();//å½“å‰å±‚çš„èŠ‚ç‚¹æ•°ç›®
 
             for(int i=0;i<cur_size;i++)
             {
                 TreeNode* cur=que.front();
                 que.pop();
 
                 if(i==0)//æœ€å·¦ä¾§
                     result=cur->val;//ä¸€ç›´æ›´æ–°
 
                 if(cur->left!=nullptr)
                     que.push(cur->left);
                 if(cur->right!=nullptr)
                     que.push(cur->right);
             }
         }
 
         return result;
     }
 };
</script>
</code></pre>
</details>

</div> 
</div> 

<p><br></p>
<h1>åŒæ—¶é€‚ç”¨DFSä¸BFSä¸¤ç§è§£æ³•</h1>
<div>
<p>
  é’ˆå¯¹äºŒå‰æ ‘çš„é—®é¢˜ï¼Œè§£é¢˜ä¹‹å‰ä¸€å®šè¦æƒ³æ¸…æ¥šç©¶ç«Ÿæ˜¯å‰ä¸­ååºéå†ï¼Œè¿˜æ˜¯å±‚åºéå†ã€‚å‰ä¸­ååºéå†æ˜¯DFSï¼Œå±‚åºéå†æ˜¯BFSã€‚å½“ç„¶éƒ¨åˆ†çš„é¢˜ç›®ä¸¤ç§è§£æ³•å‡å¯ï¼Œä¸‹é¢ç»™å‡ºæ ·ä¾‹ã€‚
</p>
<p><br></p>
<h2>ç¿»è½¬äºŒå‰æ ‘</h2>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/binary_tree/WX20240919-203658.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>  
<details>
<summary>Click to expand the codeï¼Œé‡‡ç”¨DFSæ¥åš</summary>
<pre><code>
<script type='text/html' style='display:block'>
  /**
  * Definition for a binary tree node.
  * struct TreeNode {
  *     int val;
  *     TreeNode *left;
  *     TreeNode *right;
  *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
  *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
  *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
  * };
  */
 class Solution {
 public:
     void traverse(TreeNode* root) 
     {
         //é€’å½’ç»ˆæ­¢çš„æ¡ä»¶
         if(root==nullptr)
             return;
 
         // *** å‰åºä½ç½® ***
         // æ¯ä¸€ä¸ªèŠ‚ç‚¹éœ€è¦åšçš„äº‹å°±æ˜¯äº¤æ¢å®ƒçš„å·¦å³å­èŠ‚ç‚¹.
         // å…ˆç¿»è½¬äº†ï¼Œç„¶åå†ç»§ç»­éå†ï¼Œä¸ºæ­¤åº”è¯¥ä½äºå‰åºçš„ä½ç½®
         TreeNode* temp=root->left;
         root->left=root->right;
         root->right=temp;
 
         //ç„¶åç»§ç»­éå†å·¦ä¸å³èŠ‚ç‚¹
         traverse(root->left); 
         traverse(root->right); 
         
     }
     TreeNode* invertTree(TreeNode* root) {
         
         //DFS,ç”¨é€’å½’çš„æ€è·¯ï¼Œæ¯ä¸€å±‚å°†å®ƒçš„å·¦å³èŠ‚ç‚¹è°ƒè½¬
         if(root!=nullptr)
             traverse(root);
         return root;
     }
 };
</script>
</code></pre>
</details>

<details>
<summary>Click to expand the codeã€‚é‡‡ç”¨BFS</summary>
<pre><code>
<script type='text/html' style='display:block'>
  /**
  * Definition for a binary tree node.
  * struct TreeNode {
  *     int val;
  *     TreeNode *left;
  *     TreeNode *right;
  *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
  *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
  *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
  * };
  */
 class Solution {
 public:
     TreeNode* invertTree(TreeNode* root) {
         
         queue<TreeNode* > que;
 
         if(root!=nullptr)
             que.push(root);
 
         while(!que.empty())
         {
             int cur_size=que.size();//å½“å‰å±‚çš„èŠ‚ç‚¹æ•°
 
             for(int i=0;i<cur_size;i++)
             {
                 TreeNode* cur=que.front();
                 que.pop();
 
                 //è¿›è¡Œäº¤æ¢
                 // auto temp=cur->left;
                 // cur->left=cur->right;
                 // cur->right=temp;
                 swap(cur->left, cur->right); // å‡½æ•°ä»£æ›¿ä¸Šé¢3è¡Œ
 
                 if(cur->left!=nullptr)
                     que.push(cur->left);
                 if(cur->right!=nullptr)
                     que.push(cur->right);
             }
         }
 
         return root;//åŸåœ°æ›¿æ¢è€Œéé‡æ–°ç”Ÿæˆæ ‘ï¼ˆç”¨çš„æ˜¯æŒ‡é’ˆï½ï¼‰
     }
 };
</script>
</code></pre>
</details> 

<p><br></p>
<h2>å¯¹ç§°äºŒå‰æ ‘</h2>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/binary_tree/WX20240919-210317.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
<details>
<summary>Click to expand the codeã€‚ç±»ä¼¼BFSçš„è§£é¢˜æ€è·¯è¯·è§åŠ¨å›¾ã€‚æ³¨æ„å¯¹ç§°æ˜¯å¯¹æ¯”å®Œä¸€åŠå†åˆ°å¦å¤–ä¸€åŠ</summary>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/binary_tree/101.å¯¹ç§°äºŒå‰æ ‘.gif" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
<pre><code>
<script type='text/html' style='display:block'>
  /**
  * Definition for a binary tree node.
  * struct TreeNode {
  *     int val;
  *     TreeNode *left;
  *     TreeNode *right;
  *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
  *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
  *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
  * };
  */
 class Solution {
 public:
     bool isSymmetric(TreeNode* root) {
 
         //BFSï¼ŒæŸ¥çœ‹ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªæ˜¯å¦ä¸€è‡´ã€‚ä½†æ˜¯é˜Ÿåˆ—ä¸å¥½å–ç´¢å¼•ï¼Œå› æ­¤å­˜çš„æ—¶å€™å°±å˜ç´¢å¼•
         // ï¼ˆæ³¨æ„å†™æ³•è™½ç„¶è·ŸBFSä¸€æ ·ï¼Œä½†æ˜¯å¹¶ä¸æ˜¯çœŸæ­£æ„ä¹‰çš„BFSï¼‰
         queue<TreeNode* > que;
  
         if(root!=nullptr)
         {
             que.push(root->left);
             que.push(root->right);
         }
 
         while(!que.empty())
         {
             // int cur_size=que.size();//å½“å‰å±‚çš„èŠ‚ç‚¹æ•°
 
             // for(int i=0;i<cur_size;i++)
             // {
                 TreeNode* left_of_pre_left=que.front();
                 que.pop();
                 TreeNode* right_of_pre_right=que.front();
                 que.pop();
 
                 //æ£€æŸ¥æ˜¯å¦å¯¹ç§°
                 if(left_of_pre_left==nullptr && right_of_pre_right==nullptr)//å·¦å³éƒ½ä¸ºç©ºï¼Œé‚£ä¹ˆæ˜¯å¯¹ç§°çš„
                     continue;//è·³è¿‡
                 
                 //è‹¥å·¦å³æœ‰ä¸€ä¸ªä¸ä¸ºç©ºï¼Œæˆ–è€…ä¸¤ä¸ªéƒ½ä¸ä¸ºç©ºä½†å€¼ä¸ç­‰ï¼Œé‚£ä¹ˆå°±ä¸æ˜¯å¯¹ç§°çš„
                 if(
                     left_of_pre_left==nullptr //æ­¤æ—¶å³å¿…ç„¶ä¸ºç©º
                  || right_of_pre_right==nullptr //æ­¤æ—¶å·¦å¿…ç„¶ä¸ºç©º
                  || (left_of_pre_left->val!=right_of_pre_right->val)
                 )
                     return false;
 
                 que.push(left_of_pre_left->left);
                 que.push(right_of_pre_right->right);
                 que.push(left_of_pre_left->right);
                 que.push(right_of_pre_right->left);
 
                 // if(cur->left!=nullptr)
                 //     que.push(cur->left);
                 // if(cur->right!=nullptr)
                 //     que.push(cur->right);
             // }
         }
 
         return true;
     }
 };
</script>
</code></pre>
</details> 
<details>
<summary>Click to expand the codeã€‚DFSçš„è§£æ³•ï¼Œæ³¨æ„åªæœ‰åœ¨å·¦å³ä¸åŒæ—¶ä¸º nullptr çš„æƒ…å†µä¸‹ï¼Œæ‰æ˜¯ä¸å¯¹ç§°çš„ã€‚ç”¨ != é€»è¾‘ç¬¦å·å¯èƒ½ä¼šå¯¼è‡´ç©ºèŠ‚ç‚¹æƒ…å†µåˆ¤æ–­é”™è¯¯</summary>
<pre><code>
<script type='text/html' style='display:block'>
  /**
  * Definition for a binary tree node.
  * struct TreeNode {
  *     int val;
  *     TreeNode *left;
  *     TreeNode *right;
  *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
  *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
  *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
  * };
  */
 class Solution {
 public:
     bool traverse(TreeNode* leftnode, TreeNode* rightnode)
     {
         //é€’å½’ç»ˆæ­¢æ¡ä»¶ï¼šè‹¥ä¸€ä¸ªä¸ºç©ºå¦ä¸€ä¸ªä¸æ˜¯ï¼Œæˆ–è€…ä¸¤ä¸ªå€¼ä¸ç­‰ï¼Œé‚£ä¹ˆå°±return false
         if(leftnode==nullptr && rightnode==nullptr)//ä¸¤ä¸ªéƒ½ä¸ºç©º
             return true;
         else if (leftnode==nullptr || rightnode==nullptr)//åªæœ‰ä¸€ä¸ªä¸ºç©ºï¼ˆæ³¨æ„ä¸æ˜¯åˆ¤æ–­æœ‰ä¸€ä¸ªéç©ºï¼Œåº”è¯¥æ˜¯åˆ¤æ–­æœ‰ä¸€ä¸ªä¸ºç©ºï¼‰
             return false;
         else if (leftnode->val!=rightnode->val)
             return false;
 
         //ç»§ç»­éå†
         bool temp1=traverse(leftnode->left, rightnode->right);
         bool temp2=traverse(leftnode->right,rightnode->left);
         
         //ååºçš„ä½ç½®
         return temp1 && temp2;
     }
     bool isSymmetric(TreeNode* root) {
         if (root!=nullptr)
             return traverse(root->left, root->right);
         else
             return true;//ç©ºèŠ‚ç‚¹è‡ªç„¶æ˜¯å¯¹ç§°çš„
     }
 };
</script>
</code></pre>
</details>

<p><br></p>
<h2>äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦</h2>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/binary_tree/å¾®ä¿¡æˆªå›¾_20240802203146.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
<details>
<summary>æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œå…¶ä¸­ n ä¸ºäºŒå‰æ ‘èŠ‚ç‚¹çš„ä¸ªæ•°ã€‚ç©ºé—´å¤æ‚åº¦ï¼šO(height)ï¼Œå…¶ä¸­ height è¡¨ç¤ºäºŒå‰æ ‘çš„é«˜åº¦ã€‚é€’å½’å‡½æ•°éœ€è¦æ ˆç©ºé—´ï¼Œè€Œæ ˆç©ºé—´å–å†³äºé€’å½’çš„æ·±åº¦ï¼Œ</summary>
<pre><code>
  /**
  * Definition for a binary tree node.
  * struct TreeNode {
  *     int val;
  *     TreeNode *left;
  *     TreeNode *right;
  *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
  *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
  *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
  * };
  */
 class Solution {
 public:
     int traverse(TreeNode* root)
     {
         if(root==nullptr)//åˆ°è¾¾è·ŸèŠ‚ç‚¹
             return 0;
         
         //å‰åºçš„ä½ç½®
         int left=traverse(root->left);//å·¦ä¾§çš„æ ‘çš„æ·±åº¦
         //ä¸­åºçš„ä½ç½®
         int right=traverse(root->right);//å³ä¾§çš„æ ‘çš„æ·±åº¦
         //ååºçš„ä½ç½®
         return max(left,right)+1;//// æ•´æ£µæ ‘çš„æœ€å¤§æ·±åº¦ç­‰äºå·¦å³å­æ ‘çš„æœ€å¤§æ·±åº¦å–æœ€å¤§å€¼ã€‚ç„¶åå†åŠ ä¸Šæ ¹èŠ‚ç‚¹è‡ªå·±

         //ä¸ºä»€ä¹ˆåœ¨ååºå‘¢ï¼Ÿ
         //è¦é¦–å…ˆåˆ©ç”¨é€’å½’å‡½æ•°çš„å®šä¹‰ç®—å‡ºå·¦å³å­æ ‘çš„æœ€å¤§æ·±åº¦ï¼Œ
         //ç„¶åæ¨å‡ºåŸæ ‘çš„æœ€å¤§æ·±åº¦ï¼Œä¸»è¦é€»è¾‘è‡ªç„¶æ”¾åœ¨ååºä½ç½®ã€‚
     }
     int maxDepth(TreeNode* root) {
         return  traverse(root);
     }
 };
</code></pre>
</details>

<details>
<summary>Click to expand the codeã€‚ä¸Šé¢æ˜¯DFSçš„è§£æ³•ï¼Œè‡³äºBFSçš„è§£æ³•å¦‚ä¸‹ï¼š</summary>
<pre><code>
<script type='text/html' style='display:block'>
  /**
  * Definition for a binary tree node.
  * struct TreeNode {
  *     int val;
  *     TreeNode *left;
  *     TreeNode *right;
  *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
  *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
  *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
  * };
  */
 class Solution {
 public:
     int maxDepth(TreeNode* root) {
         queue<TreeNode* >que;
 
         if(root!=nullptr)
             que.push(root);
         int max_depth=0;
         while(!que.empty())
         {
             int cur_size=que.size();
 
             max_depth++;//æ¯å±‚æ·±åº¦è‡ªåŠ 
             for(int i=0;i<cur_size;i++)//éå†å½“å‰å±‚
             {
                 TreeNode* cur=que.front();
                 que.pop();
 
                 //å…ˆå·¦åå³
                 if(cur->left!=nullptr)
                     que.push(cur->left);
                 if(cur->right!=nullptr)
                     que.push(cur->right);
             }
         }
 
         return max_depth;
     }
 };
</script>
</code></pre>
</details>

<p><br></p>
<h2>Nå‰æ ‘çš„æœ€å¤§æ·±åº¦</h2>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/binary_tree/WX20240920-103029.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
<details>
<summary>Click to expand the codeã€‚DFSå†™æ³•</summary>
<pre><code>
<script type='text/html' style='display:block'>
  /*
  // Definition for a Node.
  class Node {
  public:
      int val;
      vector<Node*> children;
  
      Node() {}
  
      Node(int _val) {
          val = _val;
      }
  
      Node(int _val, vector<Node*> _children) {
          val = _val;
          children = _children;
      }
  };
  */
  
  class Solution {
  public:
      int traverse(Node* root)
      {
          //é€’å½’ç»ˆæ­¢æ¡ä»¶
          if(root==nullptr)
              return 0;
          
          int maxdepth=0;
          for(auto each_root:root->children)
          {
              maxdepth=max(maxdepth,traverse(each_root));//æ¯ä¸ªè¿›è¡Œå¯¹æ¯”ï¼Œè·å–æœ€å¤§å€¼
          }
          //ååºä½ç½®
          return maxdepth+1;//æ³¨æ„åŠ ä¸€æ˜¯åŒ…å«å½“å‰çš„èŠ‚ç‚¹çš„
      }
  
      int maxDepth(Node* root) {
          return traverse(root);
      }
  };
</script>
</code></pre>
</details> 

<details>
<summary>Click to expand the codeã€‚BFSå†™æ³•</summary>
<pre><code>
<script type='text/html' style='display:block'>
  /*
  // Definition for a Node.
  class Node {
  public:
      int val;
      vector<Node*> children;
  
      Node() {}
  
      Node(int _val) {
          val = _val;
      }
  
      Node(int _val, vector<Node*> _children) {
          val = _val;
          children = _children;
      }
  };
  */
  
  class Solution {
  public:
      int maxDepth(Node* root) {
  
          queue<Node*> que;
  
          if(root!=nullptr)
              que.push(root);
  
          int maxdepth=0;
          while(!que.empty())
          {
              int cur_size=que.size();//å½“å‰å±‚çš„æ•°ç›®
              maxdepth++;//æœ‰ä¸€å±‚å°±åŠ 
              for(int i=0;i<cur_size;i++)
              {
                  Node* cur=que.front();
                  que.pop();
  
                  for(auto childernnode:cur->children)
                      que.push(childernnode);
              }
          }
  
          return maxdepth;
          
      }
  };
</script>
</code></pre>
</details> 

<p><br></p>
<h2>å®Œå…¨äºŒå‰æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°</h2>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/binary_tree/WX20240920-105819.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>
<details>
<summary>Click to expand the code.BFSè§£æ³•ã€‚æ—¶é—´å¤æ‚åº¦ï¼šO(n)ã€‚ç©ºé—´å¤æ‚åº¦ï¼šO(n)</summary>
<pre><code>
<script type='text/html' style='display:block'>
  /**
  * Definition for a binary tree node.
  * struct TreeNode {
  *     int val;
  *     TreeNode *left;
  *     TreeNode *right;
  *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
  *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
  *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
  * };
  */
 class Solution {
 public:
     int countNodes(TreeNode* root) {
         
         queue<TreeNode*> que;
   
         if(root!=nullptr)
             que.push(root);
 
         int num_node=0;
         while(!que.empty())
         {
             int cur_size=que.size();//å½“å‰å±‚çš„æ•°ç›®
             for(int i=0;i<cur_size;i++)
             {
                 TreeNode* cur=que.front();
                 que.pop();
                 num_node++;//èŠ‚ç‚¹æ•°è‡ªåŠ 
 
                 if(cur->left!=nullptr)
                     que.push(cur->left);
                 if(cur->right)
                     que.push(cur->right);
             }
         }
 
         return num_node;
     }
 };
</script>
</code></pre>
</details>
<details>
<summary>Click to expand the code.DFSè§£æ³•ã€‚æ—¶é—´å¤æ‚åº¦ï¼šO(n)ã€‚ç©ºé—´å¤æ‚åº¦ï¼šO(log n)ï¼Œç®—ä¸Šäº†é€’å½’ç³»ç»Ÿæ ˆå ç”¨çš„ç©ºé—´ï¼ˆæ³¨æ„å¹³è¡¡äºŒå‰æ ‘çš„ç©ºé—´å¤æ‚åº¦æ˜¯O(log n)ï¼Œæ™®é€šäºŒå‰æ ‘çš„ç©ºé—´å¤æ‚åº¦æ˜¯O(n)ï¼‰</summary>
<pre><code>
<script type='text/html' style='display:block'>
  /**
  * Definition for a binary tree node.
  * struct TreeNode {
  *     int val;
  *     TreeNode *left;
  *     TreeNode *right;
  *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
  *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
  *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
  * };
  */
 class Solution {
 public:
     int traverse(TreeNode* root)
      {
         if(root==nullptr)//åˆ°è¾¾è·ŸèŠ‚ç‚¹
             return 0;
          
          //å‰åºçš„ä½ç½®
          int left=traverse(root->left);//å·¦ä¾§çš„æ ‘çš„æ·±åº¦
          //ä¸­åºçš„ä½ç½®
          int right=traverse(root->right);//å³ä¾§çš„æ ‘çš„æ·±åº¦
          //ååºçš„ä½ç½®
          return left+right+1;//å·¦èŠ‚ç‚¹æ•°ç›®+å³èŠ‚ç‚¹æ•°ç›®+è‡ªå·±
      }
     int countNodes(TreeNode* root) {
         return traverse(root);
     }
 };
</script>
</code></pre>
</details>


<p><br></p>
<h2>åˆå¹¶äºŒå‰æ ‘</h2>
<div>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="../assets/img/binary_tree/å¾®ä¿¡æˆªå›¾_20240925204704.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>

<details>
<summary>Click to expand the codeã€‚DFSå‰åºéå†</summary>
<pre><code>
<script type='text/html' style='display:block'>
  /**
  * Definition for a binary tree node.
  * struct TreeNode {
  *     int val;
  *     TreeNode *left;
  *     TreeNode *right;
  *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
  *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
  *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
  * };
  */
 class Solution {
 public:
     TreeNode* traverse(TreeNode* root1, TreeNode* root2)
     {
         //é€’å½’ç»ˆæ­¢æ¡ä»¶
         if(root2==nullptr)
             return root1;
         else if(root1==nullptr)
             return root2;
         
         int cur_vale=root1->val+root2->val;
         TreeNode* root=new TreeNode(cur_vale);
 
         root->left=traverse(root1->left,root2->left);
         root->right=traverse(root1->right,root2->right);
 
         return root;
 
     }
     TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
         return traverse(root1,root2);
     }
 };
</script>
</code></pre>
</details>

<details>
<summary>Click to expand the codeã€‚é‡‡ç”¨BFSï¼Œå±‚åºéå†ã€‚æ³¨æ„ç”±äºqueä¸­pushäº†ä¸¤ä¸ªæ ‘ï¼Œæ•…æ­¤å½“å‰çš„æ•°ç›®åº”è¯¥è¦é™¤2</summary>
<pre><code>
<script type='text/html' style='display:block'>
  /**
  * Definition for a binary tree node.
  * struct TreeNode {
  *     int val;
  *     TreeNode *left;
  *     TreeNode *right;
  *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
  *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
  *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
  * };
  */
 class Solution {
 public:
     TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
 
         if(root2==nullptr)
             return root1;
         else if(root1==nullptr)
             return root2;
 
         //åˆå§‹åŒ–é˜Ÿåˆ—ï¼ˆå…ˆå…¥å…ˆå‡ºï¼‰
         std::queue<TreeNode*> que;
         que.push(root1);
         que.push(root2);
         
         while(!que.empty())
         {
             int cur_size=que.size();//å½“å‰å±‚çš„èŠ‚ç‚¹æ•°ç›®
             cur_size=cur_size/2;//æ³¨æ„åªæœ‰ä¸€åŠ!
 
             // éå†å½“å‰å±‚
             for(int i=0;i<cur_size;i++)
             {
                 TreeNode* cur1=que.front();//è·å–é˜Ÿåˆ—å¼€å¤´ï¼ˆå…ˆå…¥å…ˆå‡ºï¼‰
                 que.pop();//åˆ æ‰
 
                 TreeNode* cur2=que.front();
                 que.pop();//åˆ æ‰
 
                  // æ­¤æ—¶ä¸¤ä¸ªèŠ‚ç‚¹ä¸€å®šä¸ä¸ºç©ºï¼Œvalç›¸åŠ 
                 cur1->val=cur1->val+cur2->val;//ä¸¤ä¸ªå€¼ç›¸åŠ 
                 
                 //å½“å‰èŠ‚ç‚¹çš„å·¦å­èŠ‚ç‚¹ä¸å³å­èŠ‚ç‚¹æ”¾å…¥é˜Ÿåˆ—ä¸­ï¼Œä¸‹æ¬¡ç”¨(æ³¨æ„é¡ºåºæ˜¯å…ˆæ”¾å·¦åæ”¾å³)
                 if(cur1->left!=nullptr && cur2->left!=nullptr)//æ³¨æ„ä¸ä¸ºç©ºå†æ”¾
                 {
                     que.push(cur1->left);
                     que.push(cur2->left);
                 }
                 if(cur1->right!=nullptr && cur2->right!=nullptr)
                 {
                     que.push(cur1->right);
                     que.push(cur2->right);
                 }
 
                 //æ³¨æ„:ç”±äºè¿”å›çš„æ˜¯root1ï¼Œæ‰€ä»¥å¯¹äºroot2ä¸ºç©ºçš„éƒ¨åˆ†ä¸ç”¨ç®¡
                 // ä¸‹é¢åªå¤„ç†root1ä¸ºç©º,ä½†root2ä¸ä¸ºç©ºçš„æƒ…å†µ
                 if(cur1->left==nullptr && cur2->left!=nullptr)
                 {
                     cur1->left=cur2->left;//èŠ‚ç‚¹åœ°å€èµ‹äºˆ
                 }
                 if(cur1->right==nullptr && cur2->right!=nullptr)
                 {
                     cur1->right=cur2->right;
                 }
             }
         }
         return root1;
     }
 };
</script>
</code></pre>
</details>

</div>

<p><br></p>
<h2>äºŒå‰æœç´¢æ ‘ä¸­çš„æœç´¢</h2>
<div>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="../assets/img/binary_tree/å¾®ä¿¡æˆªå›¾_20240925213023.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>

<details>
<summary>Click to expand the codeã€‚DFSï¼Œåº”è¯¥æ˜¯ååºéå†ï¼Œåœ¨ååºçš„ä½ç½®å¤„ç†</summary>
<pre><code>
<script type='text/html' style='display:block'>
  /**
  * Definition for a binary tree node.
  * struct TreeNode {
  *     int val;
  *     TreeNode *left;
  *     TreeNode *right;
  *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
  *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
  *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
  * };
  */
 class Solution {
 public:
     TreeNode* traverse(TreeNode* root, int val)
     {
         if(root==nullptr)
             return root;
         if(root->val==val)
             return root;
         
         auto left=traverse(root->left,val);
         auto right=traverse(root->right,val);
 
         //è‹¥å·¦å³éƒ½æ˜¯ç©ºçš„,è¯æ˜æ²¡æœ‰
         if(left==nullptr && right==nullptr)
             return nullptr;
         else//æœ‰ä¸€ä¸ªä¸ä¸ºç©º,é‚£ä¹ˆå°±æ˜¯è¿”å›ä¸ä¸ºç©ºçš„é‚£ä¸ª
             return (left==nullptr)? right :left;//è¿”å›ä¸ä¸ºç©ºçš„é‚£ä¸ª
 
     }
     TreeNode* searchBST(TreeNode* root, int val) {
         return traverse(root,val);
     }
 };
</script>
</code></pre>
</details>

<details>
<summary>Click to expand the codeã€‚é‡‡ç”¨BFS</summary>
<pre><code>
<script type='text/html' style='display:block'>
  class Solution {
    public:
        TreeNode* searchBST(TreeNode* root, int target) {
    
            queue<TreeNode* > que;
    
            if(root!=nullptr)
                que.push(root);
    
            while(!que.empty())
            {
                int cur_size=que.size();//å½“å‰å±‚çš„èŠ‚ç‚¹æ•°
    
                for(int i=0;i<cur_size;i++)
                {
                    TreeNode* cur=que.front();
                    que.pop();
    
                    if(cur->val==target)
                        return cur;
    
                    if(cur->left!=nullptr)
                        que.push(cur->left);
                    if(cur->right!=nullptr)
                        que.push(cur->right);
                }
            }
    
            return nullptr;//å‰é¢æ²¡æœ‰returné‚£ä¹ˆå¿…ç„¶å°±æ˜¯æ²¡æ‰¾åˆ°,æ‰€ä»¥è¿”å›ç©º
    
        }
    };
</script>
</code></pre>
</details>

</div> 

</div>

<p><br></p>
<h1>å›æº¯ç®—æ³•è§£äºŒå‰æ ‘</h1>
<p>æ›´å¤šå…³äºå›æº¯ç®—æ³•çš„ä»‹ç»è¯·è§åšå®¢<sup><a href="../Poster/å›æº¯ç®—æ³•.html">Link</a></sup>
</p>
<div>
<p><br></p>
<h2>äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„</h2>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/binary_tree/WX20240920-123831.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>
<details>
<summary>Click to expand the codeï¼Œé‡‡ç”¨DFSå…¶å®ä¹Ÿå°±æ˜¯å›æº¯ç®—æ³•çš„æ€è·¯</summary>
<pre><code>
<script type='text/html' style='display:block'>
  /**
  * Definition for a binary tree node.
  * struct TreeNode {
  *     int val;
  *     TreeNode *left;
  *     TreeNode *right;
  *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
  *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
  *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
  * };
  */
 class Solution {
 public:
     void backtrack(TreeNode* root, string each_path, vector<string>& results)//æ³¨æ„stringåº”è¯¥æ˜¯ä¼ å€¼è€Œä¸æ˜¯åœ°å€
     {
         //å…ˆå†™å…¥å½“å‰ç»“æœ
         each_path+=to_string(root->val);
         if(root->left==nullptr && root->right==nullptr)//åˆ°è·ŸèŠ‚ç‚¹äº†
         {
             results.push_back(each_path);//å­˜ç»“æœ
             return;
         }
 
         //é€‰æ‹©åˆ—è¡¨:å·¦èŠ‚ç‚¹
         if(root->left!=nullptr)
         {
             //åšé€‰æ‹©
             each_path+="->";//å€¼åœ¨ä¸‹ä¸€è½®å­˜
             backtrack(root->left, each_path,results);
             //æ’¤é”€é€‰æ‹©
             each_path.pop_back(); // å›æº¯ '>'
             each_path.pop_back(); // å›æº¯ '-'
         }
 
         //é€‰æ‹©åˆ—è¡¨:å³èŠ‚ç‚¹
         if(root->right!=nullptr)
         {
             //åšé€‰æ‹©
             each_path+="->";//å€¼åœ¨ä¸‹ä¸€è½®å­˜
             backtrack(root->right, each_path,results);
             //æ’¤é”€é€‰æ‹©
             each_path.pop_back(); // å›æº¯ '>'
             each_path.pop_back(); // å›æº¯ '-'
         }
 
     }
     vector<string> binaryTreePaths(TreeNode* root) {
 
         //å›æº¯ç®—æ³•
         string each_path;
         vector<string> results;
         backtrack(root, each_path,results);
         return results;
     }
 };
</script>
</code></pre>
</details>

<p><br></p>
<h2>è·¯å¾„æ€»å’Œ</h2>
<div>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="../assets/img/binary_tree/å¾®ä¿¡æˆªå›¾_20240924090839.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>

<details>
<summary>Click to expand the codeã€‚DFS+å›æº¯ï¼Œæ³¨æ„å¯¹äºå›æº¯ç»ˆæ­¢çš„æ¡ä»¶ï¼šå¹¶ä¸æ˜¯åˆ¤æ–­rootæ˜¯å¦ä¸ºç©ºï¼Œè€Œæ˜¯åˆ¤æ–­rootçš„å­èŠ‚ç‚¹æ˜¯å¦ä¸ºç©º</summary>
<pre><code>
<script type='text/html' style='display:block'>
  /**
  * Definition for a binary tree node.
  * struct TreeNode {
  *     int val;
  *     TreeNode *left;
  *     TreeNode *right;
  *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
  *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
  *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
  * };
  */
 class Solution {
 public:
     bool backtrack(TreeNode* root, int each_patch, int targetSum) 
     {
         if(root->left==nullptr && root->right==nullptr)//åˆ°è¾¾æ ¹èŠ‚ç‚¹
         {
             if(each_patch==targetSum)//å‡‘åˆ°äº†ç›®æ ‡å€¼
                 return true;
             else
                 return false;
         }
 
 
         //é€‰æ‹©åˆ—è¡¨
         if(root->left!=nullptr)
         {
             //åšé€‰æ‹©
             each_patch+=root->left->val;
             if(backtrack(root->left, each_patch,targetSum))
                 return true;
             //æ’¤é”€é€‰æ‹©
             each_patch-=root->left->val;
         }
 
         if(root->right!=nullptr)
         {
             //åšé€‰æ‹©
             each_patch+=root->right->val;
             if(backtrack(root->right, each_patch,targetSum))
                 return true;
             //æ’¤é”€é€‰æ‹©
             each_patch-=root->right->val;
         }
 
         // ä¸¤è¾¹éƒ½è¯•è¿‡äº†ï¼Œä¸”éƒ½æ— trueè¿”å›ï¼Œé‚£ä¹ˆå°±æ˜¯false
         return false;
     }
     bool hasPathSum(TreeNode* root, int targetSum) {
 
         // DFS+å›æº¯ç®—æ³•
         if(root==nullptr)
             return false;//ç©ºçš„æ—¶å€™ä¸ºfalse
         int each_patch=root->val;//åˆå§‹åŒ–å€¼
         return backtrack(root, each_patch,targetSum);
     }
 };
</script>
</code></pre>
</details>

<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="../assets/img/binary_tree/å¾®ä¿¡æˆªå›¾_20240924093004.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 

<details>
<summary>Click to expand the codeã€‚è·Ÿä¸Šé¢é¢˜ç›®å‡ ä¹æ˜¯ä¸€æ ·çš„ã€‚ä½†æ˜¯æ³¨æ„åˆå§‹åŒ–çš„æ—¶å€™ä¸è¦æ¼äº†targetSumä¹Ÿè¦å‡</summary>
<pre><code>
<script type='text/html' style='display:block'>
  /**
  * Definition for a binary tree node.
  * struct TreeNode {
  *     int val;
  *     TreeNode *left;
  *     TreeNode *right;
  *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
  *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
  *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
  * };
  */
 class Solution {
 public:
     void backtrack(TreeNode* root, vector<int> each_patch, vector<vector<int>> &results, int targetSum) 
      {
          if(root->left==nullptr && root->right==nullptr)//åˆ°è¾¾æ ¹èŠ‚ç‚¹
          {
             if(targetSum==0)//å‡‘åˆ°äº†ç›®æ ‡å€¼(åˆšå¥½ä¸º0)
                 results.push_back(each_patch);
             return;
          }
  
  
          //é€‰æ‹©åˆ—è¡¨
          if(root->left!=nullptr)
          {
             //åšé€‰æ‹©
             targetSum-=root->left->val;
             each_patch.push_back(root->left->val);
             
             backtrack(root->left, each_patch,results, targetSum);
 
             //æ’¤é”€é€‰æ‹©
             targetSum+=root->left->val;
             each_patch.pop_back();
          }
  
         if(root->right!=nullptr)
         {
             //åšé€‰æ‹©
             targetSum-=root->right->val;
             each_patch.push_back(root->right->val);
             
             backtrack(root->right, each_patch,results, targetSum);
 
             //æ’¤é”€é€‰æ‹©
             targetSum+=root->right->val;
             each_patch.pop_back();
         }
  
      }
 
     vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
         // DFS+å›æº¯ç®—æ³•
 
         vector<int> each_patch;
         vector<vector<int>> results;
         if(root!=nullptr)
         {
             each_patch.push_back(root->val);
             targetSum-=root->val;//ä¸è¦æ¼äº†ï¼ï¼ï¼
             backtrack(root, each_patch,results, targetSum);
         }
 
         return results;
     }
 };
</script>
</code></pre>
</details>

</div>
</div>






<!-- æ ‡ç­¾å†…ä½¿ç”¨ &lt; å’Œ &gt; æ¥ä»£æ›¿ < å’Œ > -->
<!-- <details>
<summary>Click to expand the code</summary>
<pre><code>
<script type='text/html' style='display:block'>

</script>
</code></pre>
</details> -->

<!-- <p><br></p>
<h1></h1>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="../assets/img/binary_tree" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>  -->

<!-- ä¸€æ•´ä¸ªæ¨¡å— -->
<!-- <p><br></p>
<h1></h1>
<div>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="../assets/img/binary_tree" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>

<details>
<summary>Click to expand the code</summary>
<pre><code>
<script type='text/html' style='display:block'>

</script>
</code></pre>
</details>

</div> -->

<p><br></p>
<h1>å‚è€ƒèµ„æ–™</h1>
<ul>
  <li><a href="https://leetcode.cn/u/kwan-wai-pang/" target="_blank">My Leetcode</a></li>
  <li><a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/" target="_blank">labuladongäºŒå‰æ ‘</a>ï¼ˆPSï¼šæ„Ÿè§‰å†™å¾—ä¸æ˜¯å¾ˆå¥½ï¼Œæ€è·¯ä¸æ¸…æ™°ä¸”å¤§éƒ¨åˆ†è¦ä»˜è´¹ï¼‰ </li>
  <li><a href="https://www.programmercarl.com/" target="_blank">ä»£ç éšæƒ³å½•</a></li>
</ul>

</article>
</div>
</div>

<!-- Footer --> 
<p><br></p>   
<footer class="nofixed-bottom">
<div class="container mt-0" style="width:100%;text-align:center;">
  Please feel free to contact me through <a href="https://kwanwaipang.github.io/" target="_blank">my personal website</a>
</div>
</footer> 

    <!-- JavaScripts -->
    <!-- jQuery -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>

    <!-- Bootsrap & MDB scripts -->
  <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.2/dist/umd/popper.min.js" integrity="sha256-l/1pMF/+J4TThfgARS6KwWrk/egwuVvhRzfLAMQ6Ds4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.min.js" integrity="sha256-SyTu6CwrfOhaznYZPoolVw2rxoY7lKYKQvqbtqN93HI=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script>

    <!-- Masonry & imagesLoaded -->
  <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
  <script defer src="/ecmd/assets/js/masonry.js" type="text/javascript"></script>

  <!-- Medium Zoom JS -->
  <script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script>
  <script src="/ecmd/assets/js/zoom.js"></script><!-- Load Common JS -->
  <script src="/ecmd/assets/js/common.js"></script>

    <!-- MathJax -->
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        tags: 'ams'
      }
    };
  </script>
  <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
  <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>

   <!-- ä¸‹é¢æ˜¯æ’å…¥ç›®å½•çš„ -->
   <script>
    document.addEventListener("DOMContentLoaded", function() {
        const toc = document.querySelector("#toc ul");
        const headers = document.querySelectorAll(".post h1, .post h2, .post h3, .post h4, .post h5, .post h6");
        headers.forEach(header => {
            const li = document.createElement("li");
            const a = document.createElement("a");
            const id = header.textContent.replace(/\s+/g, "-").toLowerCase();
            header.setAttribute("id", id);
            a.setAttribute("href", `#${id}`);
            a.textContent = header.textContent;
            li.style.marginLeft = `${(parseInt(header.tagName.substring(1)) - 2) * 20}px`;
            li.appendChild(a);
            toc.appendChild(li);
        });
    });
</script>

 <!-- JavaScriptsæ·»åŠ æŒ‰é’® -->
 <script>
      // æ·»åŠ æŒ‰é’®ç‚¹å‡»äº‹ä»¶
      const button = document.getElementById("scrollToTocButton");
      button.addEventListener("click", function() {
          document.querySelector("#toc").scrollIntoView({ behavior: "smooth" });
      });
</script>

<!-- ç‚¹å‡»æŒ‰é’®å±•å¼€ç›®å½• -->
<script>
  // æ·»åŠ æ–°çš„ç›®å½•
  const newToc = document.querySelector("#newToc ul");
  const headers = document.querySelectorAll(".post h1, .post h2, .post h3, .post h4, .post h5, .post h6");
  
  headers.forEach(header => {
      const li = document.createElement("li");
      const a = document.createElement("a");
      const id = header.textContent.replace(/\s+/g, "-").toLowerCase();
      header.setAttribute("id", id);
      a.setAttribute("href", `#${id}`);
      a.textContent = header.textContent;
      li.style.marginLeft = `${(parseInt(header.tagName.substring(1)) - 2) * 20}px`;
      li.appendChild(a);
      newToc.appendChild(li);
  });

  // æ§åˆ¶æ–°çš„ç›®å½•çš„æ˜¾ç¤ºä¸éšè—
  const toggleButton = document.getElementById("toggleTocButton");
  toggleButton.addEventListener("click", function() {
      if (newToc.parentElement.style.display === "none") {
          newToc.parentElement.style.display = "block"; // å±•å¼€æ–°ç›®å½•
      } else {
          newToc.parentElement.style.display = "none"; // æ”¶èµ·æ–°ç›®å½•
      }
  });
</script>

</body>
</html>

