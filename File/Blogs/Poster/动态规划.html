<!DOCTYPE html>
<html lang="en">

<style>
    p { /* 文字对齐 */
        text-align: justify;
        text-align-last: left;
        text-justify: inter-word;
    }
    #toc {
      background: #f4f4f4;
      padding: 10px;
      /* border: 1px solid #ccc; */
      /* margin-bottom: 20px; */
      max-width: 100%; /* 限制目录框架的最大宽度 */
      word-wrap: break-word; /* 强制超长单词换行 */
      position: relative;
      margin-left: auto; /* 使目录框架在页面中居右 */
      margin-right: auto; /* 使目录框架在页面中居右 */
      box-sizing: border-box; /* 包含内边距和边框在内的宽度计算 */
  }
  }
  #toc ul {
      list-style-type: none;
      padding-left: 0; /* 去除默认的列表内边距 */
  }
  #toc ul ul {
      margin-left: 20px; /* 子目录项的缩进 */
  }
  </style>

<!-- Head -->
<head>    <!-- Metadata, OpenGraph and Schema.org -->


  <!-- Standard metadata -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Kwan Wai-Pang's Blog</title>
  <meta name="author" content="Kwan Wai-Pang " />
  <meta name="description" content="Personal Blog of Kwan Wai-Pang" />
  <meta name="keywords" content="Event-based Vision, SLAM, Robotics" />

  <!-- OpenGraph -->
  <meta property="og:site_name" content="My Technology Blog" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Kwan Wai-Pang | Personal Blog" />
  <meta property="og:description" content="Welcome to My Blog of Dynamic Programming 😊" />
  <meta property="og:image" content="https://kwanwaipang.github.io/Poster_files/hku_logo.jpg" />

  <meta property="og:locale" content="en" />

  <!-- Twitter card -->
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Home" />
  <meta name="twitter:description" content="Personal Blog of Kwan Wai-Pang" />

  <!-- Bootstrap & MDB -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous" />

  <!-- Fonts & Icons -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css2?family=Barriecito&family=Poppins:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700">

  <!-- Code Syntax Highlighting -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/PASTIE.css" media="none" id="highlight_theme_light" />

  <!-- Styles -->

  <link rel="shortcut icon" href="https://kwanwaipang.github.io/Poster_files/hku_logo.jpg"/>

  <!-- <link rel="stylesheet" href="https://kwanwaipang.github.io/File/Blogs/assets/css/main.css"> -->
  <!-- <link rel="stylesheet" href="https://kwanwaipang.github.io/File/Blogs/assets/css/fonts.css"> -->
  <link rel="stylesheet" href="../assets/css/main.css">
  <link rel="stylesheet" href="../assets/css/fonts.css">
  <link rel="stylesheet" href="../assets/new_css_js/cpp-highlight/styles/gradient-dark.css">
  <script src="../assets/new_css_js/cpp-highlight/highlight.js"></script>    <!--引入代码高亮js库-->

  <script>hljs.initHighlightingOnLoad();
  </script>

  <!-- Dark Mode -->


</head>

  <!-- Body -->
  <body class="fixed-top-nav ">

    <!-- Header -->
    <header>

      <!-- Nav Bar -->
      <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
        <div class="container">
          
          <!-- Navbar Toggle -->
          <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar top-bar"></span>
            <span class="icon-bar middle-bar"></span>
            <span class="icon-bar bottom-bar"></span>
          </button>

          <div class="collapse navbar-collapse text-right" id="navbarNav">
            <ul class="navbar-nav ml-auto flex-nowrap">
              <li class="nav-item ">
                <a class="nav-link" href="../My_Blog.html">Homepage</a>
              </li>

              <li class="nav-item ">
                <a class="nav-link" href="../Poster/cpp算法学习笔记.html">Learning Algorithm</a>
              </li>

            </ul>
          </div>
        </div>
      </nav>
    </header>

<header class="post-header">
  <h1 align="center" class="post-title">
    <span style="font-weight: 600;">动态规划算法</span>
  </h1>
</header>

<!-- Content -->
<div class="container mt-5">
<!-- home.html -->
<div class="post">

<!-- 插入目录 -->
<div id="toc">
  <h8>目录</h8>
  <ul></ul>
</div>

<article>
<!-- 插入博客内容-->
<p>
  之前做过不少动态规划方面的题目，但是都没有系统的整理，本博文系统整理下动态规划相关的知识。
  <br>
  动态规划算法（Dynamic Programming，简称 DP）.它将一个问题分解为一系列更小的子问题，并通过存储子问题的解来避免重复计算，从而大幅提升时间效率。
  <br>
  <strong>动态规划问题是从底到顶，而递归算法是从顶到底。</strong>
  <br>
  动态规划问题的一般形式就是求最值，而求最值的核心其实就是穷举,所谓的穷举就是定义好「状态转移方程」。
  <!-- 但是穷举所有可行解其实并不是一件容易的事，只有列出正确的「状态转移方程」,才能正确地穷举。  -->

</p>

<details>
<summary>动态规划算法的一些个人笔记：</summary>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 100%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/算法学习笔记cpp rnL _页面_1.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 100%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/算法学习笔记cpp rnL _页面_2.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 100%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/算法学习笔记cpp rnL _页面_3.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>  
</details>

<p><br></p>
<h1>爬楼梯</h1>
<p>首先通过经典的爬楼梯问题，导出其对应的动态规划解法</p>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 90%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/微信截图_20240802212746.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>
<details>
<summary>动态规划是一种“从底至顶”的方法：从最小子问题的解开始，迭代地构建更大子问题的解，直至得到原问题的解。</summary>
<pre><code>
/* 爬楼梯：动态规划 */
int climbingStairsDP(int n) {
  if (n == 1 || n == 2)
    return n;
  // step1: 初始化dp 表，用于存储子问题的解
  vector&ltint&gt dp(n + 1);
  // step1: 确定初始状态：预设最小子问题的解
  dp[1] = 1;
  dp[2] = 2;
  // step3:确定状态转移方程，进行状态转移：从较小子问题逐步求解较大子问题
  for (int i = 3; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];//状态转移方程
  }
  return dp[n];
}
</code></pre>
</details>
<p>
  根据上面的代码，可以简单总结出动态规划问题的解题思路：
  <ul>
    <li>step1:初始化dp表。将数组𝑑𝑝称为𝑑𝑝表，𝑑𝑝[𝑖] 表示状态 𝑖 对应子问题的解。</li>
    <li>step2:确定初始状态。将最小子问题对应的状态（第 1 阶和第 2 阶楼梯）称为初始状态。</li>
    <li>step3:构建状态转移方程。将递推公式 𝑑𝑝[𝑖] = 𝑑𝑝[𝑖 − 1] + 𝑑𝑝[𝑖 − 2] 称为状态转移方程。</li>
    </ul>
</p>
<p>上图仅仅是展示了动态规划的基本构建，但是一般来说，动态规划都是用来解决最优化问题的，因此进一步的，题目形如下面：
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/微信截图_20240802214008.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
前面的动态规划的状态转移方程为：
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/微信截图_20240802214129.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
而对于此处的最优化问题（带有代价函数的），则为：
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/微信截图_20240802214218.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 

从两个子问题最优解 𝑑𝑝[𝑖 − 1] 和 𝑑𝑝[𝑖 − 2] 中挑选出较优的那一个，并用它构建出原问题 𝑑𝑝[𝑖] 的最优解。也就是<strong>最优子结构</strong>.
<br>
</p>
<details>
  <summary>因此，这个带有最优子结构的动态规划问题应该如下代码所示：</summary>
<pre><code>
/* 爬楼梯最小代价：动态规划 */
int minCostClimbingStairsDP(vector&ltint&gt &cost) {

  int n = cost.size() - 1;

  if (n == 1 || n == 2)
    return cost[n];

  // 初始化 dp 表，用于存储子问题的解
  vector&ltint&gt dp(n + 1);

  // 初始状态：预设最小子问题的解
  dp[1] = cost[1];
  dp[2] = cost[2];

  // 状态转移：从较小子问题逐步求解较大子问题
  for (int i = 3; i &lt= n; i++) {
    dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];
  }

  return dp[n];
}
</code></pre>
</details> 
<p>
  若进一步的，对上面题目添加限制条件，如下：
  </p>
  <figure style="text-align: center;">
    <div style="margin-bottom: 10px;">
      <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/微信截图_20240802214847.png" alt="Image description">
    </div>
  <figcaption><p>
  </p></figcaption>
  </figure> 

<p>
  改问题中，下一步选择不能由当前状态（当前所在楼梯阶数）独立决定，还和前一个状态（上一轮所在楼梯阶数）有关。
  因此不满足<strong>无后效性</strong>，那么上面的状态转移方程就不适用了，
  <br>
  为此，扩展状态定义：状态 [𝑖, 𝑗] 表示处在第 𝑖 阶并且上一轮跳了 𝑗 阶，其中 𝑗 ∈ {1, 2} 。此状态定义有效地区分了上一轮跳了 1 阶还是 2 阶，我们可以据此判断当前状态是从何而来的。
</p>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/微信截图_20240802215149.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>  
<p>
  <ul>
    <li>当上一轮跳了 1 阶时，上上一轮只能选择跳 2 阶，即 𝑑𝑝[𝑖, 1] 只能从 𝑑𝑝[𝑖 − 1, 2] 转移过来。</li>
    <li>当上一轮跳了 2 阶时，上上一轮可选择跳 1 阶或跳 2 阶，即 𝑑𝑝[𝑖, 2] 可以从 𝑑𝑝[𝑖−2, 1] 或 𝑑𝑝[𝑖−2, 2]
  转移过来。</li>
  </ul>
</p>
<details>
<summary>代码如下：</summary>
<pre><code>
  /* 带约束爬楼梯：动态规划 */
  int climbingStairsConstraintDP(int n) {
    if (n == 1 || n == 2) {
    return 1;
    }
    // 初始化 dp 表，用于存储子问题的解
    vector&ltvector&ltint&gt&gt dp(n + 1, vector&ltint&gt(3, 0));
    // 初始状态：预设最小子问题的解
    dp[1][1] = 1;
    dp[1][2] = 0;
    dp[2][1] = 0;
    dp[2][2] = 1;
    // 状态转移：从较小子问题逐步求解较大子问题
    for (int i = 3; i &lt= n; i++) {
      dp[i][1] = dp[i - 1][2];
      dp[i][2] = dp[i - 2][1] + dp[i - 2][2];
    }
    return dp[n][1] + dp[n][2];//两者之和代表爬到第 𝑛 阶的方案总数
  }
</code></pre>
</details>

<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 60%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/微信截图_20240805214857.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 

<details>
<summary>Click to expand the code。时间复杂度O（N），空间复杂度为O（N）</summary>
<pre><code>
  class Solution {
    public:
        int climbStairs(int n) {
            // n个阶梯对应多少种方法(一共n+1个元素)，也就是状态dp
    
            if(n&lt3)//要大于等于3才适用于动态规划的问题～
                return n;
    
            // 时间复杂度O（N），空间复杂度为O（N）
    
            // step1：定义dp表
            int dp[n+1];//n个状态，对应n+1数组
    
            // step2：定义初始状态
            dp[0]=0;
            dp[1]=1;
            dp[2]=2;//一次性两级，或两次1级
    
            // step3：状态转移方程
            for(int i=3;i&ltn+1;i++)//注意数组是到n+1
            {
                //第n级。有n-1或n-2决定
                dp[i]=dp[i-1]+dp[i-2];//状态转移方程。
            }
    
            return dp[n];//最后返回第n阶梯的时候的解决方案
        }
    };
</code></pre>
</details>


<p><br></p>
<h1>走方格的方案数</h1>

<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 60%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/WX20240819-105641.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
<details>
<summary>Click to expand the code。最基本的动态规划问题～</summary>
<pre><code>
<script type='text/html' style='display:block'>
    #include <iostream>
    using namespace std;
    
    int main() {
        int n,m;
        cin>>n>>m;//n为横向的格子数，m为竖向的格子数
    
        // step1:定义dp表，走到第i和j个格子的走法
        int dp[n+1][m+1];
    
        //step2:初始化dp表，为0
        dp[0][0]=0;//走法为0,不用走
    
        for(int i=1;i<n+1;i++)
        {
            dp[i][0]=1;//从00到i0只有一种走法，就是一直往右
        }
    
        for(int j=1;j<m+1;j++)
        {
            dp[0][j]=1;//从00到0j只有一种走法，就是一直往下
        }
    
        // step3:进行状态转移
        for(int i=1;i<n+1;i++)
        {
            for(int j=1;j<m+1;j++)
            {
                dp[i][j]=dp[i-1][j]+dp[i][j-1];//只由这两种走法决定
            }
        }
    
        std::cout<<dp[n][m];
        
    }
    
</script>
</code></pre>
</details>

<p><br></p>
<h1>编辑距离</h1>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 60%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/微信截图_20240805215323.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
<details>
<summary>Click to expand the code。（此题中，注释相对比较规范化了动态规划问题的解题~）时间复杂度O（M*N），空间复杂度为O（M*N）</summary>
<pre><code>
  class Solution {
    public:
        int minDistance(string word1, string word2) {
            // 解法：动态规划
            // 步骤1：创建动态规划的数组，dp[i][j]代表第i-1和j-1个字符的对比
            int dp[word1.size()+1][word2.size()+1];
    
            // 步骤1：初始化数组：当某个数组为0，另一个操作数就等于另外一个的size
            for(int i=0;i&ltword1.size()+1;i++)
            {
                dp[i][0]=i;
            }
            for(int j=0;j&ltword2.size()+1;j++)
            {
                dp[0][j]=j;
            }
    
            // 步骤二：定义状态转移方程
            for(int i=1;i&ltword1.size()+1;i++)
            {
                for(int j=1;j&ltword2.size()+1;j++)
                {
                    if(word1[i-1]==word2[j-1])//如果两个字符相等,退化为dp【i-1】【j-1】（相当于什么都不做）
                        dp[i][j]=dp[i-1][j-1];
                    else //如果不相等：
                        //增加/插入新的值：可以理解为【i+1】与【j】一样了。那么就是退化为【i】与【j-1】对比了~
                        //删除i：就相当于用i的上一个状态了【i-1】与【j】对比
                        //替换：那么就相当于只用对比前一个状态了【i-1】与【j-1】对比
                        //(+1为本次操作数)
                        dp[i][j]=min(min(dp[i][j-1],dp[i-1][j]),dp[i-1][j-1])+1;
                }
            }
    
            return dp[word1.size()][word2.size()];
    
        }
    };
</code></pre>
</details>

<p><br></p>
<h1>字符串通配符</h1>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 60%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/WX20240818-104800.png" alt="Image description">
  </div> 
<figcaption><p>
</p></figcaption>
</figure>
<details>
<summary>Click to expand the code，跟字符串编辑距离很像</summary>
<pre><code>
<script type='text/html' style='display:block'>
    #include <cctype>
    #include <iostream>
    #include <algorithm>
    using namespace std;
    
    int main() {
        string str_1, str_2;
        cin>>str_1>>str_2;
        // 不区分大小写的匹配结果.先全部转换为小写
        // transform(str_1.begin(),str_1.end(),str_1.begin(),::tolower);
        // transform(str_2.begin(),str_2.end(),str_2.begin(),::tolower);
    
    
        // step1:创建dp表。str1中的第i个字符与第j个字符对比
        bool dp[str_1.size()+1][str_2.size()+1];
    
        //step2:初始化dp表，如果有一个为0，那么都不是通配
        dp[0][0]=true;
        for(int i=1;i<str_1.size()+1;i++)
        {
            if(str_1[i-1]=='*')//注意查看是否为*的情况
                dp[i][0]=dp[i-1][0];
            else
                dp[i][0]=false;
        }
        for(int j=1;j<str_2.size()+1;j++)
        {
            dp[0][j]=false;
        }
    
        // step3:进行自下而上的状态转移，推导状态转移方程
        for(int i=1;i<str_1.size()+1;i++)
        {
            for(int j=1;j<str_2.size()+1;j++)
            {
                // if(str_1[i-1]==str_2[j-1])//若两者相同
                if(tolower(str_1[i-1])==tolower(str_2[j-1]))//若两者小写相同（忽略大小写）
                {
                    dp[i][j]=dp[i-1][j-1];//那么就退化为上一个的对比
                }
                else//不等
                {
                    if(str_1[i-1]=='*'
                        && 
                        (
                        (str_2[j-1]>='0' && str_2[j-1]<='9') || (str_2[j-1]>='a' && str_2[j-1]<='z')
                            ))//匹配0个或以上的字符（注：能被*和?匹配的字符仅由英文字母和数字0到9组成，下同）
                    {
                        dp[i][j]=dp[i-1][j-1] || dp[i][j-1] || dp[i-1][j];
                    }
                    else if(str_1[i-1]=='?'
                    && 
                    (
                    (str_2[j-1]>='0' && str_2[j-1]<='9') || (str_2[j-1]>='a' && str_2[j-1]<='z')
                        ))//匹配1个字符
                    {
                        dp[i][j]=dp[i-1][j-1];//那么就退化为上一个的对比
                    }
                    else
                        dp[i][j]=false;//那么就直接是false了
                }
            }
        }
        if(dp[str_1.size()][str_2.size()])
            std::cout<<"true";
        else
            std::cout<<"false";
    }
    
</script>
</code></pre>
</details>


<p><br></p>
<h1>斐波那契数列</h1>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 60%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/微信截图_20240805220055.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
<details>
<summary>解法1：动态规划Click to expand the code。时间复杂度O（N），空间复杂度为O（N）</summary>
<pre><code>
  class Solution {
    public:
        int fib(int n) {
    
            //首先只有大于2才适用
            if(n&lt2)
                return n;
            
            //step1：定义dp表
            int dp[n+1]; //对应于状态n
    
            // step2：状态的初始化
            dp[0]=0;
            dp[1]=1;
    
            // step3:自下而上，推到状态方程
            for(int i=2;i&ltn+1;i++)
            {
                dp[i]=dp[i-1]+dp[i-2];//后面的每一项数字都是前面两项数字的和
            }
    
            return dp[n];
    
        }
    };
</code></pre>
</details>

<details>
<summary>用递归的思路解题也很简单。但是这个递归调用次数类似于计算一棵二叉树的节点数，树的高度为𝑛所以总的子树数目是O（2<sup>N</sup>），对应的时间复杂度为O（2<sup>N</sup>）。空间复杂度主要由递归调用的栈空间决定。每次递归调用都会占用一定的栈空间，递归的最大深度为𝑛，因此空间复杂度为：𝑂(N)</summary>
<pre><code>
  class Solution {
    public:
        int fib(int n) {
    
            //首先只有大于2才适用
            if(n&lt2)
                return n;
            
            return fib(n-1)+fib(n-2);
    
        }
    };
</code></pre>
</details>

<p>
  上面递归方法如果改为带有【备忘录】的写法，时间复杂度就会降低到O（N），所谓的备忘录写法其实就是对于每个结果都先记录着，如果这个结果被计算过了，就不重新计算，直接获值。也就是说动态规划其实就是相当于带有【备忘录】的递归。只是一个是自下而上，一个是自上而下。
  </p>
<details>
<summary>带有【备忘录】的递归</summary>
<pre><code>
<script type='text/html' style='display:block'>
  class Solution {
    public:
        // 带着备忘录进行递归
        int dp(vector<int> &memo, int n) {
            
            if (n == 0 || n == 1) 
                return n;//递归终止
    
            if (memo[n] != 0)  // 已经计算过，不用再计算了
                return memo[n];
                
            memo[n] = dp(memo, n - 1) + dp(memo, n - 2);
            return memo[n];
        }
        
        int fib(int n) {
    
            vector<int> memo(n+1,0);// 备忘录全初始化为 0

            // 进行带备忘录的递归
            return dp(memo, n);
    
        }    
    };
</script>
</code></pre>
</details>

<details>
<summary>对于上面解法1的动态规划解法。进一步的把空间复杂度降为 O(1)。当前状态 n 只和之前的 n-1, n-2 两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态</summary>
<pre><code>
  class Solution {
    public:
        int fib(int n) {
    
            //首先只有大于2才适用
            if(n&lt2)
                return n;
            
            //step1：定义dp表
            // int dp[n+1]; //对应于状态n
    
            // step2：状态的初始化
            // dp[0]=0;
            // dp[1]=1;
            int dp_i_2=0;
            int dp_i_1=1;
    
            // step3:自下而上，推到状态方程
            for(int i=2;i&ltn+1;i++)
            {
                // dp[i]=dp[i-1]+dp[i-2];//后面的每一项数字都是前面两项数字的和
                int dp_i=dp_i_1+dp_i_2;
    
                // 滚动更新
                dp_i_2=dp_i_1;
                dp_i_1=dp_i;
            }
    
            // return dp[n];
            return dp_i_1;
    
        }
    };
</code></pre>
</details>

<p><br></p>
<h1>零钱兑换</h1>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 60%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/微信截图_20240805222949.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
<p>
  此处引出动态规划问题中状态以及选择量的确定过程：
<br>
<strong>1、确定「状态」，也就是原问题和子问题中会变化的变量。</strong> 
由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case （凑够了目标金额，为0）靠近，所以唯一的「状态」就是目标金额 amount。
<br>
<strong>2、确定「选择」，也就是导致「状态」产生变化的行为。</strong>
目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是的「选择」。
<br>
<strong>3、明确 dp 数组的定义。</strong>
就本题来说，状态只有一个，即对应凑出目标金额所需的「最少硬币数量」。
</p>
<details>
<summary>Click to expand the code.此题的难点就是用什么作为状态，如何确定dp表。</summary>
<pre><code>
  class Solution {
    public:
        int coinChange(vector<int>& coins, int amount) {
    
            if(coins.size()==0)
                return -1;
    
            // // step!:确定状态，建立dp表。唯一可能的状态就是amount了
            // int dp[amount+1];//状态amount时,需要的最小的硬币的数量
            // // 注意初始化为amount + 1 ，因为凑成 amount 金额的硬币数最多只可能等于 amount（全用 1 元面值的硬币）
            // // 所以初始化为 amount + 1 就相当于初始化为正无穷
            vector&ltint&gt dp(amount + 1, amount + 1);//这个写法正确且简单
    
            // step2：确立初始状态
            dp[0]=0;
            // for(int i=1;i&ltamount+1;i++)
            // {
            //     dp[i]=amount+1;
            // }
    
            // step3: 确定状态转移方程
            for(int n=0; n&ltamount+1; n++)
            {
                for(int each_coin:coins)
                {
                    // 减去当前的面值小于0，那么当前面值不适用,跳过使用下一个试试
                    if(n-each_coin&lt0)
                    {
                        continue;
                    }
                    else//若当前面值可以用
                    {
                        //当前n的最小值由当前n(不选硬币)
                        // 以及
                        // 当前面值选择这个硬币，那么就是n减去each_coin的组成
                      dp[n]=min(dp[n],1+dp[n-each_coin]);
                    }
    
                }
            }
            return (dp[amount]==amount+1)? -1: dp[amount];
        }
    };
</code></pre>
</details>
<details>
<summary>下面可能更好理解</summary>
<pre><code>
<script type='text/html' style='display:block'>
  class Solution {
    public:
        int coinChange(vector<int>& coins, int amount) {
            
            // step1:定义dp表，代表对于需要的金额i，dp【i】状态为[最少的硬币个数]
            vector<int> dp(amount+1, 0);//当目标金额为 i 时，至少需要 dp[i] 枚硬币凑出
    
            // step2:确定初始状态，当总金额为0的时候，最小的硬币数量为0
            dp[0]=0;
    
            // step3：进行状态转移
            for(int i=1;i<amount+1;i++)//遍历所有状态的所有取值
            {
                dp[i]=amount+1;//每一轮对其进行初始化，初始化为每个面值为1元的硬币+1，那么就是最大的。也是全部的最大
                for(auto each_coin:coins)//选择对应的面值
                {
                    if(i-each_coin<0)//剪枝，当前硬币面值太大了
                        continue;
                    else
                        dp[i]=min(dp[i],dp[i-each_coin]+1);//不选这个面值，或者选这个面值，两种情况的最小
                }
            }
    
            if(dp[amount]==amount+1)//没有面值合适,故此没有发生变化～
                return -1;
            else
                return dp[amount];
        }
    };
</script>
</code></pre>
</details>

<p><br></p>
<h1>最长递增子序列</h1>

<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 60%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/微信截图_20240806204942.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 

<details>
<summary>Click to expand the code。用了两个for循环，时间复杂度为O（N<sup>2</sup>）,空间复杂度为O（N）也就是存储的dp表</summary>
<pre><code>
  class Solution {
    public:
        int lengthOfLIS(vector&ltint&gt& nums) {
    
            // step1：定义dp表。状态变量应该就是n=nums.size()了吧，也是唯一的变量
            int n=nums.size();
            int dp[n];
    
            // step2：确定初始状态
            for(int i=0; i&ltn;i++)
            {
                dp[i]=1;//自身，长度就是1了
            }
    
            // step3:状态转移方程
            // 对于状态dp[i]。以及在i前的状态j。
            // 若nums【i】&gtnums【j】.那么dp【i】为dp【i】（其他值）与dp【j】+1之间的最值
            int max_len=1;
            for(int i=0;i&ltn;i++)
            {
                for(int j=0;j&lti;j++)
                {
                    if(nums[i]&gtnums[j]) //注意nums只能访问到n-1
                        dp[i]=max(dp[i], dp[j]+1);//循环的其他j也参与了对比的。只是只记录最大值
                }
                max_len=max(max_len,dp[i]);//dp[i]为最大的
            }
    
            return max_len;//不能直接返回dp[n-1]，因为这是n-1位置时最大的，不是全部最大的~
        }
    };
</code></pre>
</details>
<p>
  通过本例可以发现。寻找动态规划的状态转移方程的通用技巧：数学归纳法！
  <br>
  所谓的数学归纳法其实就是。比如我们想证明一个数学结论，那么我们先假设这个结论在 k &lt n 时成立，然后根据这个假设，想办法推导证明出 k = n 的时候此结论也成立。如果能够证明出来，那么就说明这个结论对于 k 等于任何数都成立。
</p>
<details>
  <summary>Click to expand the code</summary>
  <pre><code>
  <script type='text/html' style='display:block'>
    class Solution {
      public:
          int lengthOfLIS(vector<int>& nums) {
      
              //step1:定义dp表:为dp[i]=对于以 nums[i] 这个数结尾的最长递增子序列的长度
              // 故此应该是dp大小是nums.size()而不是nums.size()+1
              vector<int> dp(nums.size(), 1);
              //step2:初始化dp表，为1，以 nums[i] 结尾的最长递增子序列起码要包含它自己，也就是自身长度1
      
              //step3:状态转移方程
              int max_len=0;
              for(int i=0;i<nums.size();i++)
              {
                  for(int j=0;j<i;j++)//由于不改变顺序，故此需要遍历的是i之前的
                  {//// 寻找 nums[0..i-1] 中比 nums[i] 小的元素
                      if(nums[i]>nums[j])//对于nums[j]<nums[i]的情况，子序列的长度肯定就是dp[j]+1
                          dp[i]=max(dp[i],dp[j]+1);//相当于把i之前的每一个都对比了～
                  }
                  if(dp[i]>max_len)
                      max_len=dp[i];
              }
      
              return max_len;
          }
      };
  </script>
  </code></pre>
</details> 

<p><br></p>
<h1>俄罗斯套娃信封问题</h1>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 60%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/微信截图_20240806214015.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
<details>
<summary>此题相当于上面题目的二维版本，但是需要对数组先进行排列。但是leetcode上下面代码运行会超时，只能通过85/87.时间复杂度为O（N<sup>2</sup>）,空间复杂度为O（N）</summary>
<pre><code>
  <script type='text/html' style='display:block'>
  class Solution {
    public:
        static bool comparefunction(vector<int>&a, vector<int>&b)//要设置为静态成员函数
        {
            if (a[0]!=b[0])
                return a[0]<b[0];
            else
                return a[1]<b[1];
        }
        int maxEnvelopes(vector<vector<int>>& envelopes) {
            
            //注意！需要先对envelopes进行排序
            sort(envelopes.begin(),envelopes.end(),comparefunction);
    
            //step1:定义dp表：dp[i]=对于信封envelopes【i】最多的组合个数
            vector<int> dp(envelopes.size(),1);
            // step2:初始化dp表，都为1，也就是自身
    
            // step3:状态转移
            int max_len=0;
            for(int i=0;i<envelopes.size();i++)//遍历每个信封
            {
                for(int j=0;j<i;j++)//选择i的前面进行对比
                {
                    //满足要求时
                    if(envelopes[i][0]>envelopes[j][0] && envelopes[i][1]>envelopes[j][1])
                        dp[i]=max(dp[i],dp[j]+1);
                }
                if(dp[i]>max_len)
                    max_len=dp[i];
            }
    
            return max_len;
        }
    };
  </script>
</code></pre>
</details>
<details>
<summary>Click to expand the code。二分法解题将复杂度降低为O（NlogN）这个方法还不是很熟悉～</summary>
<pre><code>
  <script type='text/html' style='display:block'>
  class Solution {
    public:
        static bool comparefunction(vector<int>& a, vector<int>& b) {
            if (a[0] == b[0])
                return a[1] > b[1];  // 宽度相同，高度降序排列
            return a[0] < b[0];  // 否则，宽度升序排列
        }
    
        int maxEnvelopes(vector<vector<int>>& envelopes) {
            // 对信封进行排序
            sort(envelopes.begin(), envelopes.end(), comparefunction);
    
            // 用于存储当前最长递增子序列的末尾元素
            vector<int> dp;
    
            for (auto& envelope : envelopes) {
                int height = envelope[1];
                // 使用二分查找找到第一个大于或等于当前高度的位置
                auto it = lower_bound(dp.begin(), dp.end(), height);
                if (it == dp.end()) {
                    dp.push_back(height);  // 如果没有找到，则添加到末尾
                } else {
                    *it = height;  // 如果找到了，则替换掉该位置的值
                }
            }
    
            return dp.size();  // dp的长度就是最长递增子序列的长度
        }
    };
  </script>
</code></pre>
</details>

<p><br></p>
<h1>超级动态规划问题：购物单</h1>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/WX20240813-090109.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
<details>
<summary>这道题其实就是在01背包问题的基础上，添加了各种约束。是的整体比较复杂。解题的关键点是：
  <br>1、每次只处理主件。如果是附件的话，状态等于上一次。
  <br>2、所谓的状态分为：不买、买主件、买主件+1个附件、买主件+2个附件。只有四个状态。而不买跟当前是附件的状态一样，都是继承上一个状态
  <br>3、在讨论买主件、主件+1附件、主件+2附件的时候，是依次递推满足的情况下再记录状态，不然会超时。</summary>
<pre><code>
<script type='text/html' style='display:block'>
  #include <iostream>
    #include <utility>  // 包含 pair 和 make_pair 的定义
    #include <vector>   // 包含 vector 的定义
    using namespace std;
    
    int main() {
        int N, m;
    
        cin >> N; //总的钱的数目
        cin >> m; //可购买物品的个数
    
        // int v, p, q;
        // v 表示该物品的价格， p 表示该物品的重要度（ 1 ~ 5 ）， q 表示该物品是主件还是附件。如果 q=0 ，表示该物品为主件，如果 q>0 ，表示该物品为附件，
        // vector< pair<int, pair<int, int>> > all_item(m+1);//要m+1个，因为下面的索引也是从1开始的
        // for (int i = 1; i < m+1; ++i) {
        //     cin >> v >> p >> q;
        //     all_item[i] = make_pair(v, make_pair(p, q));//保证了索引从1开始。因为下面也是从1开始的
        // }
        //all_item的size为m
        vector<int> v(m + 1), p(m + 1), q(m + 1);
        for (int i = 1; i <= m; ++i) {
            cin >> v[i] >> p[i] >> q[i];
        }
    
    
        //由于是求解最优子问题，采用动态规划
        // step1: 定义dp表,购买第m个物体时，此时预算为N的时候的最大满意度
        vector< vector<int>> dp(m + 1, vector<int> (N + 1, 0));
        //step2:初始化状态，当当前物品不买的时候，初始化为0
    
    
        //step3:进行自下而上的状态转移方程
        for (int i = 1; i < m + 1; i++) {
            //预算从N开始算。没花钱
            for (int j = N; j >= 0; j--) {
                // 先继承上一个状态
                dp[i][j] = dp[i - 1][j];
    
                //只考虑主件，非主件时不处理，相当于只继承之前的状态
                if (q[i] == 0) {
                    // 当前的状态为买了主件后的贡献量+上一个状态的贡献量
                    // vs
                    // 不买当前主件。上一状态的贡献量
                    if (j >= v[i]) 
                    { //若可以买
                        //买与不买之间的最大值。注意，当前如果买了，那么上一个状态可以花的额度就只有j - temp_v
                        dp[i][j] = max(dp[i - 1][j - v[i]] + v[i] * p[i]
                                       , dp[i - 1][j]);
                        //考虑主件+第一个1个附件
                        for (int k = 1; k < m + 1; k++) { //遍历all_item
                            if (q[k] == i && j >= v[i] + v[k]) 
                            { //当前主件的附件
                                dp[i][j] = max(dp[i - 1][j - v[i] - v[k]]
                                               + v[i] * p[i]
                                               + v[k] * p[k]
                                               , dp[i][j]);//注意对比的为当前的
    
                                int k1=k;//下面考虑买两个物品
                                for (int k2 = k1 + 1; k2 < m + 1; k2++) {
                                    if (
                                        q[k2] == i
                                        && j >= v[i] + v[k1] + v[k2]) 
                                    { //当前主件的附件
                                        dp[i][j] = max(dp[i - 1][j - v[i] - v[k1] - v[k2]] +
                                                    v[i] * p[i]
                                                    + v[k1] * p[k1]
                                                    + v[k2] * p[k2]
                                                    , dp[i][j]);//注意对比的为当前的
                                    }
                                }
                            }
                        }
    
                        // //考虑主件+2个附件
                        // for (int k1 = 1; k1 < m + 1; k1++) { //遍历all_item
                        //     for (int k2 = k1 + 1; k2 < m + 1; k2++) {
                        //         if (q[k1] == i
                        //                 && q[k2] == i
                        //                 && j >= v[i] + v[k1] + v[k2]) { //当前主件的附件
                        //             dp[i][j] = max(dp[i - 1][j - v[i] - v[k1] - v[k2]] +
                        //                            v[i] * p[i]
                        //                            + v[k1] * p[k1]
                        //                            + v[k2] * p[k2]
                        //                            , dp[i][j]);//注意对比的为当前的
                        //         }
                        //     }
                        // }
                    }
    
                }
    
            }
        }
        std::cout << dp[m][N];
    }
</script>
</code></pre>
</details>


<p><br></p>
<h1>合唱队：最长递增子序列与最长递减子序列的结合</h1>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/WX20240813-134758.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
<details>
<summary>Click to expand the code</summary>
<pre><code>
<script type='text/html' style='display:block'>
  #include <iostream>
  #include <vector>
  using namespace std;
  
  int main() {
      int N;//N位同学
      cin>>N;
  
      vector<int> height_group;
      int temp;
      while(cin>>temp)
      {
          height_group.push_back(temp);
      }
      // 中间从两边递减，因此可以理解为是从左到右：最长递增子序列。从右向左：最长递减子序列
  
      //step1:定义dp表。第N-1个同学，最长序列为dp【N-1】
      //step2:初始化状态为第0个同学，初始化为1,也就是自身的长度
      vector<int> dp1(N,1);
      
      // 从左到右：最长递增子序列
      // step3:状态转移方程
      //对于第i个同学，对比j同学（j为0～i）
      for(int i=0;i<N;i++)
      {
          for(int j=0;j<i;j++)
          {   
              //只要j小于i就参加对比。j大于i的就删除（不处理）
              if(height_group[i]>height_group[j])
                  dp1[i]=max(dp1[i],dp1[j]+1);
          }
      }//最终获得第i个同学，最长递增子序列
  
      // 从右向左：最长递减子序列
      //step1:定义dp表。第N-1个同学，最长序列为dp【N-1】
      //step2:初始化状态为第0个同学，初始化为1,也就是自身的长度
      vector<int> dp2(N,1);
      
      // step3:状态转移方程
      //对于第i个同学，对比j同学（j为0～i）
      for(int i=N-1;i>=0;i--)
      {
          for(int j=N-1;j>i;j--)
          {   
              //只要j大于i就参加对比。j小于于i的就删除（不处理）
              if(height_group[j]<height_group[i])//j在i的后面，j比i小，那么就是递减
                  dp2[i]=max(dp2[i],dp2[j]+1);
          }
      }//最终获得第i个同学，最长递减子序列
  
      //
      int maxLength = 0;
      //遍历这些同学
      for (int  i = 0; i < N; i++){
          //dp1[i]为第i个同学，从左到右的最长递增子序列
          //dp2[i] 为第i个同学，从i开始的最长递减子序列
          if (maxLength < dp1[i] + dp2[i] - 1)//i为分割点，因此需要-1
          {
              maxLength = dp1[i] + dp2[i] - 1;
              //这里的i就是划分中点
          }
      }
      std::cout << N - maxLength << endl;
      
  }
  
</script>
</code></pre>
</details>


<p><br></p>
<h1>最长回文子串  </h1>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 60%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/array/WX20240814-190830.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 

<details>
  <summary>动态规划解法，时间复杂度与空间复杂度都是O（N^2）。对于此类形的题目，定义的dp表应该为dp[j][i]：j代表了起点，i代表了终点。对比是否回文子串的过程就是dp[j][i]=(i++j && dp[j+1][i-1]).同时注意奇数与偶数的情况（aba与aa都是回文子串）</summary>
  <pre><code>
  <script type='text/html' style='display:block'>
      #include <iostream>
      #include <vector>
      using namespace std;
      
      int main() {
          //本质上就是求最长的回文子串。可以采用动态规划或者双指针法
      
          string input_str, result_str;
          getline(cin,input_str);
      
          //step1:定义dp表，对于起点为j终点为i的dp[j][i]是否为回文串
          // i，j为字符的索引
          //step2:初始化dp表：全部为false
          vector< vector <bool> > dp(input_str.size(), vector<bool> (input_str.size(),false));
      
          int max_len=0;
          // step3:状态转移方程
          for(int i=0;i<input_str.size();i++)
          {
              for(int j=0;j<=i;j++)
              {
                  if(i==j)//自身必然为回文子串。//对应aba的情况，基数位
                      dp[j][i]=true;//注意是j～i
                  else if(i==j+1)//对应偶数位，回文子串
                  {
                      dp[j][i]=(input_str[i]==input_str[j]);
                  }
                  else//其他情况
                      dp[j][i]= (input_str[i]==input_str[j]) && dp[j+1][i-1];//从小范围到大范围
      
                  if(dp[j][i]==true)//若当前为回文子串
                  {
                      if(i-j+1>max_len)
                          max_len=i-j+1;//如果是回文子串且长度大于记录值,则更新
                  }
              }
          }
      
          std::cout<<max_len<<std::endl;
      }
  </script>
  </code></pre>
</details>

<details>
  <summary>Click to expand the code。也可以采用双指针解法。时间复杂度是O（N^2）更上面一样的。但空间复杂度更小，为O（1）</summary>
  <pre><code>
  <script type='text/html' style='display:block'>
      #include <iostream>
      using namespace std;
      
      // 对于以left与right为中心的最长回文子串
      // 通过左右指针向两边扩散
      string function(string s, int left, int right)
      {
          //确保不越界以及相等
          while(left>=0 && right<s.size() &&s[left]==s[right])
          {
              left--;
              right++;
          }
          //若不等的话，会跳出来。所以应该是当前的left+1到right为目标结果
          return s.substr(left+1,right-(left+1));
      }
      
      int main() {
          //本质上就是求最长的回文子串。可以采用动态规划或者双指针法
      
          string input_str, result_str;
          getline(cin,input_str);
      
          for(int i=0;i<input_str.size();i++)
          {
              //以i为中心的，奇数字符串
              string s1=function(input_str,i,i);
              //以i为中心的，偶数字符串
              string s2=function(input_str,i,i+1);
      
              // 保存最长的
              result_str= result_str.size()>s1.size()? result_str:s1;
              result_str= result_str.size()>s2.size()? result_str:s2;
          }
      
          std::cout<<result_str.size();
      }
  </script>
  </code></pre>
</details>

<p><br></p>
<h1>公共子串计算</h1>

<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 60%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/WX20240818-113759.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
<details>
<summary>最简单直接了当的方法应该是从最长的序列开始递减计算</summary>
<pre><code>
<script type='text/html' style='display:block'>
    #include <iostream>
    using namespace std;
    
    int main() {
        string str_1, str_2;
        cin>>str_1>>str_2;
    
        if(str_1.size()>str_2.size())
            swap(str_1,str_2);//确保1为最短
    
        for(size_t len=str_1.size();len>=0;len--)
        {
            for(int i=0;i<=str_1.size()-len;i++)
            {
                string temp=str_1.substr(i,len);
                if(str_2.find(temp)!=string::npos)//找到了
                {
                    std::cout<<temp.size();
                    return 0;
                }
            }
        }
        std::cout<<"-1";
    }
</script>
</code></pre>
</details> 

<details>
<summary>这里也给出动态规划的解法</summary>
<pre><code>
<script type='text/html' style='display:block'>
    #include <iostream>
    using namespace std;
    
    int main() {
        string str_1, str_2;
        cin>>str_1>>str_2;
    
        //step1:定义dp表。dp【i】【j】为对比第i与j个字符，为公共子串的长度
        int dp[str_1.size()+1][str_2.size()+1];
    
        // step2:初始化状态
        dp[0][0]=0;
        for(int i=1;i<str_1.size()+1;i++)
            dp[i][0]=0;
        for(int j=1;j<str_2.size()+1;j++)
            dp[0][j]=0;
    
        int max_len=0;//多加个记录会简单很多～
        //进行状态转移
        for(int i=1;i<str_1.size()+1;i++)
        {
            for(int j=1;j<str_2.size()+1;j++)
            {
                if(str_1[i-1]==str_2[j-1])//相等
                {
                    dp[i][j]=dp[i-1][j-1]+1;
                }
                else {
                    dp[i][j]=0;//不等，那么最长的公共子串长度为0
                }
                if(dp[i][j]>max_len)
                    max_len=dp[i][j];
            }
        }
    
        std::cout<<max_len;
    }
</script>
</code></pre>
</details> 


<p><br></p>
<h1>Redraiment的走法</h1>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 60%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/WX20240820-100411.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
<details>
<summary>Click to expand the code</summary>
<pre><code>
<script type='text/html' style='display:block'>
    #include <iostream>
    #include <vector>
    using namespace std;
    
    int main() {
        int n;
        cin>>n;
        int temp;
        vector<int> group;
        while(cin>>temp)
        {
            group.push_back(temp);
        }
    
        //step1:确定dp表。dp[i]为对于第i阶，最多走多少步过来的
        int dp[n+1];
    
        // step2:初始化dp表：在每一轮里面初始化
    
        //step3:进行状态转移
        int max_step=0;
        for(int i=1;i<n+1;i++)
        {
            dp[i]=1;//每阶走了多少步都初始化为1，就是在当前阶不动，
    
            //由于涉及到了前面是怎么的情况，为此必须遍历i之前的对比计算
            for(int j=1;j<i;j++)//查看第j阶前面的情况
            {
                if(group[j-1]<group[i-1])//若小于i，那么就是可以从j走过来，故此+1
                {
                    dp[i]=max(dp[i],dp[j]+1);
                }//反之，不能从i走到j
                else
                    dp[i]=max(dp[i],1);//只能在当前格,不走
            }
            //一圈对比完后，判断最大值
            if(dp[i]>max_step)
            {
                max_step=dp[i];
            }
        }
    
        std::cout<<max_step;
    
    }
    
</script>
</code></pre>
</details>




<!-- 标签内使用 &lt; 和 &gt; 来代替 < 和 > -->
<!-- <details>
<summary>Click to expand the code</summary>
<pre><code>
<script type='text/html' style='display:block'>

</script>
</code></pre>
</details> -->

<!-- <p><br></p>
<h1></h1>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 60%;" src="../assets/img/dynamic_programming" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>  -->

<p><br></p>
<h1>参考资料</h1>
<ul>
  <li><a href="https://leetcode.cn/u/kwan-wai-pang/" target="_blank">My Leetcode</a></li>
  <li><a href="https://labuladong.online/algo/essential-technique/dynamic-programming-framework-2/" target="_blank">动态规划解题套路框架</a></li>
  <li><a href="https://www.bilibili.com/video/BV1XV411Y7oE/?vd_source=a88e426798937812a8ffc1a9be5a3cb7" target="_blank">动态规划问题的讲解视频</a></li>
  <li><a href="https://labuladong.online/algo/dynamic-programming/faq-summary/" target="_blank">最优子结构原理和 dp 数组遍历方向</a></li>
</ul>

</article>
</div>
</div>

<!-- Footer --> 
<p><br></p>   
<footer class="nofixed-bottom">
<div class="container mt-0" style="width:100%;text-align:center;">
  Please feel free to contact me through <a href="https://kwanwaipang.github.io/" target="_blank">my personal website</a>
</div>
</footer> 

    <!-- JavaScripts -->
    <!-- jQuery -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>

    <!-- Bootsrap & MDB scripts -->
  <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.2/dist/umd/popper.min.js" integrity="sha256-l/1pMF/+J4TThfgARS6KwWrk/egwuVvhRzfLAMQ6Ds4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.min.js" integrity="sha256-SyTu6CwrfOhaznYZPoolVw2rxoY7lKYKQvqbtqN93HI=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script>

    <!-- Masonry & imagesLoaded -->
  <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
  <script defer src="/ecmd/assets/js/masonry.js" type="text/javascript"></script>

  <!-- Medium Zoom JS -->
  <script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script>
  <script src="/ecmd/assets/js/zoom.js"></script><!-- Load Common JS -->
  <script src="/ecmd/assets/js/common.js"></script>

    <!-- MathJax -->
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        tags: 'ams'
      }
    };
  </script>
  <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
  <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>

  <!-- 下面是插入目录的 -->
  <script>
    document.addEventListener("DOMContentLoaded", function() {
        const toc = document.querySelector("#toc ul");
        const headers = document.querySelectorAll(".post h1, .post h2, .post h3, .post h4, .post h5, .post h6");
        headers.forEach(header => {
            const li = document.createElement("li");
            const a = document.createElement("a");
            const id = header.textContent.replace(/\s+/g, "-").toLowerCase();
            header.setAttribute("id", id);
            a.setAttribute("href", `#${id}`);
            a.textContent = header.textContent;
            li.style.marginLeft = `${(parseInt(header.tagName.substring(1)) - 2) * 20}px`;
            li.appendChild(a);
            toc.appendChild(li);
        });
    });
</script>

</body>
</html>

