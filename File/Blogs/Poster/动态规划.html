<!DOCTYPE html>
<html lang="en">

<style>
    p { /* 文字对齐 */
        text-align: justify;
        text-align-last: left;
        text-justify: inter-word;
    }
    #toc {
      background: #f4f4f4;
      padding: 10px;
      /* border: 1px solid #ccc; */
      /* margin-bottom: 20px; */
      max-width: 100%; /* 限制目录框架的最大宽度 */
      word-wrap: break-word; /* 强制超长单词换行 */
      position: relative;
      margin-left: auto; /* 使目录框架在页面中居右 */
      margin-right: auto; /* 使目录框架在页面中居右 */
      box-sizing: border-box; /* 包含内边距和边框在内的宽度计算 */
  }
  }
  #toc ul {
      list-style-type: none;
      padding-left: 0; /* 去除默认的列表内边距 */
  }
  #toc ul ul {
      margin-left: 20px; /* 子目录项的缩进 */
  }
  </style>

<!-- Head -->
<head>    <!-- Metadata, OpenGraph and Schema.org -->


  <!-- Standard metadata -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Kwan Wai-Pang's Blog</title>
  <meta name="author" content="Kwan Wai-Pang " />
  <meta name="description" content="Personal Blog of Kwan Wai-Pang" />
  <meta name="keywords" content="Event-based Vision, SLAM, Robotics" />

  <!-- OpenGraph -->
  <meta property="og:site_name" content="My Technology Blog" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Kwan Wai-Pang | Personal Blog" />
  <meta property="og:description" content="Welcome to My Blog of Dynamic Programming 😊" />
  <meta property="og:image" content="https://kwanwaipang.github.io/Poster_files/hku_logo.jpg" />

  <meta property="og:locale" content="en" />

  <!-- Twitter card -->
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Home" />
  <meta name="twitter:description" content="Personal Blog of Kwan Wai-Pang" />

  <!-- Bootstrap & MDB -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous" />

  <!-- Fonts & Icons -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css2?family=Barriecito&family=Poppins:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700">

  <!-- Code Syntax Highlighting -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/PASTIE.css" media="none" id="highlight_theme_light" />

  <!-- Styles -->

  <link rel="shortcut icon" href="https://kwanwaipang.github.io/Poster_files/hku_logo.jpg"/>

  <!-- <link rel="stylesheet" href="https://kwanwaipang.github.io/File/Blogs/assets/css/main.css"> -->
  <!-- <link rel="stylesheet" href="https://kwanwaipang.github.io/File/Blogs/assets/css/fonts.css"> -->
  <link rel="stylesheet" href="../assets/css/main.css">
  <link rel="stylesheet" href="../assets/css/fonts.css">
  <link rel="stylesheet" href="../assets/new_css_js/cpp-highlight/styles/gradient-dark.css">
  <script src="../assets/new_css_js/cpp-highlight/highlight.js"></script>    <!--引入代码高亮js库-->

  <script>hljs.initHighlightingOnLoad();
  </script>

  <!-- Dark Mode -->


</head>

  <!-- Body -->
  <body class="fixed-top-nav ">

    <!-- Header -->
    <header>

      <!-- Nav Bar -->
      <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
        <div class="container">
          
          <!-- Navbar Toggle -->
          <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar top-bar"></span>
            <span class="icon-bar middle-bar"></span>
            <span class="icon-bar bottom-bar"></span>
          </button>

          <div class="collapse navbar-collapse text-right" id="navbarNav">
            <ul class="navbar-nav ml-auto flex-nowrap">
              <li class="nav-item ">
                <a class="nav-link" href="../My_Blog.html">Homepage</a>
              </li>

              <li class="nav-item ">
                <a class="nav-link" href="../Poster/cpp算法学习笔记.html">Learning Algorithm</a>
              </li>

            </ul>
          </div>
        </div>
      </nav>
    </header>

<header class="post-header">
  <h1 align="center" class="post-title">
    <span style="font-weight: 600;">动态规划算法</span>
  </h1>
</header>

<!-- Content -->
<div class="container mt-5">
<!-- home.html -->
<div class="post">

<!-- 插入目录 -->
<div id="toc">
  <h8>目录</h8>
  <ul></ul>
</div>

<article>
<!-- 插入博客内容-->
<p>
  之前做过不少动态规划方面的题目，但是都没有系统的整理，本博文系统整理下动态规划相关的知识。
  <br>
  动态规划算法（Dynamic Programming，简称 DP）.它将一个问题分解为一系列更小的子问题，并通过存储子问题的解来避免重复计算，从而大幅提升时间效率。
  <br>
  <strong>动态规划问题是从底到顶，而递归算法是从顶到底。</strong>
  <br>
  动态规划问题的一般形式就是求最值，而求最值的核心其实就是穷举,所谓的穷举就是定义好「状态转移方程」。
  <!-- 但是穷举所有可行解其实并不是一件容易的事，只有列出正确的「状态转移方程」,才能正确地穷举。  -->

</p>

<details>
<summary>动态规划算法的一些个人笔记：</summary>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 100%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/算法学习笔记cpp rnL _页面_1.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 100%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/算法学习笔记cpp rnL _页面_2.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 100%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/算法学习笔记cpp rnL _页面_3.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>  
</details>

<p><br></p>
<h1>爬楼梯</h1>
<p>首先通过经典的爬楼梯问题，导出其对应的动态规划解法</p>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 90%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/微信截图_20240802212746.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>
<details>
<summary>动态规划是一种“从底至顶”的方法：从最小子问题的解开始，迭代地构建更大子问题的解，直至得到原问题的解。</summary>
<pre><code>
/* 爬楼梯：动态规划 */
int climbingStairsDP(int n) {
  if (n == 1 || n == 2)
    return n;
  // step1: 初始化dp 表，用于存储子问题的解
  vector&ltint&gt dp(n + 1);
  // step1: 确定初始状态：预设最小子问题的解
  dp[1] = 1;
  dp[2] = 2;
  // step3:确定状态转移方程，进行状态转移：从较小子问题逐步求解较大子问题
  for (int i = 3; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];//状态转移方程
  }
  return dp[n];
}
</code></pre>
</details>
<p>
  根据上面的代码，可以简单总结出动态规划问题的解题思路：
  <ul>
    <li>step1:初始化dp表。将数组𝑑𝑝称为𝑑𝑝表，𝑑𝑝[𝑖] 表示状态 𝑖 对应子问题的解。</li>
    <li>step2:确定初始状态。将最小子问题对应的状态（第 1 阶和第 2 阶楼梯）称为初始状态。</li>
    <li>step3:构建状态转移方程。将递推公式 𝑑𝑝[𝑖] = 𝑑𝑝[𝑖 − 1] + 𝑑𝑝[𝑖 − 2] 称为状态转移方程。</li>
    </ul>
</p>
<p>上图仅仅是展示了动态规划的基本构建，但是一般来说，动态规划都是用来解决最优化问题的，因此进一步的，题目形如下面：
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/微信截图_20240802214008.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
前面的动态规划的状态转移方程为：
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/微信截图_20240802214129.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
而对于此处的最优化问题（带有代价函数的），则为：
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/微信截图_20240802214218.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 

从两个子问题最优解 𝑑𝑝[𝑖 − 1] 和 𝑑𝑝[𝑖 − 2] 中挑选出较优的那一个，并用它构建出原问题 𝑑𝑝[𝑖] 的最优解。也就是<strong>最优子结构</strong>.
<br>
</p>
<details>
  <summary>因此，这个带有最优子结构的动态规划问题应该如下代码所示：</summary>
<pre><code>
/* 爬楼梯最小代价：动态规划 */
int minCostClimbingStairsDP(vector&ltint&gt &cost) {

  int n = cost.size() - 1;

  if (n == 1 || n == 2)
    return cost[n];

  // 初始化 dp 表，用于存储子问题的解
  vector&ltint&gt dp(n + 1);

  // 初始状态：预设最小子问题的解
  dp[1] = cost[1];
  dp[2] = cost[2];

  // 状态转移：从较小子问题逐步求解较大子问题
  for (int i = 3; i &lt= n; i++) {
    dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];
  }

  return dp[n];
}
</code></pre>
</details> 
<p>
  若进一步的，对上面题目添加限制条件，如下：
  </p>
  <figure style="text-align: center;">
    <div style="margin-bottom: 10px;">
      <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/微信截图_20240802214847.png" alt="Image description">
    </div>
  <figcaption><p>
  </p></figcaption>
  </figure> 

<p>
  改问题中，下一步选择不能由当前状态（当前所在楼梯阶数）独立决定，还和前一个状态（上一轮所在楼梯阶数）有关。
  因此不满足<strong>无后效性</strong>，那么上面的状态转移方程就不适用了，
  <br>
  为此，扩展状态定义：状态 [𝑖, 𝑗] 表示处在第 𝑖 阶并且上一轮跳了 𝑗 阶，其中 𝑗 ∈ {1, 2} 。此状态定义有效地区分了上一轮跳了 1 阶还是 2 阶，我们可以据此判断当前状态是从何而来的。
</p>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/微信截图_20240802215149.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>  
<p>
  <ul>
    <li>当上一轮跳了 1 阶时，上上一轮只能选择跳 2 阶，即 𝑑𝑝[𝑖, 1] 只能从 𝑑𝑝[𝑖 − 1, 2] 转移过来。</li>
    <li>当上一轮跳了 2 阶时，上上一轮可选择跳 1 阶或跳 2 阶，即 𝑑𝑝[𝑖, 2] 可以从 𝑑𝑝[𝑖−2, 1] 或 𝑑𝑝[𝑖−2, 2]
  转移过来。</li>
  </ul>
</p>
<details>
<summary>代码如下：</summary>
<pre><code>
  /* 带约束爬楼梯：动态规划 */
  int climbingStairsConstraintDP(int n) {
    if (n == 1 || n == 2) {
    return 1;
    }
    // 初始化 dp 表，用于存储子问题的解
    vector&ltvector&ltint&gt&gt dp(n + 1, vector&ltint&gt(3, 0));
    // 初始状态：预设最小子问题的解
    dp[1][1] = 1;
    dp[1][2] = 0;
    dp[2][1] = 0;
    dp[2][2] = 1;
    // 状态转移：从较小子问题逐步求解较大子问题
    for (int i = 3; i &lt= n; i++) {
      dp[i][1] = dp[i - 1][2];
      dp[i][2] = dp[i - 2][1] + dp[i - 2][2];
    }
    return dp[n][1] + dp[n][2];//两者之和代表爬到第 𝑛 阶的方案总数
  }
</code></pre>
</details>

<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 60%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/微信截图_20240805214857.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 

<details>
<summary>Click to expand the code。时间复杂度O（N），空间复杂度为O（N）</summary>
<pre><code>
  class Solution {
    public:
        int climbStairs(int n) {
            // n个阶梯对应多少种方法(一共n+1个元素)，也就是状态dp
    
            if(n&lt3)//要大于等于3才适用于动态规划的问题～
                return n;
    
            // 时间复杂度O（N），空间复杂度为O（N）
    
            // step1：定义dp表
            int dp[n+1];//n个状态，对应n+1数组
    
            // step2：定义初始状态
            dp[0]=0;
            dp[1]=1;
            dp[2]=2;//一次性两级，或两次1级
    
            // step3：状态转移方程
            for(int i=3;i&ltn+1;i++)//注意数组是到n+1
            {
                //第n级。有n-1或n-2决定
                dp[i]=dp[i-1]+dp[i-2];//状态转移方程。
            }
    
            return dp[n];//最后返回第n阶梯的时候的解决方案
        }
    };
</code></pre>
</details>

<details>
<summary>下面是等效的~</summary>
<pre><code>
<script type='text/html' style='display:block'>
  class Solution {
    public:
        int climbStairs(int n) {
    
            // step1:定义dp表：dp[i]=第i级时，一共的方案数
            // 状态：当前在第i阶
            // 选择：由上一阶或上两阶获取的
            int dp[n+1];
    
            // step2：初始化dp表
            dp[0]=1;
            dp[1]=1;
            
            // step3:进行状态转移
            for(int i=2;i<n+1;i++)
            {
                dp[i]=dp[i-1]+dp[i-2];
            }
    
            return dp[n];
    
        }
    };
</script>
</code></pre>
</details>


<p><br></p>
<h1>走方格的方案数</h1>

<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/WX20240819-105641.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
<details>
<summary>Click to expand the code。最基本的动态规划问题～</summary>
<pre><code>
<script type='text/html' style='display:block'>
    #include <iostream>
    using namespace std;
    
    int main() {
        int n,m;
        cin>>n>>m;//n为横向的格子数，m为竖向的格子数
        //注意是（0，1，2，。。。n）和（0，1，2，。。。m）一共是n+1和m+1个格子
    
        // step1:定义dp表，dp[i][j]:走到第i和j个格子的走法（注意是走法而不是一共走了多少格子）
        //状态：当前位于第i行第j列（注意从0开始）
        //选择：向右走或者向下走
        int dp[n+1][m+1];
    
        //step2:初始化dp表，为0
        dp[0][0]=0;//走法为0,不用走
    
        for(int i=1;i<n+1;i++)
        {
            dp[i][0]=1;//从00到i0只有一种走法，就是一直往右
        }
    
        for(int j=1;j<m+1;j++)
        {
            dp[0][j]=1;//从00到0j只有一种走法，就是一直往下
        }
    
        // step3:进行状态转移
        for(int i=1;i<n+1;i++)
        {
            for(int j=1;j<m+1;j++)
            {
                dp[i][j]=dp[i-1][j]+dp[i][j-1];//只由这两种走法决定
            }
        }
    
        std::cout<<dp[n][m];
        
    }
    
</script>
</code></pre>
</details>

<p><br></p>
<h1>编辑距离</h1>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 60%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/微信截图_20240805215323.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
<p>解决两个字符串的动态规划问题，一般都是用两个指针 i, j 分别指向两个字符串的最后，然后一步步往前移动，缩小问题的规模。</p>
<details>
<summary>Click to expand the code。（此题中，注释相对比较规范化了动态规划问题的解题~）时间复杂度O（M*N），空间复杂度为O（M*N）</summary>
<pre><code>
  <script type='text/html' style='display:block'>

  class Solution {
    public:
        int minDistance(string word1, string word2) {
            // 解法：动态规划
            // 步骤1：创建动态规划的数组，dp[i][j]代表第i-1和j-1个字符的对比的情况下，最短的编辑距离～
            int dp[word1.size()+1][word2.size()+1];
    
            // 步骤1：初始化数组：当某个数组为0，另一个操作数就等于另外一个的size
            for(int i=0;i<word1.size()+1;i++)
            {
                dp[i][0]=i;
            }
            for(int j=0;j<word2.size()+1;j++)
            {
                dp[0][j]=j;
            }
    
            // 步骤二：定义状态转移方程
            for(int i=1;i<word1.size()+1;i++)
            {
                for(int j=1;j<word2.size()+1;j++)
                {
                    if(word1[i-1]==word2[j-1])//如果两个字符相等,退化为dp【i-1】【j-1】（相当于什么都不做）
                        dp[i][j]=dp[i-1][j-1];
                    else //如果不相等：
                        //增加/插入新的值：可以理解为【i+1】与【j】一样了。那么就是退化为【i】与【j-1】对比了~
                        //删除i：就相当于用i的上一个状态了【i-1】与【j】对比
                        //替换：那么就相当于只用对比前一个状态了【i-1】与【j-1】对比
                        //注意不要漏了+1（为本次操作数)
                        dp[i][j]=min(min(dp[i][j-1],dp[i-1][j]),dp[i-1][j-1])+1;
                }
            }
    
            return dp[word1.size()][word2.size()];
    
        }
    };
  </script>
</code></pre>
</details>

<p><br></p>
<h1>字符串通配符</h1>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/WX20240818-104800.png" alt="Image description">
  </div> 
<figcaption><p>
</p></figcaption>
</figure>
<details>
<summary>Click to expand the code，跟字符串编辑距离很像，只是有了其他字符因此对初始化会有影响！</summary>
<pre><code>
<script type='text/html' style='display:block'>
    #include <cctype>
    #include <iostream>
    #include <algorithm>
    using namespace std;
    
    int main() {
        string str_1, str_2;
        cin>>str_1>>str_2;
        // 不区分大小写的匹配结果.先全部转换为小写
        // transform(str_1.begin(),str_1.end(),str_1.begin(),::tolower);
        // transform(str_2.begin(),str_2.end(),str_2.begin(),::tolower);
    
    
        // step1:创建dp表。str1中的第i个字符与第j个字符对比
        bool dp[str_1.size()+1][str_2.size()+1];
    
        //step2:初始化dp表，如果有一个为0，那么都不是通配
        dp[0][0]=true;
        for(int i=1;i<str_1.size()+1;i++)
        {
            if(str_1[i-1]=='*')//对于星号的情况不能全部为true，因为可能出现*A*的情况
                dp[i][0]=dp[i-1][0];
            else if(str_1[i-1]=='?')//匹配1个字符
              dp[i][0]=dp[i-1][0];
            else
                dp[i][0]=false;
        }
        //对于i=0的情况，可以通过初始化全部为false那就不用再初始化了
        for(int j=1;j<str_2.size()+1;j++)
        {
            dp[0][j]=false;
        }
    
        // step3:进行自下而上的状态转移，推导状态转移方程
        for(int i=1;i<str_1.size()+1;i++)
        {
            for(int j=1;j<str_2.size()+1;j++)
            {
                // if(str_1[i-1]==str_2[j-1])//若两者相同
                if(tolower(str_1[i-1])==tolower(str_2[j-1]))//若两者小写相同（忽略大小写）
                {
                    dp[i][j]=dp[i-1][j-1];//那么就退化为上一个的对比
                }
                else//不等
                {
                    if(str_1[i-1]=='*'
                        && 
                        (
                        (str_2[j-1]>='0' && str_2[j-1]<='9') || (str_2[j-1]>='a' && str_2[j-1]<='z')
                            ))//匹配0个或以上的字符（注：能被*和?匹配的字符仅由英文字母和数字0到9组成，下同）
                    {
                      //此处也并非有*就马上为true，反推初始化也不应该出现有*就为true
                        dp[i][j]=dp[i-1][j-1] || dp[i][j-1] || dp[i-1][j];
                    }
                    else if(str_1[i-1]=='?'
                    && 
                    (
                    (str_2[j-1]>='0' && str_2[j-1]<='9') || (str_2[j-1]>='a' && str_2[j-1]<='z')
                        ))//匹配1个字符
                    {
                        dp[i][j]=dp[i-1][j-1];//那么就退化为上一个的对比
                    }
                    else
                        dp[i][j]=false;//那么就直接是false了
                }
            }
        }
        if(dp[str_1.size()][str_2.size()])
            std::cout<<"true";
        else
            std::cout<<"false";
    }
    
</script>
</code></pre>
</details>


<p><br></p>
<h1>斐波那契数列</h1>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 70%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/微信截图_20240805220055.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
<details>
<summary>解法1：动态规划Click to expand the code。时间复杂度O（N），空间复杂度为O（N）</summary>
<pre><code>
  class Solution {
    public:
        int fib(int n) {
    
            //首先只有大于2才适用
            if(n&lt2)
                return n;
            
            //step1：定义dp表
            int dp[n+1]; //对应于状态n
    
            // step2：状态的初始化
            dp[0]=0;
            dp[1]=1;
    
            // step3:自下而上，推到状态方程
            for(int i=2;i&ltn+1;i++)
            {
                dp[i]=dp[i-1]+dp[i-2];//后面的每一项数字都是前面两项数字的和
            }
    
            return dp[n];
    
        }
    };
</code></pre>
</details>

<details>
<summary>用递归的思路解题也很简单。但是这个递归调用次数类似于计算一棵二叉树的节点数，树的高度为𝑛所以总的子树数目是O（2<sup>N</sup>），对应的时间复杂度为O（2<sup>N</sup>）。空间复杂度主要由递归调用的栈空间决定。每次递归调用都会占用一定的栈空间，递归的最大深度为𝑛，因此空间复杂度为：𝑂(N)</summary>
<pre><code>
  class Solution {
    public:
        int fib(int n) {
    
            //首先只有大于2才适用
            if(n&lt2)
                return n;
            
            return fib(n-1)+fib(n-2);
    
        }
    };
</code></pre>
</details>

<p>
  上面递归方法如果改为带有【备忘录】的写法，时间复杂度就会降低到O（N），所谓的备忘录写法其实就是对于每个结果都先记录着，如果这个结果被计算过了，就不重新计算，直接获值。也就是说动态规划其实就是相当于带有【备忘录】的递归。只是一个是自下而上，一个是自上而下。
  </p>
<details>
<summary>带有【备忘录】的递归</summary>
<pre><code>
<script type='text/html' style='display:block'>
  class Solution {
    public:
        // 带着备忘录进行递归
        int dp(vector<int> &memo, int n) {
            
            if (n == 0 || n == 1) 
                return n;//递归终止
    
            if (memo[n] != 0)  // 已经计算过，不用再计算了
                return memo[n];
                
            memo[n] = dp(memo, n - 1) + dp(memo, n - 2);
            return memo[n];
        }
        
        int fib(int n) {
    
            vector<int> memo(n+1,0);// 备忘录全初始化为 0

            // 进行带备忘录的递归
            return dp(memo, n);
    
        }    
    };
</script>
</code></pre>
</details>

<details>
<summary>对于上面解法1的动态规划解法。进一步的把空间复杂度降为 O(1)。当前状态 n 只和之前的 n-1, n-2 两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态</summary>
<pre><code>
  class Solution {
    public:
        int fib(int n) {
    
            //首先只有大于2才适用
            if(n&lt2)
                return n;
            
            //step1：定义dp表
            // int dp[n+1]; //对应于状态n
    
            // step2：状态的初始化
            // dp[0]=0;
            // dp[1]=1;
            int dp_i_2=0;
            int dp_i_1=1;
    
            // step3:自下而上，推到状态方程
            for(int i=2;i&ltn+1;i++)
            {
                // dp[i]=dp[i-1]+dp[i-2];//后面的每一项数字都是前面两项数字的和
                int dp_i=dp_i_1+dp_i_2;
    
                // 滚动更新
                dp_i_2=dp_i_1;
                dp_i_1=dp_i;
            }
    
            // return dp[n];
            return dp_i_1;
    
        }
    };
</code></pre>
</details>

<p><br></p>
<h1>零钱兑换</h1>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 60%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/微信截图_20240805222949.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
<p>
  此处引出动态规划问题中状态以及选择量的确定过程：
<br>
<strong>1、确定「状态」，也就是原问题和子问题中会变化的变量。</strong> 
由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case （凑够了目标金额，为0）靠近，所以唯一的「状态」就是目标金额 amount。
（ps：）
<br>
<strong>2、确定「选择」，也就是导致「状态」产生变化的行为。</strong>
目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是的「选择」。
<br>
<strong>3、明确 dp 数组的定义。</strong>
就本题来说，状态只有一个，即对应凑出目标金额所需的「最少硬币数量」。
</p>
<details>
<summary>Click to expand the code.此题的难点就是用什么作为状态，如何确定dp表。</summary>
<pre><code>
  <script type='text/html' style='display:block'>
  class Solution {
    public:
        int coinChange(vector<int>& coins, int amount) {
    
            if(coins.size()==0)
                return -1;
    
            // // step!:确定状态，建立dp表。唯一可能的状态就是amount了
            // int dp[amount+1];//状态amount时,需要的最小的硬币的数量
            // // 注意初始化为amount + 1 ，因为凑成 amount 金额的硬币数最多只可能等于 amount（全用 1 元面值的硬币）
            // // 所以初始化为 amount + 1 就相当于初始化为正无穷
            vector&ltint&gt dp(amount + 1, amount + 1);//这个写法正确且简单
    
            // step2：确立初始状态
            dp[0]=0;
            // for(int i=1;i&ltamount+1;i++)
            // {
            //     dp[i]=amount+1;
            // }
    
            // step3: 确定状态转移方程
            for(int n=0; n&ltamount+1; n++)
            {
                for(int each_coin:coins)
                {
                    // 减去当前的面值小于0，那么当前面值不适用,跳过使用下一个试试
                    if(n-each_coin&lt0)
                    {
                        continue;
                    }
                    else//若当前面值可以用
                    {
                        //当前n的最小值由当前n(不选硬币)
                        // 以及
                        // 当前面值选择这个硬币，那么就是n减去each_coin的组成
                      dp[n]=min(dp[n],1+dp[n-each_coin]);
                    }
    
                }
            }
            return (dp[amount]==amount+1)? -1: dp[amount];
        }
    };
  </script>
</code></pre>
</details>
<details>
<summary>下面可能更好理解</summary>
<pre><code>
<script type='text/html' style='display:block'>
  class Solution {
    public:
        int coinChange(vector<int>& coins, int amount) {
            
            // step1:定义dp表，代表对于需要的金额i，dp【i】状态为[最少的硬币个数]
            vector<int> dp(amount+1, 0);//当目标金额为 i 时，至少需要 dp[i] 枚硬币凑出
    
            // step2:确定初始状态，当总金额为0的时候，最小的硬币数量为0
            dp[0]=0;
    
            // step3：进行状态转移
            for(int i=1;i<amount+1;i++)//遍历所有状态的所有取值
            {
                dp[i]=amount+1;//每一轮对其进行初始化，初始化为每个面值为1元的硬币+1，那么就是最大的。也是全部的最大
                for(auto each_coin:coins)//选择对应的面值
                {
                    if(i-each_coin<0)//剪枝，当前硬币面值太大了
                        continue;
                    else
                        dp[i]=min(dp[i],dp[i-each_coin]+1);//不选这个面值，或者选这个面值，两种情况的最小
                }
            }
    
            if(dp[amount]==amount+1)//没有面值合适,故此没有发生变化～
                return -1;
            else
                return dp[amount];
        }
    };
</script>
</code></pre>
</details>

<p><br></p>
<h1>零钱兑换 II</h1>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 60%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/WX20240826-102658.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
<details>
<summary>Click to expand the code，题目跟上面很类似的，但此处不是求最优子问题，求解是总共有多少数目可以填满，可以转换为背包问题</summary>
<pre><code>
<script type='text/html' style='display:block'>
  class Solution {
    public:
        int change(int amount, vector<int>& coins) {
    
            //step1: 定义dp表：dp[i][j]为第i个硬币,当前的金额数为j,有多少种方法可以放满
            // 若只使用 coins 中的前 i 个（i 从 1 开始计数）硬币的面值，若想凑出金额 j，有 dp[i][j] 种凑法。
            // 状态：第i个硬币，现在的金额数
            // 选择：用或不用当前的硬币
            int dp[coins.size()+1][amount+1];
    
            // step2:初始化状态（base case最重要）
            for(int i=0;i<coins.size()+1;i++)
            {
                dp[i][0]=1;//对于目标金额为0，什么都不做就是一种做法，直接可以凑出
            }
    
            for(int j=1;j<amount+1;j++)
            {
                dp[0][j]=0;//没有金币了，但是面值不为0，那么肯定凑不出，就为0
            }
    
            // step3:进行状态转移
            for(int i=1;i<coins.size()+1;i++)
            {
                for(int j=1;j<amount+1;j++)
                {
                    if(j<coins[i-1])//那么就是不能选当前的硬币
                        dp[i][j]=dp[i-1][j];
                    else
                    {
                        //不放以及放，各一种做法，结果应该为两者之和.但是对于放了，你还可以从i个中选，因为金币的数量是无限的！
                        dp[i][j]=dp[i-1][j]+dp[i][j-coins[i-1]];
                    }
                }
            }
            
            return dp[coins.size()][amount];
    
        }
    };
</script>
</code></pre>
</details>

<details>
<summary>当然也可以不用背包问题的思路去解题！但是思路相对有点绕~</summary>
<pre><code>
<script type='text/html' style='display:block'>
  class Solution {
    public:
        int change(int amount, vector<int>& coins) {
    
            //不用背包问题的思路去解决~
    
            // step1:定义dp表：dp[i]=当前金额为i时，总的硬币组合方案
            // 状态：当前的金额，i，需要为amount+1
            //选择：用或不用第i个金币（有条件，必须要满足当前金额i大于这个金币的数值）
            vector<int> dp (amount+1,0);
    
            //step2：初始化dp
            dp[0]=1;//当金额为0的时候，方案数为1
            // 其余情况均初始化为0，组合方案为0（注意涉及到循环运算的时候需要预先给值）
    
            //step3 进行状态转移
            //每种金币都可以选
            for(auto each_coin:coins)
            {
                //首先对于这个面值的金币，i至少等于each_coin
                for(int i=each_coin;i<amount+1;i++)
                {
                    //故此，当前状态的数目等于上一次使用这个面值的金币在加一次这个面值
                    dp[i]+=dp[i-each_coin];
                    // 而由于统计一共的方法数目，因此需要把其他时候的也加入。这就意味着必须初始化dp[i]=0
                }
    
            }
    
            return dp[amount];
    
        }
    };
</script>
</code></pre>
</details>

<p><br></p>
<h1>最长递增子序列</h1>

<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 60%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/微信截图_20240806204942.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 

<details>
<summary>Click to expand the code。用了两个for循环，时间复杂度为O（N<sup>2</sup>）,空间复杂度为O（N）也就是存储的dp表</summary>
<pre><code>
  class Solution {
    public:
        int lengthOfLIS(vector&ltint&gt& nums) {
    
            // step1：定义dp表。状态变量应该就是n=nums.size()了吧，也是唯一的变量
            int n=nums.size();
            int dp[n];
    
            // step2：确定初始状态
            for(int i=0; i&ltn;i++)
            {
                dp[i]=1;//自身，长度就是1了
            }
    
            // step3:状态转移方程
            // 对于状态dp[i]。以及在i前的状态j。
            // 若nums【i】&gtnums【j】.那么dp【i】为dp【i】（其他值）与dp【j】+1之间的最值
            int max_len=1;
            for(int i=0;i&ltn;i++)
            {
                for(int j=0;j&lti;j++)
                {
                    if(nums[i]&gtnums[j]) //注意nums只能访问到n-1
                        dp[i]=max(dp[i], dp[j]+1);//循环的其他j也参与了对比的。只是只记录最大值
                }
                max_len=max(max_len,dp[i]);//dp[i]为最大的
            }
    
            return max_len;//不能直接返回dp[n-1]，因为这是n-1位置时最大的，不是全部最大的~
        }
    };
</code></pre>
</details>
<p>
  通过本例可以发现。寻找动态规划的状态转移方程的通用技巧：数学归纳法！
  <br>
  所谓的数学归纳法其实就是。比如我们想证明一个数学结论，那么我们先假设这个结论在 k &lt n 时成立，然后根据这个假设，想办法推导证明出 k = n 的时候此结论也成立。如果能够证明出来，那么就说明这个结论对于 k 等于任何数都成立。
</p>
<details>
  <summary>Click to expand the code</summary>
  <pre><code>
  <script type='text/html' style='display:block'>
    class Solution {
      public:
          int lengthOfLIS(vector<int>& nums) {
      
              //step1:定义dp表:为dp[i]=对于以 nums[i] 这个数结尾的最长递增子序列的长度
              // 故此应该是dp大小是nums.size()而不是nums.size()+1
              vector<int> dp(nums.size(), 1);
              //step2:初始化dp表，为1，以 nums[i] 结尾的最长递增子序列起码要包含它自己，也就是自身长度1
      
              //step3:状态转移方程
              int max_len=0;
              for(int i=0;i<nums.size();i++)
              {
                  for(int j=0;j<i;j++)//由于不改变顺序，故此需要遍历的是i之前的
                  {//// 寻找 nums[0..i-1] 中比 nums[i] 小的元素
                      if(nums[i]>nums[j])//对于nums[j]<nums[i]的情况，子序列的长度肯定就是dp[j]+1
                          dp[i]=max(dp[i],dp[j]+1);//相当于把i之前的每一个都对比了～
                  }
                  if(dp[i]>max_len)
                      max_len=dp[i];
              }
      
              return max_len;
          }
      };
  </script>
  </code></pre>
</details> 

<p><br></p>
<h1>俄罗斯套娃信封问题</h1>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 60%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/微信截图_20240806214015.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
<details>
<summary>此题相当于上面题目的二维版本，但是需要对数组先进行排列。但是leetcode上下面代码运行会超时，只能通过85/87.时间复杂度为O（N<sup>2</sup>）,空间复杂度为O（N）</summary>
<pre><code>
  <script type='text/html' style='display:block'>
  class Solution {
    public:
        static bool comparefunction(vector<int>&a, vector<int>&b)//要设置为静态成员函数
        {
            if (a[0]!=b[0])
                return a[0]<b[0];
            else
                return a[1]<b[1];
        }
        int maxEnvelopes(vector<vector<int>>& envelopes) {
            
            //注意！需要先对envelopes进行排序
            sort(envelopes.begin(),envelopes.end(),comparefunction);
    
            //step1:定义dp表：dp[i]=对于信封envelopes【i】最多的组合个数
            vector<int> dp(envelopes.size(),1);
            // step2:初始化dp表，都为1，也就是自身
    
            // step3:状态转移
            int max_len=0;
            for(int i=0;i<envelopes.size();i++)//遍历每个信封
            {
                for(int j=0;j<i;j++)//选择i的前面进行对比
                {
                    //满足要求时
                    if(envelopes[i][0]>envelopes[j][0] && envelopes[i][1]>envelopes[j][1])
                        dp[i]=max(dp[i],dp[j]+1);
                }
                if(dp[i]>max_len)
                    max_len=dp[i];
            }
    
            return max_len;
        }
    };
  </script>
</code></pre>
</details>
<details>
<summary>Click to expand the code。二分法解题将复杂度降低为O（NlogN）这个方法还不是很熟悉～</summary>
<pre><code>
  <script type='text/html' style='display:block'>
  class Solution {
    public:
        static bool comparefunction(vector<int>& a, vector<int>& b) {
            if (a[0] == b[0])
                return a[1] > b[1];  // 宽度相同，高度降序排列
            return a[0] < b[0];  // 否则，宽度升序排列
        }
    
        int maxEnvelopes(vector<vector<int>>& envelopes) {
            // 对信封进行排序
            sort(envelopes.begin(), envelopes.end(), comparefunction);
    
            // 用于存储当前最长递增子序列的末尾元素
            vector<int> dp;
    
            for (auto& envelope : envelopes) {
                int height = envelope[1];
                // 使用二分查找找到第一个大于或等于当前高度的位置
                auto it = lower_bound(dp.begin(), dp.end(), height);
                if (it == dp.end()) {
                    dp.push_back(height);  // 如果没有找到，则添加到末尾
                } else {
                    *it = height;  // 如果找到了，则替换掉该位置的值
                }
            }
    
            return dp.size();  // dp的长度就是最长递增子序列的长度
        }
    };
  </script>
</code></pre>
</details>

<p><br></p>
<h1>下降路径最小和</h1>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/WX20240825-143229.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
<details>
<summary>Click to expand the code。时间与空间复杂度都是O（N<sup>2</sup>）</summary>
<pre><code>
<script type='text/html' style='display:block'>
  class Solution {
    public:
        int minFallingPathSum(vector<vector<int>>& matrix) {
    
            //step1:定义dp表：dp【i】【j】=当前第i行与第j列时最小的路径和
            vector<vector<int>> dp(matrix.size(),vector<int>(matrix.size(),0));
    
            // step2:初始化dp表，实际上应该是位于当前网格的值的大小
            for(int j=0;j<matrix.size();j++)
            {
                dp[0][j]=matrix[0][j];//初始化第一行即可。
            }
    
            //step3:进行状态转移
            for(int i=1;i<matrix.size();i++)
            {
                for(int j=0;j<matrix.size();j++)//注意处理j边界的方式
                {
                    // 当前列正上方
                    int minAbove = dp[i-1][j];
    
                    if (j > 0) // 可以对比左上方元素
                        minAbove = min(minAbove, dp[i-1][j-1]);
                    
                    if (j < matrix.size() - 1) // 可以对比右上方元素
                        minAbove = min(minAbove, dp[i-1][j+1]);
                    
                    dp[i][j] = matrix[i][j] + minAbove;
                }
            }
    
            //最后再统计最后一行的最小值
            int min_value=INT_MAX;
            for(int j=0;j<matrix.size();j++)
            {
                if(dp[matrix.size()-1][j]<min_value)//最后一行
                    min_value=dp[matrix.size()-1][j];
            }
            return min_value;
        }
    };
</script>
</code></pre>
</details>


<p><br></p>
<h1>超级动态规划问题：购物单</h1>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/WX20240813-090109.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
<details>
<summary>这道题其实就是在01背包问题的基础上，添加了各种约束。是的整体比较复杂。解题的关键点是：
  <br>1、每次只处理主件。如果是附件的话，状态等于上一次。
  <br>2、所谓的状态分为：不买、买主件、买主件+1个附件、买主件+2个附件。只有四个状态。而不买跟当前是附件的状态一样，都是继承上一个状态
  <br>3、在讨论买主件、主件+1附件、主件+2附件的时候，是依次递推满足的情况下再记录状态，不然会超时。</summary>
<pre><code>
<script type='text/html' style='display:block'>
  #include <iostream>
    #include <utility>  // 包含 pair 和 make_pair 的定义
    #include <vector>   // 包含 vector 的定义
    using namespace std;
    
    int main() {
        int N, m;
    
        cin >> N; //总的钱的数目
        cin >> m; //可购买物品的个数
    
        // int v, p, q;
        // v 表示该物品的价格， p 表示该物品的重要度（ 1 ~ 5 ）， q 表示该物品是主件还是附件。如果 q=0 ，表示该物品为主件，如果 q>0 ，表示该物品为附件，
        // vector< pair<int, pair<int, int>> > all_item(m+1);//要m+1个，因为下面的索引也是从1开始的
        // for (int i = 1; i < m+1; ++i) {
        //     cin >> v >> p >> q;
        //     all_item[i] = make_pair(v, make_pair(p, q));//保证了索引从1开始。因为下面也是从1开始的
        // }
        //all_item的size为m
        vector<int> v(m + 1), p(m + 1), q(m + 1);
        for (int i = 1; i <= m; ++i) {
            cin >> v[i] >> p[i] >> q[i];
        }
    
    
        //由于是求解最优子问题，采用动态规划
        // step1: 定义dp表,购买第m个物体时，此时预算为N的时候的最大满意度
        vector< vector<int>> dp(m + 1, vector<int> (N + 1, 0));
        //step2:初始化状态，当当前物品不买的时候，初始化为0
    
    
        //step3:进行自下而上的状态转移方程
        for (int i = 1; i < m + 1; i++) {
            //预算从N开始算。没花钱
            for (int j = N; j >= 0; j--) {
                // 先继承上一个状态
                dp[i][j] = dp[i - 1][j];
    
                //只考虑主件，非主件时不处理，相当于只继承之前的状态
                if (q[i] == 0) {
                    // 当前的状态为买了主件后的贡献量+上一个状态的贡献量
                    // vs
                    // 不买当前主件。上一状态的贡献量
                    if (j >= v[i]) 
                    { //若可以买
                        //买与不买之间的最大值。注意，当前如果买了，那么上一个状态可以花的额度就只有j - temp_v
                        dp[i][j] = max(dp[i - 1][j - v[i]] + v[i] * p[i]
                                       , dp[i - 1][j]);
                        //考虑主件+第一个1个附件
                        for (int k = 1; k < m + 1; k++) { //遍历all_item
                            if (q[k] == i && j >= v[i] + v[k]) 
                            { //当前主件的附件
                                dp[i][j] = max(dp[i - 1][j - v[i] - v[k]]
                                               + v[i] * p[i]
                                               + v[k] * p[k]
                                               , dp[i][j]);//注意对比的为当前的
    
                                int k1=k;//下面考虑买两个物品
                                for (int k2 = k1 + 1; k2 < m + 1; k2++) {
                                    if (
                                        q[k2] == i
                                        && j >= v[i] + v[k1] + v[k2]) 
                                    { //当前主件的附件
                                        dp[i][j] = max(dp[i - 1][j - v[i] - v[k1] - v[k2]] +
                                                    v[i] * p[i]
                                                    + v[k1] * p[k1]
                                                    + v[k2] * p[k2]
                                                    , dp[i][j]);//注意对比的为当前的
                                    }
                                }
                            }
                        }
    
                        // //考虑主件+2个附件
                        // for (int k1 = 1; k1 < m + 1; k1++) { //遍历all_item
                        //     for (int k2 = k1 + 1; k2 < m + 1; k2++) {
                        //         if (q[k1] == i
                        //                 && q[k2] == i
                        //                 && j >= v[i] + v[k1] + v[k2]) { //当前主件的附件
                        //             dp[i][j] = max(dp[i - 1][j - v[i] - v[k1] - v[k2]] +
                        //                            v[i] * p[i]
                        //                            + v[k1] * p[k1]
                        //                            + v[k2] * p[k2]
                        //                            , dp[i][j]);//注意对比的为当前的
                        //         }
                        //     }
                        // }
                    }
    
                }
    
            }
        }
        std::cout << dp[m][N];
    }
</script>
</code></pre>
</details>


<p><br></p>
<h1>合唱队：最长递增子序列与最长递减子序列的结合</h1>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/WX20240813-134758.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
<details>
<summary>Click to expand the code</summary>
<pre><code>
<script type='text/html' style='display:block'>
  #include <iostream>
  #include <vector>
  using namespace std;
  
  int main() {
      int N;//N位同学
      cin>>N;
  
      vector<int> height_group;
      int temp;
      while(cin>>temp)
      {
          height_group.push_back(temp);
      }
      // 中间从两边递减，因此可以理解为是从左到右：最长递增子序列。从右向左：最长递减子序列
  
      //step1:定义dp表。第N-1个同学，最长序列为dp【N-1】
      //step2:初始化状态为第0个同学，初始化为1,也就是自身的长度
      vector<int> dp1(N,1);
      
      // 从左到右：最长递增子序列
      // step3:状态转移方程
      //对于第i个同学，对比j同学（j为0～i）
      for(int i=0;i<N;i++)
      {
          for(int j=0;j<i;j++)
          {   
              //只要j小于i就参加对比。j大于i的就删除（不处理）
              if(height_group[i]>height_group[j])
                  dp1[i]=max(dp1[i],dp1[j]+1);
          }
      }//最终获得第i个同学，最长递增子序列
  
      // 从右向左：最长递减子序列
      //step1:定义dp表。第N-1个同学，最长序列为dp【N-1】
      //step2:初始化状态为第0个同学，初始化为1,也就是自身的长度
      vector<int> dp2(N,1);
      
      // step3:状态转移方程
      //对于第i个同学，对比j同学（j为0～i）
      for(int i=N-1;i>=0;i--)
      {
          for(int j=N-1;j>i;j--)
          {   
              //只要j大于i就参加对比。j小于于i的就删除（不处理）
              if(height_group[j]<height_group[i])//j在i的后面，j比i小，那么就是递减
                  dp2[i]=max(dp2[i],dp2[j]+1);
          }
      }//最终获得第i个同学，最长递减子序列
  
      //
      int maxLength = 0;
      //遍历这些同学
      for (int  i = 0; i < N; i++){
          //dp1[i]为第i个同学，从左到右的最长递增子序列
          //dp2[i] 为第i个同学，从i开始的最长递减子序列
          if (maxLength < dp1[i] + dp2[i] - 1)//i为分割点，因此需要-1
          {
              maxLength = dp1[i] + dp2[i] - 1;
              //这里的i就是划分中点
          }
      }
      std::cout << N - maxLength << endl;
      
  }
  
</script>
</code></pre>
</details>


<p><br></p>
<h1>最长回文子串  </h1>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 60%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/array/WX20240814-190830.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 

<details>
  <summary>动态规划解法，时间复杂度与空间复杂度都是O（N^2）。对于此类形的题目，定义的dp表应该为dp[j][i]：j代表了起点，i代表了终点。对比是否回文子串的过程就是dp[j][i]=(i++j && dp[j+1][i-1]).同时注意奇数与偶数的情况（aba与aa都是回文子串）</summary>
  <pre><code>
  <script type='text/html' style='display:block'>
      #include <iostream>
      #include <vector>
      using namespace std;
      
      int main() {
          //本质上就是求最长的回文子串。可以采用动态规划或者双指针法
      
          string input_str, result_str;
          getline(cin,input_str);
      
          //step1:定义dp表，对于起点为j终点为i的dp[j][i]是否为回文串
          // i，j为字符的索引
          //step2:初始化dp表：全部为false
          vector< vector <bool> > dp(input_str.size(), vector<bool> (input_str.size(),false));
      
          int max_len=0;
          // step3:状态转移方程
          for(int i=0;i<input_str.size();i++)
          {
              for(int j=0;j<=i;j++)
              {
                  if(i==j)//自身必然为回文子串。//对应aba的情况，基数位
                      dp[j][i]=true;//注意是j～i
                  else if(i==j+1)//对应偶数位，回文子串
                  {
                      dp[j][i]=(input_str[i]==input_str[j]);
                  }
                  else//其他情况
                      dp[j][i]= (input_str[i]==input_str[j]) && dp[j+1][i-1];//从小范围到大范围
      
                  if(dp[j][i]==true)//若当前为回文子串
                  {
                      if(i-j+1>max_len)
                          max_len=i-j+1;//如果是回文子串且长度大于记录值,则更新
                  }
              }
          }
      
          std::cout<<max_len<<std::endl;
      }
  </script>
  </code></pre>
</details>

<details>
  <summary>Click to expand the code。也可以采用双指针解法。时间复杂度是O（N^2）更上面一样的。但空间复杂度更小，为O（1）</summary>
  <pre><code>
  <script type='text/html' style='display:block'>
      #include <iostream>
      using namespace std;
      
      // 对于以left与right为中心的最长回文子串
      // 通过左右指针向两边扩散
      string function(string s, int left, int right)
      {
          //确保不越界以及相等
          while(left>=0 && right<s.size() &&s[left]==s[right])
          {
              left--;
              right++;
          }
          //若不等的话，会跳出来。所以应该是当前的left+1到right为目标结果
          return s.substr(left+1,right-(left+1));
      }
      
      int main() {
          //本质上就是求最长的回文子串。可以采用动态规划或者双指针法
      
          string input_str, result_str;
          getline(cin,input_str);
      
          for(int i=0;i<input_str.size();i++)
          {
              //以i为中心的，奇数字符串
              string s1=function(input_str,i,i);
              //以i为中心的，偶数字符串
              string s2=function(input_str,i,i+1);
      
              // 保存最长的
              result_str= result_str.size()>s1.size()? result_str:s1;
              result_str= result_str.size()>s2.size()? result_str:s2;
          }
      
          std::cout<<result_str.size();
      }
  </script>
  </code></pre>
</details>

<p><br></p>
<h1>公共子串计算</h1>

<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 60%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/WX20240818-113759.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
<details>
<summary>最简单直接了当的方法应该是从最长的序列开始递减计算</summary>
<pre><code>
<script type='text/html' style='display:block'>
    #include <iostream>
    using namespace std;
    
    int main() {
        string str_1, str_2;
        cin>>str_1>>str_2;
    
        if(str_1.size()>str_2.size())
            swap(str_1,str_2);//确保1为最短
    
        for(size_t len=str_1.size();len>=0;len--)
        {
            for(int i=0;i<=str_1.size()-len;i++)
            {
                string temp=str_1.substr(i,len);
                if(str_2.find(temp)!=string::npos)//找到了
                {
                    std::cout<<temp.size();
                    return 0;
                }
            }
        }
        std::cout<<"-1";
    }
</script>
</code></pre>
</details> 

<details>
<summary>这里也给出动态规划的解法</summary>
<pre><code>
<script type='text/html' style='display:block'>
    #include <iostream>
    using namespace std;
    
    int main() {
        string str_1, str_2;
        cin>>str_1>>str_2;
    
        //step1:定义dp表。dp【i】【j】为对比第i与j个字符，为公共子串的长度
        int dp[str_1.size()+1][str_2.size()+1];
    
        // step2:初始化状态
        dp[0][0]=0;
        for(int i=1;i<str_1.size()+1;i++)
            dp[i][0]=0;
        for(int j=1;j<str_2.size()+1;j++)
            dp[0][j]=0;
    
        int max_len=0;//多加个记录会简单很多～
        //进行状态转移
        for(int i=1;i<str_1.size()+1;i++)
        {
            for(int j=1;j<str_2.size()+1;j++)
            {
                if(str_1[i-1]==str_2[j-1])//相等
                {
                    dp[i][j]=dp[i-1][j-1]+1;
                }
                else {
                    dp[i][j]=0;//不等，那么最长的公共子串长度为0
                }
                if(dp[i][j]>max_len)
                    max_len=dp[i][j];
            }
        }
    
        std::cout<<max_len;
    }
</script>
</code></pre>
</details> 


<p><br></p>
<h1>Redraiment的走法</h1>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 60%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/WX20240820-100411.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
<details>
<summary>Click to expand the code</summary>
<pre><code>
<script type='text/html' style='display:block'>
    #include <iostream>
    #include <vector>
    using namespace std;
    
    int main() {
        int n;
        cin>>n;
        int temp;
        vector<int> group;
        while(cin>>temp)
        {
            group.push_back(temp);
        }
    
        //step1:确定dp表。dp[i]为对于第i阶，最多走多少步过来的
        int dp[n+1];
    
        // step2:初始化dp表：在每一轮里面初始化
    
        //step3:进行状态转移
        int max_step=0;
        for(int i=1;i<n+1;i++)
        {
            dp[i]=1;//每阶走了多少步都初始化为1，就是在当前阶不动，
    
            //由于涉及到了前面是怎么的情况，为此必须遍历i之前的对比计算
            for(int j=1;j<i;j++)//查看第j阶前面的情况
            {
                if(group[j-1]<group[i-1])//若小于i，那么就是可以从j走过来，故此+1
                {
                    dp[i]=max(dp[i],dp[j]+1);
                }//反之，不能从i走到j
                else
                    dp[i]=max(dp[i],1);//只能在当前格,不走
            }
            //一圈对比完后，判断最大值
            if(dp[i]>max_step)
            {
                max_step=dp[i];
            }
        }
    
        std::cout<<max_step;
    
    }
    
</script>
</code></pre>
</details>


<p><br></p>
<h1>0-1背包问题</h1>
<p>
  题目：给你一个可装载重量为 W 的背包和 N 个物品，每个物品有重量和价值两个属性。其中第 i 个物品的重量为 wt[i]，价值为 val[i]。现在让你用这个背包装物品，每个物品只能用一次，在不超过被包容量的前提下，最多能装的价值是多少？
  </p>
<p>
  首先要明确两点，「状态」和「选择」。
  <li>对于状态，如何才能描述一个问题局面？只要给几个物品和一个背包的容量限制，就形成了一个背包问题呀。所以状态有两个，就是「背包的容量」和「可选择的物品」。</li>
  <li>对于选择，选择就是「装进背包」或者「不装进背包」。只有两种。</li>
  确定了状态与选择，那么基本主体的框架就出来了：
<pre><code>
  <script type='text/html' style='display:block'>
    for 状态1 in 状态1的所有取值：
      for 状态2 in 状态2的所有取值：
          for ...
              dp[状态1][状态2][...] = 择优(选择1，选择2...)
  </script>
  </code></pre>

  第一步需要明确dp数组的定义。
  上述状态定义为两个，一个二维的dp数组，dp[i][w] 的定义如下：对于前 i 个物品，当前背包的容量为 w，这种情况下可以装的最大价值是 dp[i][w]。
  <br>
  第二步需要确定初始的状态。那么就是<mark>dp[0][..] = dp[..][0] = 0</mark>，因为没有物品或者背包没有空间的时候，能装的最大价值就是 0。
  <br>
  第三步就是确定状态转移方程（其实也就是上面「首先」的时候完成的了）
  <li>dp[i][w] 表示：对于前 i 个物品（从 1 开始计数），当前背包的容量为 w 时，这种情况下可以装下的最大价值是 dp[i][w]</li>
  <li>如果没有把这第 i 个物品装入背包，那么很显然，最大价值 dp[i][w] 应该等于 dp[i-1][w]，继承之前的结果。</li>
  <li>如果把这第 i 个物品装入了背包，那么 dp[i][w] 应该等于 val[i-1] + dp[i-1][w - wt[i-1]]。 </li>
  ⚠️由于数组索引从 0 开始，而定义中的 i 是从 1 开始计数的，所以 val[i-1] 和 wt[i-1] 表示第 i 个物品的价值和重量。
<pre><code>
<script type='text/html' style='display:block'>
int knapsack(int W, int N, vector<int>& wt, vector<int>& val) {
  assert(N == wt.size());

  //step1:初始化dp表
  vector<vector<int>> dp(N + 1, vector<int>(W + 1));

  //step2:初始化状态（其实也就是上面初始化为0，为此不用操作）
  dp[0][..] = 0
  dp[..][0] = 0
  
  //step3:进行状态转移
  for (int i = 1; i <= N; i++) {
    for (int w = 1; w <= W; w++) {
        //注意是否有这种剪枝的情况
        if (w - wt[i - 1] < 0) {
            // 这种情况下只能选择不装入背包
            dp[i][w] = dp[i - 1][w];
        } else {
            // 装入或者不装入背包，择优
            dp[i][w] = max(
                dp[i - 1][w - wt[i-1]] + val[i-1], //把物品 i 装进背包
                dp[i - 1][w] //不把物品 i 装进背包
            );
        }
    }
}
  return dp[N][W]
</script>
</code></pre>
</p>

<p><br></p>
<h2>背包问题变体之子集分割/子集背包问题</h2>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 60%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/WX20240826-092925.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>
<details>
<summary>用递归的思路去解题不是不行，数组多了就会超出时间限制，当然也可以用回溯算法中的“划分为k个相等的子集”（还没尝试）</summary>
<pre><code>
<script type='text/html' style='display:block'>
  class Solution {
    public:
        bool callback(vector<int>& nums, int sum1, int smu2, int index)
        {
            // 递归终止条件
            if(index==nums.size())
                return sum1==smu2;
    
            return callback(nums,sum1+nums[index], smu2, index+1) || callback(nums,sum1, smu2+nums[index], index+1); 
        }
    
        bool canPartition(vector<int>& nums) {
    
            return callback(nums,0,0,0);
        }
    };
</script>
</code></pre>
</details> 

<details>
<summary>采用动态规划</summary>
<pre><code>
<script type='text/html' style='display:block'>
  class Solution {
    public:
        bool canPartition(vector<int>& nums) {
            
            int sum=0;
            for(auto num:nums)
                sum+=num;
            
            if(sum%2!=0)//若不能被2整除，那就直接false
                return false;// 和为奇数时，不可能划分成两个和相等的集合
            
            int target=sum/2;
    
            //step1: 定义dp表：dp【i】【j】=对于第i个物品，当前和值为j，若为true就是刚好分完，若为false就是还没分完
            // 状态：第i个数，j为当前存放的值和
            // 选择：第i个数选择放与不放
           bool dp[nums.size()+1][target+1];
    
           //step2:初始化状态方程
            // j==0相当于装满了，可以理解为true了，正好分配成功了   
           for(int i=0;i<nums.size()+1;i++)
           {
                dp[i][0]=true;
           }
    
           //i==0，那就是没有数据，但是j！=0那么就是没分完，但是没得分了，所以为false
           for(int j=1;j<target+1;j++)
           {
                dp[0][j]=false;
           }
    
            //step3:进行状态转移
            for(int i=1;i<nums.size()+1;i++)
            {
                for(int j=1;j<target+1;j++)
                {
                    if(j<nums[i-1])//那么就是当前数字不取，那么就是跟上一个状态一样
                        dp[i][j]=dp[i-1][j];
                    else
                    {
                        //取或者不取这个数字只要有一个为true都是true
                        dp[i][j]= dp[i-1][j-nums[i-1]] || dp[i-1][j];
                    }
                }
            }
    
            return dp[nums.size()][target];
    
        }
    };
</script>
</code></pre>
</details>

<p><br></p>
<h2>完全背包问题：零钱兑换 II</h2>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 60%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/WX20240826-102658.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
<details>
<summary>Click to expand the code，同样是背包问题，跟上面是很像的，只是状态转移不一样～</summary>
<pre><code>
<script type='text/html' style='display:block'>
  class Solution {
    public:
        int change(int amount, vector<int>& coins) {
    
            //step1: 定义dp表：dp[i][j]为第i个硬币,当前的金额数为j,有多少种方法可以放满
            // 若只使用 coins 中的前 i 个（i 从 1 开始计数）硬币的面值，若想凑出金额 j，有 dp[i][j] 种凑法。
            // 状态：第i个硬币，现在的金额数
            // 选择：用或不用当前的硬币
            int dp[coins.size()+1][amount+1];
    
            // step2:初始化状态（base case最重要）
            for(int i=0;i<coins.size()+1;i++)
            {
                dp[i][0]=1;//对于目标金额为0，什么都不做就是一种做法，直接可以凑出
            }
    
            for(int j=1;j<amount+1;j++)
            {
                dp[0][j]=0;//没有金币了，但是面值不为0，那么肯定凑不出，就为0
            }
    
            // step3:进行状态转移
            for(int i=1;i<coins.size()+1;i++)
            {
                for(int j=1;j<amount+1;j++)
                {
                    if(j<coins[i-1])//那么就是不能选当前的硬币
                        dp[i][j]=dp[i-1][j];
                    else
                    {
                        //不放以及放，各一种做法，结果应该为两者之和.但是对于放了，你还可以从i个中选，因为金币的数量是无限的！
                        dp[i][j]=dp[i-1][j]+dp[i][j-coins[i-1]];
                    }
                }
            }
            
            return dp[coins.size()][amount];
    
        }
    };
</script>
</code></pre>
</details>


<p><br></p>
<h1>最小路径和</h1>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 60%;" src="../assets/img/dynamic_programming/微信截图_20240826160245.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
<details>
<summary>Click to expand the code。dp表的初始化容易出错，对于第i行第j列的dp标索引应该从0开始，从1开始其实也可以只是对应处理更加复杂而已~</summary>
<pre><code>
<script type='text/html' style='display:block'>
  class Solution {
    public:
        int minPathSum(vector<vector<int>>& grid) {
    
            // step1：定义dp表，dp[i][j]表示当前位置的最小路径数值和
            // 状态：当前位于第i行第j列（注意从0开始）
            // 选择：（除了第一行和第一列外）向下或向右
            vector<vector<int>> dp(grid.size(), vector<int>(grid[0].size(),0));
            
            // step2:初始化dp表：i或j等于0的情况
            dp[0][0]=grid[0][0];
    
            // 注意！第一行和第一列仅仅有一种选择，而不是两种最小
            for(int i=1;i<grid.size();i++)
            {
                dp[i][0]=grid[i][0]+dp[i-1][0];
            }
    
            for(int j=1;j<grid[0].size();j++)
            {
                dp[0][j]=grid[0][j]+dp[0][j-1];
            }
    
    
            // step3：进行状态转移
            for(int i=1;i<grid.size();i++)
            {
                for(int j=1;j<grid[0].size();j++)
                {
                    //当前的值+(上一状态从上下来的或者从左过来的最小值)
                    dp[i][j]=grid[i][j]+min(dp[i-1][j],dp[i][j-1]);
                }
            }
    
            return dp[grid.size()-1][grid[0].size()-1];
    
        }
    };
</script>
</code></pre>
</details>

<p><br></p>
<h1>逆向思维动态规划：地下城游戏</h1>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 60%;" src="../assets/img/dynamic_programming/微信截图_20240826161711.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>

<details>
<summary>第一次解题的时候，想着把最小路径和改为最大路径和然后简单的对结果值进行修正希望达到最优。但实际上运行发现会选择运行28的结果。所以应该做到是损失最小，也就是负数之和最大，但是这个思路也不对，实际上就是同时考虑补充和扣减，与其如此，还不如换个思路，从右下角到左上角</summary>
<pre><code>
<script type='text/html' style='display:block'>
  class Solution {
    public:
        int calculateMinimumHP(vector<vector<int>>& dungeon) {
            // 反过来的思路，初始化血量为1，从右下角走到左上角
    
            // step1:定义dp表：dp[i][j]= 这个格子走到右下角所需要的最小生命值
            // 状态为第i行和第j列（从dungeon.size()-1与dungeon[0].size()-1开始索引）
            // 选择为： 向左 或 向上 移动一步
            vector<vector<int>> dp(dungeon.size()+1, vector<int>(dungeon[0].size()+1, INT_MAX));;
            
            // step2:初始化dp表为int的最大值，这样索引可以避免考虑最后一列和最后一行复杂的情况
            dp[dungeon.size()][dungeon[0].size()]=1;//到最后一格的时候刚好是一滴血
            dp[dungeon.size()-1][dungeon[0].size()]=1;
            dp[dungeon.size()][dungeon[0].size()-1]=1;
            
           for(int i=dungeon.size()-1;i>=0;i--)
           {
                for(int j=dungeon[0].size()-1;j>=0;j--)
                {
                    // 选择两个去向中较小的一个，也就是下一个时刻最小需要多少
                    int temp=min(dp[i+1][j],dp[i][j+1]);//可以保持从最小值从取，那么当前temp-dungeon[i][j]也是最小的情况。但是由于不能等于0，故此最小是1或者是temp-dungeon[i][j]
    
                    dp[i][j]=max(temp-dungeon[i][j],1);//要么保留1血量，要么就是当前剩余的
                    // 若dungeon[i][j]为负，那么当前应该是-dungeon[i][j]+temp，这样才可以保证能走到下一个
                    //  若dungeon[i][j]为正，那么当前只需要1就可以了，因为补充了
                }
           }
    
           return dp[0][0];
    
        }
    };
</script>
</code></pre>
</details>


<!-- 标签内使用 &lt; 和 &gt; 来代替 < 和 > -->
<!-- <details>
<summary>Click to expand the code</summary>
<pre><code>
<script type='text/html' style='display:block'>

</script>
</code></pre>
</details> -->

<!-- <p><br></p>
<h1></h1>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 60%;" src="../assets/img/dynamic_programming" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>  -->

<p><br></p>
<h1>参考资料</h1>
<ul>
  <li><a href="https://leetcode.cn/u/kwan-wai-pang/" target="_blank">My Leetcode</a></li>
  <li><a href="https://labuladong.online/algo/essential-technique/dynamic-programming-framework-2/" target="_blank">动态规划解题套路框架</a></li>
  <li><a href="https://www.bilibili.com/video/BV1XV411Y7oE/?vd_source=a88e426798937812a8ffc1a9be5a3cb7" target="_blank">动态规划问题的讲解视频</a></li>
  <li><a href="https://labuladong.online/algo/dynamic-programming/faq-summary/" target="_blank">最优子结构原理和 dp 数组遍历方向</a></li>
  <li><a href="https://labuladong.online/algo/dynamic-programming/knapsack1/" target="_blank">0-1背包问题</a></li>
</ul>

</article>
</div>
</div>

<!-- Footer --> 
<p><br></p>   
<footer class="nofixed-bottom">
<div class="container mt-0" style="width:100%;text-align:center;">
  Please feel free to contact me through <a href="https://kwanwaipang.github.io/" target="_blank">my personal website</a>
</div>
</footer> 

    <!-- JavaScripts -->
    <!-- jQuery -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>

    <!-- Bootsrap & MDB scripts -->
  <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.2/dist/umd/popper.min.js" integrity="sha256-l/1pMF/+J4TThfgARS6KwWrk/egwuVvhRzfLAMQ6Ds4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.min.js" integrity="sha256-SyTu6CwrfOhaznYZPoolVw2rxoY7lKYKQvqbtqN93HI=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script>

    <!-- Masonry & imagesLoaded -->
  <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
  <script defer src="/ecmd/assets/js/masonry.js" type="text/javascript"></script>

  <!-- Medium Zoom JS -->
  <script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script>
  <script src="/ecmd/assets/js/zoom.js"></script><!-- Load Common JS -->
  <script src="/ecmd/assets/js/common.js"></script>

    <!-- MathJax -->
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        tags: 'ams'
      }
    };
  </script>
  <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
  <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>

  <!-- 下面是插入目录的 -->
  <script>
    document.addEventListener("DOMContentLoaded", function() {
        const toc = document.querySelector("#toc ul");
        const headers = document.querySelectorAll(".post h1, .post h2, .post h3, .post h4, .post h5, .post h6");
        headers.forEach(header => {
            const li = document.createElement("li");
            const a = document.createElement("a");
            const id = header.textContent.replace(/\s+/g, "-").toLowerCase();
            header.setAttribute("id", id);
            a.setAttribute("href", `#${id}`);
            a.textContent = header.textContent;
            li.style.marginLeft = `${(parseInt(header.tagName.substring(1)) - 2) * 20}px`;
            li.appendChild(a);
            toc.appendChild(li);
        });
    });
</script>

</body>
</html>

