<!DOCTYPE html>
<html lang="en">

<style>
    p { /* 文字对齐 */
        text-align: justify;
        text-align-last: left;
        text-justify: inter-word;
    }
  </style>

<!-- Head -->
<head>    <!-- Metadata, OpenGraph and Schema.org -->


  <!-- Standard metadata -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Kwan Wai-Pang's Blog</title>
  <meta name="author" content="Kwan Wai-Pang " />
  <meta name="description" content="Personal Blog of Kwan Wai-Pang" />
  <meta name="keywords" content="Event-based Vision, SLAM, Robotics" />

  <!-- OpenGraph -->
  <meta property="og:site_name" content="My Technology Blog" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Kwan Wai-Pang | Personal Blog" />
  <meta property="og:description" content="Welcome to My Blog of Dynamic Programming 😊" />
  <meta property="og:image" content="https://kwanwaipang.github.io/Poster_files/hku_logo.jpg" />

  <meta property="og:locale" content="en" />

  <!-- Twitter card -->
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Home" />
  <meta name="twitter:description" content="Personal Blog of Kwan Wai-Pang" />

  <!-- Bootstrap & MDB -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous" />

  <!-- Fonts & Icons -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css2?family=Barriecito&family=Poppins:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700">

  <!-- Code Syntax Highlighting -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/PASTIE.css" media="none" id="highlight_theme_light" />

  <!-- Styles -->

  <link rel="shortcut icon" href="https://kwanwaipang.github.io/Poster_files/hku_logo.jpg"/>

  <!-- <link rel="stylesheet" href="https://kwanwaipang.github.io/File/Blogs/assets/css/main.css"> -->
  <!-- <link rel="stylesheet" href="https://kwanwaipang.github.io/File/Blogs/assets/css/fonts.css"> -->
  <link rel="stylesheet" href="../assets/css/main.css">
  <link rel="stylesheet" href="../assets/css/fonts.css">
  <link rel="stylesheet" href="../assets/new_css_js/cpp-highlight/styles/gradient-dark.css">
  <script src="../assets/new_css_js/cpp-highlight/highlight.js"></script>    <!--引入代码高亮js库-->

  <script>hljs.initHighlightingOnLoad();
  </script>

  <!-- Dark Mode -->


</head>

  <!-- Body -->
  <body class="fixed-top-nav ">

    <!-- Header -->
    <header>

      <!-- Nav Bar -->
      <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
        <div class="container">
          
          <!-- Navbar Toggle -->
          <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar top-bar"></span>
            <span class="icon-bar middle-bar"></span>
            <span class="icon-bar bottom-bar"></span>
          </button>

          <div class="collapse navbar-collapse text-right" id="navbarNav">
            <ul class="navbar-nav ml-auto flex-nowrap">
              <li class="nav-item ">
                <a class="nav-link" href="../My_Blog.html">Homepage</a>
              </li>

              <li class="nav-item ">
                <a class="nav-link" href="../Poster/cpp算法学习笔记.html">Learning Algorithm</a>
              </li>

            </ul>
          </div>
        </div>
      </nav>
    </header>

    <!-- Content -->
    <div class="container mt-5">
      <!-- home.html -->
      <div class="post">
        <header class="post-header">
          <h1 align="center" class="post-title">
           <span style="font-weight: 600;">动态规划算法</span>
          </h1>
        </header>
<article>
<!-- 插入博客内容-->
<p>
  之前做过不少动态规划方面的题目，但是都没有系统的整理，本博文系统整理下动态规划相关的知识。
  <br>
  动态规划算法（Dynamic Programming，简称 DP）.它将一个问题分解为一系列更小的子问题，并通过存储子问题的解来避免重复计算，从而大幅提升时间效率。
  <br>
  <strong>动态规划问题是从底到顶，而递归算法是从顶到底。</strong>
  <br>
  动态规划问题的一般形式就是求最值。
  <!-- 动态规划问题的一般形式就是求最值，而求最值的核心问题其实就是穷举。
  但是穷举所有可行解其实并不是一件容易的事，只有列出正确的「状态转移方程」,才能正确地穷举。 -->

</p>

<details>
<summary>动态规划算法的一些个人笔记：</summary>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 100%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/算法学习笔记cpp rnL _页面_1.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 100%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/算法学习笔记cpp rnL _页面_2.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 100%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/算法学习笔记cpp rnL _页面_3.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>  
</details>

<p><br></p>
<h1>1. 爬楼梯</h1>
<p>首先通过经典的爬楼梯问题，导出其对应的动态规划解法</p>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 90%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/微信截图_20240802212746.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>
<details>
<summary>动态规划是一种“从底至顶”的方法：从最小子问题的解开始，迭代地构建更大子问题的解，直至得到原问题的解。</summary>
<pre><code>
/* 爬楼梯：动态规划 */
int climbingStairsDP(int n) {
  if (n == 1 || n == 2)
    return n;
  // step1: 初始化dp 表，用于存储子问题的解
  vector&ltint&gt dp(n + 1);
  // step1: 确定初始状态：预设最小子问题的解
  dp[1] = 1;
  dp[2] = 2;
  // step3:确定状态转移方程，进行状态转移：从较小子问题逐步求解较大子问题
  for (int i = 3; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];//状态转移方程
  }
  return dp[n];
}
</code></pre>
</details>
<p>
  根据上面的代码，可以简单总结出动态规划问题的解题思路：
  <ul>
    <li>step1:初始化dp表。将数组𝑑𝑝称为𝑑𝑝表，𝑑𝑝[𝑖] 表示状态 𝑖 对应子问题的解。</li>
    <li>step2:确定初始状态。将最小子问题对应的状态（第 1 阶和第 2 阶楼梯）称为初始状态。</li>
    <li>step3:构建状态转移方程。将递推公式 𝑑𝑝[𝑖] = 𝑑𝑝[𝑖 − 1] + 𝑑𝑝[𝑖 − 2] 称为状态转移方程。</li>
    </ul>
</p>
<p>上图仅仅是展示了动态规划的基本构建，但是一般来说，动态规划都是用来解决最优化问题的，因此进一步的，题目形如下面：
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/微信截图_20240802214008.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
前面的动态规划的状态转移方程为：
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/微信截图_20240802214129.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
而对于此处的最优化问题（带有代价函数的），则为：
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/微信截图_20240802214218.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 

从两个子问题最优解 𝑑𝑝[𝑖 − 1] 和 𝑑𝑝[𝑖 − 2] 中挑选出较优的那一个，并用它构建出原问题 𝑑𝑝[𝑖] 的最优解。也就是<strong>最优子结构</strong>.
<br>
</p>
<details>
  <summary>因此，这个带有最优子结构的动态规划问题应该如下代码所示：</summary>
<pre><code>
/* 爬楼梯最小代价：动态规划 */
int minCostClimbingStairsDP(vector&ltint&gt &cost) {

  int n = cost.size() - 1;

  if (n == 1 || n == 2)
    return cost[n];

  // 初始化 dp 表，用于存储子问题的解
  vector&ltint&gt dp(n + 1);

  // 初始状态：预设最小子问题的解
  dp[1] = cost[1];
  dp[2] = cost[2];

  // 状态转移：从较小子问题逐步求解较大子问题
  for (int i = 3; i &lt= n; i++) {
    dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];
  }

  return dp[n];
}
</code></pre>
</details> 
<p>
  若进一步的，对上面题目添加限制条件，如下：
  </p>
  <figure style="text-align: center;">
    <div style="margin-bottom: 10px;">
      <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/微信截图_20240802214847.png" alt="Image description">
    </div>
  <figcaption><p>
  </p></figcaption>
  </figure> 

<p>
  改问题中，下一步选择不能由当前状态（当前所在楼梯阶数）独立决定，还和前一个状态（上一轮所在楼梯阶数）有关。
  因此不满足<strong>无后效性</strong>，那么上面的状态转移方程就不适用了，
  <br>
  为此，扩展状态定义：状态 [𝑖, 𝑗] 表示处在第 𝑖 阶并且上一轮跳了 𝑗 阶，其中 𝑗 ∈ {1, 2} 。此状态定义有效地区分了上一轮跳了 1 阶还是 2 阶，我们可以据此判断当前状态是从何而来的。
</p>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 80%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/微信截图_20240802215149.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>  
<p>
  <ul>
    <li>当上一轮跳了 1 阶时，上上一轮只能选择跳 2 阶，即 𝑑𝑝[𝑖, 1] 只能从 𝑑𝑝[𝑖 − 1, 2] 转移过来。</li>
    <li>当上一轮跳了 2 阶时，上上一轮可选择跳 1 阶或跳 2 阶，即 𝑑𝑝[𝑖, 2] 可以从 𝑑𝑝[𝑖−2, 1] 或 𝑑𝑝[𝑖−2, 2]
  转移过来。</li>
  </ul>
</p>
<details>
<summary>代码如下：</summary>
<pre><code>
  /* 带约束爬楼梯：动态规划 */
  int climbingStairsConstraintDP(int n) {
    if (n == 1 || n == 2) {
    return 1;
    }
    // 初始化 dp 表，用于存储子问题的解
    vector&ltvector&ltint&gt&gt dp(n + 1, vector&ltint&gt(3, 0));
    // 初始状态：预设最小子问题的解
    dp[1][1] = 1;
    dp[1][2] = 0;
    dp[2][1] = 0;
    dp[2][2] = 1;
    // 状态转移：从较小子问题逐步求解较大子问题
    for (int i = 3; i &lt= n; i++) {
      dp[i][1] = dp[i - 1][2];
      dp[i][2] = dp[i - 2][1] + dp[i - 2][2];
    }
    return dp[n][1] + dp[n][2];//两者之和代表爬到第 𝑛 阶的方案总数
  }
</code></pre>
</details>

<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 60%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/微信截图_20240805214857.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 

<details>
<summary>Click to expand the code。时间复杂度O（N），空间复杂度为O（N）</summary>
<pre><code>
  class Solution {
    public:
        int climbStairs(int n) {
            // n个阶梯对应多少种方法(一共n+1个元素)，也就是状态dp
    
            if(n&lt3)//要大于等于3才适用于动态规划的问题～
                return n;
    
            // 时间复杂度O（N），空间复杂度为O（N）
    
            // step1：定义dp表
            int dp[n+1];//n个状态，对应n+1数组
    
            // step2：定义初始状态
            dp[0]=0;
            dp[1]=1;
            dp[2]=2;//一次性两级，或两次1级
    
            // step3：状态转移方程
            for(int i=3;i&ltn+1;i++)//注意数组是到n+1
            {
                //第n级。有n-1或n-2决定
                dp[i]=dp[i-1]+dp[i-2];//状态转移方程。
            }
    
            return dp[n];//最后返回第n阶梯的时候的解决方案
        }
    };
</code></pre>
</details>

<p><br></p>
<h1>2.编辑距离</h1>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 60%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/微信截图_20240805215323.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
<details>
<summary>Click to expand the code。（此题中，注释相对比较规范化了动态规划问题的解题~）时间复杂度O（M*N），空间复杂度为O（M*N）</summary>
<pre><code>
  class Solution {
    public:
        int minDistance(string word1, string word2) {
            // 解法：动态规划
            // 步骤1：创建动态规划的数组，dp[i][j]代表第i-1和j-1个字符的对比
            int dp[word1.size()+1][word2.size()+1];
    
            // 步骤1：初始化数组：当某个数组为0，另一个操作数就等于另外一个的size
            for(int i=0;i&ltword1.size()+1;i++)
            {
                dp[i][0]=i;
            }
            for(int j=0;j&ltword2.size()+1;j++)
            {
                dp[0][j]=j;
            }
    
            // 步骤二：定义状态转移方程
            for(int i=1;i&ltword1.size()+1;i++)
            {
                for(int j=1;j&ltword2.size()+1;j++)
                {
                    if(word1[i-1]==word2[j-1])//如果两个字符相等,退化为dp【i-1】【j-1】
                        dp[i][j]=dp[i-1][j-1];
                    else //如果不相等：删掉j，删掉i,替换.(+1为本次操作数)
                        dp[i][j]=min(min(dp[i][j-1],dp[i-1][j]),dp[i-1][j-1])+1;
                }
            }
    
            return dp[word1.size()][word2.size()];
    
        }
    };
</code></pre>
</details>

<p><br></p>
<h1>3. 斐波那契数列</h1>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 60%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/微信截图_20240805220055.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
<details>
<summary>解法1：动态规划Click to expand the code。时间复杂度O（N），空间复杂度为O（N）</summary>
<pre><code>
  class Solution {
    public:
        int fib(int n) {
    
            //首先只有大于2才适用
            if(n&lt2)
                return n;
            
            //step1：定义dp表
            int dp[n+1]; //对应于状态n
    
            // step2：状态的初始化
            dp[0]=0;
            dp[1]=1;
    
            // step3:自下而上，推到状态方程
            for(int i=2;i&ltn+1;i++)
            {
                dp[i]=dp[i-1]+dp[i-2];//后面的每一项数字都是前面两项数字的和
            }
    
            return dp[n];
    
        }
    };
</code></pre>
</details>

<details>
<summary>用递归的思路解题也很简单。但是这个递归调用次数类似于计算一棵二叉树的节点数，树的高度为𝑛所以时间复杂度为O（2<sup>N</sup>）。空间复杂度主要由递归调用的栈空间决定。每次递归调用都会占用一定的栈空间，递归的最大深度为𝑛，因此空间复杂度为：𝑂(N)</summary>
<pre><code>
  class Solution {
    public:
        int fib(int n) {
    
            //首先只有大于2才适用
            if(n&lt2)
                return n;
            
            return fib(n-1)+fib(n-2);
    
        }
    };
</code></pre>
</details>

<p>
  上面递归方法如果改为带有【备忘录】的写法，时间复杂度就会降低到O（N），所谓的备忘录写法其实就是对于每个结果都先记录着，如果这个结果被计算过了，就不重新计算，直接获值。也就是说动态规划其实就是相当于带有【备忘录】的递归。只是一个是自下而上，一个是自上而下。
  </p>
<details>
<summary>带有【备忘录】的递归</summary>
<pre><code>
  class Solution {
    public:
        // 带着备忘录进行递归
        int dp(int memo[], int n) {
            
            if (n == 0 || n == 1) 
                return n;//递归终止
    
            if (memo[n] != 0)  // 已经计算过，不用再计算了
                return memo[n];
                
            memo[n] = dp(memo, n - 1) + dp(memo, n - 2);
            return memo[n];
        }
        
        int fib(int n) {
    
            int memo[n + 1];
            memset(memo, 0, sizeof(memo));// 备忘录全初始化为 0
            // 进行带备忘录的递归
            return dp(memo, n);
    
        }    
    };
</code></pre>
</details>

<details>
<summary>对于上面解法1的动态规划解法。进一步的把空间复杂度降为 O(1)。当前状态 n 只和之前的 n-1, n-2 两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态</summary>
<pre><code>
  class Solution {
    public:
        int fib(int n) {
    
            //首先只有大于2才适用
            if(n&lt2)
                return n;
            
            //step1：定义dp表
            // int dp[n+1]; //对应于状态n
    
            // step2：状态的初始化
            // dp[0]=0;
            // dp[1]=1;
            int dp_i_2=0;
            int dp_i_1=1;
    
            // step3:自下而上，推到状态方程
            for(int i=2;i&ltn+1;i++)
            {
                // dp[i]=dp[i-1]+dp[i-2];//后面的每一项数字都是前面两项数字的和
                int dp_i=dp_i_1+dp_i_2;
    
                // 滚动更新
                dp_i_2=dp_i_1;
                dp_i_1=dp_i;
            }
    
            // return dp[n];
            return dp_i_1;
    
        }
    };
</code></pre>
</details>

<p><br></p>
<h1>4.零钱兑换</h1>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 60%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/微信截图_20240805222949.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
<details>
<summary>Click to expand the code.此题的难点就是用什么作为状态，如何确定dp表。</summary>
<pre><code>
  class Solution {
    public:
        int coinChange(vector<int>& coins, int amount) {
    
            if(coins.size()==0)
                return -1;
    
            // // step!:确定状态，建立dp表。唯一可能的状态就是amount了
            // int dp[amount+1];//状态amount时,需要的最小的硬币的数量
            // // 注意初始化为amount + 1 ，因为凑成 amount 金额的硬币数最多只可能等于 amount（全用 1 元面值的硬币）
            // // 所以初始化为 amount + 1 就相当于初始化为正无穷
            vector&ltint&gt dp(amount + 1, amount + 1);//这个写法正确且简单
    
            // step2：确立初始状态
            dp[0]=0;
            // for(int i=1;i&ltamount+1;i++)
            // {
            //     dp[i]=amount+1;
            // }
    
            // step3: 确定状态转移方程
            for(int n=0; n&ltamount+1; n++)
            {
                for(int each_coin:coins)
                {
                    // 减去当前的面值小于0，那么当前面值不适用,跳过使用下一个试试
                    if(n-each_coin&lt0)
                    {
                        continue;
                    }
                    else//若当前面值可以用
                    {
                        //当前n的最小值由当前n(不选硬币)
                        // 以及
                        // 当前面值选择这个硬币，那么就是n减去each_coin的组成
                      dp[n]=min(dp[n],1+dp[n-each_coin]);
                    }
    
                }
            }
            return (dp[amount]==amount+1)? -1: dp[amount];
        }
    };
</code></pre>
</details>

<p><br></p>
<h1>5. 最长递增子序列</h1>

<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 60%;" src="https://kwanwaipang.github.io/Poster_files/learning_algorithm/dynamic_programming/微信截图_20240806204942.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 

<details>
<summary>Click to expand the code。用了两个for循环，时间复杂度为O（N<sup>2</sup>）,空间复杂度为O（N）也就是存储的dp表</summary>
<pre><code>
  class Solution {
    public:
        int lengthOfLIS(vector&ltint&gt& nums) {
    
            // step1：定义dp表。状态变量应该就是n=nums.size()了吧，也是唯一的变量
            int n=nums.size();
            int dp[n];
    
            // step2：确定初始状态
            for(int i=0; i&ltn;i++)
            {
                dp[i]=1;//自身，长度就是1了
            }
    
            // step3:状态转移方程
            // 对于状态dp[i]。以及在i前的状态j。
            // 若nums【i】&gtnums【j】.那么dp【i】为dp【i】（其他值）与dp【j】+1之间的最值
            int max_len=1;
            for(int i=0;i&ltn;i++)
            {
                for(int j=0;j&lti;j++)
                {
                    if(nums[i]&gtnums[j]) //注意nums只能访问到n-1
                        dp[i]=max(dp[i], dp[j]+1);//循环的其他j也参与了对比的。只是只记录最大值
                }
                max_len=max(max_len,dp[i]);//dp[i]为最大的
            }
    
            return max_len;//不能直接返回dp[n-1]，因为这是n-1位置时最大的，不是全部最大的~
        }
    };
</code></pre>
</details>

<p>
  通过本例与上面样例4可以发现。寻找动态规划的状态转移方程的通用技巧：数学归纳法！
  <br>
  所谓的数学归纳法其实就是。比如我们想证明一个数学结论，那么我们先假设这个结论在 k &lt n 时成立，然后根据这个假设，想办法推导证明出 k = n 的时候此结论也成立。如果能够证明出来，那么就说明这个结论对于 k 等于任何数都成立。

</p>

<p><br></p>
<h1>6. 俄罗斯套娃信封问题</h1>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 60%;" src="../assets/img/dynamic_programming/微信截图_20240806214015.png" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure> 
<details>
<summary>此题相当于上面题目的二维版本，但是需要对数组先进行排列。但是leetcode上下面代码运行会超时，只能通过85/87.时间复杂度为O（N<sup>2</sup>）,空间复杂度为O（N）</summary>
<pre><code>
  class Solution {
    public:
        // // 要设置为静态成员函数
        // static bool compareFunction(vector<int>& a, vector<int>& b)
        // {
        //     return a[0]==b[0]? a[1]&gtb[1] : a[0] &gt b[0];
        // }
        int maxEnvelopes(vector&ltvector&ltint&gt&gt& envelopes) {
    
            // //注意需要先对数组进行排序
            // sort(envelopes.begin(),envelopes.end(),compareFunction);
            // 也可以采用lambda表达式
            sort(envelopes.begin(), envelopes.end(), [](vector&ltint&gt& a, vector&ltint&gt& b) {
                return a[0] == b[0] ? a[1]&gtb[1] : a[0] &gt b[0];
            });
    
            // step1: 定义dp表
            int n=envelopes.size();
            // int dp[n];
            vector&ltint&gt dp(n,1);
    
            // // step2:初始化状态
            // for(int i=0;i &lt n;i++)
            // {
            //     dp[i]=1;//最小的可能为1
            // }
    
            int max_num=0;
            for(int i=0;i &lt n;i++)//当前信封
            {
                for(int j=0; j &lt i;j++)//另一个信封
                {
                    // 当不满足要求
                    if(envelopes[i][0]&ltenvelopes[j][0] && envelopes[i][1]&ltenvelopes[j][1])
                    {
                        dp[i]=max(dp[i], dp[j]+1);
                    }
                }
                max_num=max(max_num,dp[i]);
            }
    
            return max_num;
        }
    };
</code></pre>
</details>
<details>
<summary>Click to expand the code。二分法解题将复杂度降低为O（NlogN）</summary>
<pre><code>
  class Solution {
    public:
        int maxEnvelopes(vector&ltvector&ltint&gt&gt& envelopes) {
            // 先按照宽度升序排序，如果宽度相同，则按高度降序排序
            sort(envelopes.begin(), envelopes.end(), [](const vector&ltint&gt& a, const vector&ltint&gt& b) {
                return a[0] == b[0] ? a[1] &gt b[1] : a[0] &lt b[0];
            });
    
            // 用一个数组来存放高度的最长递增子序列
            vector&ltint&gt lis;
    
            // 对每一个信封的高度进行处理
            for (const vector&ltint&gt& envelope : envelopes) {
                int height = envelope[1];
    
                // 使用二分查找找到第一个不小于当前高度的位置
                auto it = lower_bound(lis.begin(), lis.end(), height);
    
                // 如果没有找到，说明当前高度是目前最大的，直接添加到 lis 中
                if (it == lis.end()) {
                    lis.push_back(height);
                } else {
                    // 否则，用当前高度替换掉找到的位置的值
                    *it = height;
                }
            }
    
            // lis 的长度即为最长递增子序列的长度，也就是最多信封嵌套的数量
            return lis.size();
        }
    };
    
</code></pre>
</details>


<!-- 标签内使用 &lt; 和 &gt; 来代替 < 和 > -->

<!-- <details>
<summary>Click to expand the code</summary>
<pre><code>
</code></pre>
</details> -->

<!-- <p><br></p>
<h1></h1>
<figure style="text-align: center;">
  <div style="margin-bottom: 10px;">
    <img style="width: 60%;" src="../assets/img/dynamic_programming/" alt="Image description">
  </div>
<figcaption><p>
</p></figcaption>
</figure>  -->

<p><br></p>
<h1>参考资料</h1>
<ul>
  <li><a href="https://leetcode.cn/u/kwan-wai-pang/" target="_blank">My Leetcode</a></li>
  <li><a href="https://labuladong.online/algo/essential-technique/dynamic-programming-framework-2/" target="_blank">动态规划解题套路框架</a></li>
  <li><a href="https://www.bilibili.com/video/BV1XV411Y7oE/?vd_source=a88e426798937812a8ffc1a9be5a3cb7" target="_blank">动态规划问题的讲解视频</a></li>
</ul>

</article>
</div>
</div>

<!-- Footer --> 
<p><br></p>   
<footer class="nofixed-bottom">
<div class="container mt-0" style="width:100%;text-align:center;">
  Please feel free to contact me through <a href="https://kwanwaipang.github.io/" target="_blank">my personal website</a>
</div>
</footer> 

    <!-- JavaScripts -->
    <!-- jQuery -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>

    <!-- Bootsrap & MDB scripts -->
  <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.2/dist/umd/popper.min.js" integrity="sha256-l/1pMF/+J4TThfgARS6KwWrk/egwuVvhRzfLAMQ6Ds4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.min.js" integrity="sha256-SyTu6CwrfOhaznYZPoolVw2rxoY7lKYKQvqbtqN93HI=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script>

    <!-- Masonry & imagesLoaded -->
  <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
  <script defer src="/ecmd/assets/js/masonry.js" type="text/javascript"></script>

  <!-- Medium Zoom JS -->
  <script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script>
  <script src="/ecmd/assets/js/zoom.js"></script><!-- Load Common JS -->
  <script src="/ecmd/assets/js/common.js"></script>

    <!-- MathJax -->
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        tags: 'ams'
      }
    };
  </script>
  <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
  <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>

</body>
</html>

