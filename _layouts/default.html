<!DOCTYPE html>
<html>
  {% include head.html %}
  <body>
    {% include nav.html %}

    <!-- 如果当前页面的toc为true，就添加目录 -->
    {% if page.toc==true %}
      <aside class="toc">
        {% include toc.html html=content %}
      </aside>
    {% endif %}

    <div id="main" role="main" class="wrapper-content">
      <div class="container">
        {{ content }}
      </div>
    </div>

    <!-- Google Analytics -->
    {% include analytics.html %}

<!-- 识别latex公式并渲染 -->
<script>
  // 先在 MathJax 加载前修复 HTML
  document.addEventListener('DOMContentLoaded', function() {
    const content = document.querySelector('.wrapper-content') || document.body;
    
    // 递归处理所有元素
    function fixMathInElement(element) {
      if (element.classList && (element.classList.contains('mermaid') || element.classList.contains('highlight'))) {
        return;
      }
      
      // 直接处理元素的 innerHTML
      if (element.innerHTML && element.innerHTML.includes('$')) {
        let html = element.innerHTML;
        let originalHtml = html;
        
        // 修复行内公式 $...$
        // 使用非贪婪匹配，避免跨越多个公式
        html = html.replace(/\$([^\$]+?)\$/g, (match, formula) => {
          // 移除公式内的 HTML 标签
          let fixed = formula
            .replace(/<em>/gi, '_')
            .replace(/<\/em>/gi, '_')
            .replace(/<strong>/gi, '')
            .replace(/<\/strong>/gi, '')
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&amp;/g, '&');
          return '$' + fixed + '$';
        });
        
        // 修复块级公式 $$...$$
        html = html.replace(/\$\$([^\$]+?)\$\$/gs, (match, formula) => {
          let fixed = formula
            .replace(/<em>/gi, '_')
            .replace(/<\/em>/gi, '_')
            .replace(/<strong>/gi, '')
            .replace(/<\/strong>/gi, '')
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&amp;/g, '&');
          return '$$' + fixed + '$$';
        });
        
        if (html !== originalHtml) {
          element.innerHTML = html;
        }
      }
      
      // 递归处理子元素
      Array.from(element.children).forEach(child => {
        fixMathInElement(child);
      });
    }
    
    fixMathInElement(content);
  });
</script>
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      processEscapes: true,
      packages: {'[+]': ['boldsymbol', 'ams']}
    },
    loader: {
      load: ['[tex]/boldsymbol', '[tex]/ams']
    },
    options: {
      ignoreHtmlClass: 'mermaid|highlight'
    }
  };
</script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js">
</script>

<!-- 每当页面检测到 Mermaid 代码块时，浏览器会自动将其渲染为流程图。 -->
<script src="https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.1/dist/svg-pan-zoom.min.js"></script>
<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';

  // 1. 初始化 Mermaid
  mermaid.initialize({ 
    startOnLoad: false, 
    theme: 'default',
    securityLevel: 'loose',
    flowchart: { 
        htmlLabels: true,     // 必须开启
        useMaxWidth: false,
        curve: 'basis'
    }
  });

  // 辅助函数：解码 HTML 实体
  function decodeHtmlEntities(text) {
    const txt = document.createElement("textarea");
    txt.innerHTML = text;
    return txt.value;
  }

  document.addEventListener('DOMContentLoaded', async () => {
    const elements = document.querySelectorAll('.mermaid');
    
    for (let i = 0; i < elements.length; i++) {
      const element = elements[i];
      const id = `mermaid-svg-${i}`;

      // --- 核心修复：处理换行符 ---
      // 1. 获取 HTML 内容而非纯文本，保留 <br> 标签结构
      let graphDefinition = element.innerHTML;
      
      // 2. 将被 Jekyll 转义的 &lt;br&gt; 或 &lt;br/&gt; 还原为真正的换行
      // 同时处理Markdown中可能的实体编码
      graphDefinition = graphDefinition
        .replace(/&lt;br\s*\/?&gt;/gi, '<br/>')  // 修复转义的 br
        .replace(/&amp;/g, '&')                 // 修复 & 符号
        .replace(/&quot;/g, '"');               // 修复双引号
      
      // 3. 清理掉多余的 HTML 标签（如果 Jekyll 在里面自动加了 <p> 等）
      // 只保留纯文本和我们需要的 <br>
      graphDefinition = decodeHtmlEntities(graphDefinition); 

      try {
        const { svg } = await mermaid.render(id, graphDefinition);
        element.innerHTML = svg;

        const svgElement = element.querySelector('svg');
        
        // 样式设置
        element.style.height = "700px"; 
        element.style.border = "1px solid #eee";
        element.style.overflow = "hidden";
        element.style.position = "relative";
        element.style.cursor = "grab";

        svgElement.style.width = "100%";
        svgElement.style.height = "100%";
        svgElement.style.maxWidth = "none";

        svgPanZoom(svgElement, {
          zoomEnabled: true,
          controlIconsEnabled: true,
          fit: true,
          center: true,
          minZoom: 0.1,
          maxZoom: 10
        });

      } catch (error) {
        console.error("渲染失败:", error);
        // 出错时保留原文以便调试
        element.style.border = "1px solid red";
      }
    }
  });
</script>

  </body>

  <!-- 如果当前页面的toc为true，就添加目录 -->
  {% if page.toc==true %}
  <script>
    document.getElementById("main").classList.add("withtoc");
  </script>
  {% endif %}

  <div class="wrapper-footer-mobile">
    <footer class="footer">
      {% include footer.html %}
    </footer>
  </div>


</html>
